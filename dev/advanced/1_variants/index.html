<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exploring many model variants · COBREXA.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="COBREXA.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="COBREXA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">COBREXA.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorials/">Quickstart tutorials</a></li><li><a class="tocitem" href="../">Advanced tutorials</a></li><li><a class="tocitem" href="../../notebooks/">Examples and notebooks</a></li><li><a class="tocitem" href="../../functions/">Function reference</a></li><li><a class="tocitem" href="../../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Exploring many model variants</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exploring many model variants</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/advanced/1_variants.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exploring-many-model-variants"><a class="docs-heading-anchor" href="#Exploring-many-model-variants">Exploring many model variants</a><a id="Exploring-many-model-variants-1"></a><a class="docs-heading-anchor-permalink" href="#Exploring-many-model-variants" title="Permalink"></a></h1><p>A major goal of COBREXA.jl is to make exploring of many model variants easy and fast.</p><p>One main concept that can be utilized for doing that is implemented in the function <a href="../../functions/#COBREXA.screen-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{T}, Tuple{V}} where {V&lt;:(AbstractVector{T} where T), T&lt;:Tuple, N}"><code>screen</code></a>, which takes your model, a list of model <em>variants</em> that you want to explore by some specified <em>analysis</em>, and schedules the analysis of the model variants parallely on the available distributed workers.</p><p>In its most basic form, the &quot;screening&quot; may use the slightly simplified variant of <a href="../../functions/#COBREXA.screen-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{T}, Tuple{V}} where {V&lt;:(AbstractVector{T} where T), T&lt;:Tuple, N}"><code>screen</code></a> that is called <a href="../../functions/#COBREXA.screen_variants-Tuple{Any, Any, Any}"><code>screen_variants</code></a>, which works as follows:</p><pre><code class="language-julia">m = load_model(StandardModel, &quot;e_coli_core.json&quot;)

screen_variants(
    m,    # the model for screening
    [
        [],    # a variant with no modifications
        [with_changed_bound(&quot;CO2t&quot;, lb = 0, ub = 0)],  # disable CO2 transport
        [with_changed_bound(&quot;O2t&quot;, lb = 0, ub = 0)],  # disable O2 transport
        [with_changed_bound(&quot;CO2t&quot;, lb = 0, ub = 0), with_changed_bound(&quot;O2t&quot;, lb = 0, ub = 0)],  # disable both transports
    ],
    m -&gt; flux_balance_analysis_dict(m, Tulip.Optimizer)[&quot;BIOMASS_Ecoli_core_w_GAM&quot;],
)</code></pre><p>The call specifies a model (the <code>m</code> that we have loaded) that is being tested, then a vector of model variants to be created and tested, and then the analysis that is being run on each variant – in this case, we find an optimal steady state of each of the variants, and check out the biomass production rate at that state. In this particular case, we are checking what will be the effect of disabling combinations of CO2 transport and O2 transport in the cells. For that, we get the following result:</p><pre><code class="language-none">4-element Vector{Float64}:
 0.8739215022678488
 0.46166961413944896
 0.21166294973372135
 0.21114065173865518</code></pre><p>The numbers are the biomass production rates for the specified variants. We can see that disabling O2 transport really does not help the organism much.</p><h2 id="Variant-specification"><a class="docs-heading-anchor" href="#Variant-specification">Variant specification</a><a id="Variant-specification-1"></a><a class="docs-heading-anchor-permalink" href="#Variant-specification" title="Permalink"></a></h2><p>In the above example, we have specified 4 variants, thus the analysis returned 4 different results that correspond with the specifications. Let us have a look at the precise format of the specification and result.</p><p>Importantly, the <code>variants</code> argument is of type <code>Array{Vector{Any}}</code>, meaning that it can be an array of any dimensionality that contains vectors. Each of the vectors specifies precisely one variant, possibly with more modifications applied to the model in sequence.</p><p>For example:</p><ul><li><code>[]</code> specifies no modifications at all</li><li><code>[with_changed_bound(&quot;CO2t&quot;, lb=0, ub=10)]</code> limits the CO2 transport</li><li><code>[with_changed_bound(&quot;CO2t&quot;, lb=0, ub=2), with_changed_bound(&quot;O2t&quot;, lb=0, ub=100)]</code> severely limits the CO2 transport <em>and</em> slightly restricts the transport of O2</li></ul><div class="admonition is-info"><header class="admonition-header">Variants are single-parameter model-transforming functions</header><div class="admonition-body"><p>Because the variants are just generators of single parameter functions that take the model and return its modified version, you can also use <code>identity</code> to specify a variant that does nothing – <code>[identity]</code> is perfectly same as <code>[]</code></p></div></div><p>The shape of the variants array is important too, because it is precisely retained in the result (just as with <code>pmap</code>). If you pass in a matrix of variants, you will receive a matrix of analysis results of the same size. That can be exploited for easily exploring many combinations of possible model properties. Let&#39;s try exploring a &quot;cube&quot; of possible restricted reactions:</p><pre><code class="language-julia">using IterTools # for cartesian products

res = screen_variants(m,
    [
        # for each variant we restricts 2 reactions
        [with_changed_bound(r1, lb=-3, ub=3), with_changed_bound(r2, lb=-1, ub=1)]

        # the reaction pair will be chosen from a cartesian product
        for (r1,r2) in product(
            [&quot;H2Ot&quot;, &quot;CO2t&quot;, &quot;O2t&quot;, &quot;NH4t&quot;], # of this set of transport reactions
            [&quot;EX_h2o_e&quot;, &quot;EX_co2_e&quot;, &quot;EX_o2_e&quot;, &quot;EX_nh4_e&quot;], # and this set of exchanges
        )
    ],
    m -&gt; flux_balance_analysis_dict(m, Tulip.Optimizer)[&quot;BIOMASS_Ecoli_core_w_GAM&quot;],
)</code></pre><p>As a result, we will receive a full matrix of the biomass productions:</p><pre><code class="language-none">4×4 Matrix{Float64}:
 0.407666  0.454097  0.240106  0.183392
 0.407666  0.485204  0.24766   0.183392
 0.314923  0.319654  0.24766   0.183392
 0.407666  0.485204  0.24766   0.183392</code></pre><p>Notably, this shows that O2 transport and NH4 exchange may be serious bottlenecks for biomass production.</p><p>For clarity, you may always annotate the result by zipping it with the specification structure you have used and collecting the data:</p><pre><code class="language-julia">collect(zip(
    product(
        [&quot;H2Ot&quot;, &quot;CO2t&quot;, &quot;O2t&quot;, &quot;NH4t&quot;],
        [&quot;EX_h2o_e&quot;, &quot;EX_co2_e&quot;, &quot;EX_o2_e&quot;, &quot;EX_nh4_e&quot;],
    ),
    res,
))</code></pre><p>...which gives the following annotated result:</p><pre><code class="language-none">4×4 Matrix{Tuple{Tuple{String, String}, Float64}}:
 ((&quot;H2Ot&quot;, &quot;EX_h2o_e&quot;), 0.407666)  ((&quot;H2Ot&quot;, &quot;EX_co2_e&quot;), 0.454097)  ((&quot;H2Ot&quot;, &quot;EX_o2_e&quot;), 0.240106)  ((&quot;H2Ot&quot;, &quot;EX_nh4_e&quot;), 0.183392)
 ((&quot;CO2t&quot;, &quot;EX_h2o_e&quot;), 0.407666)  ((&quot;CO2t&quot;, &quot;EX_co2_e&quot;), 0.485204)  ((&quot;CO2t&quot;, &quot;EX_o2_e&quot;), 0.24766)   ((&quot;CO2t&quot;, &quot;EX_nh4_e&quot;), 0.183392)
 ((&quot;O2t&quot;, &quot;EX_h2o_e&quot;), 0.314923)   ((&quot;O2t&quot;, &quot;EX_co2_e&quot;), 0.319654)   ((&quot;O2t&quot;, &quot;EX_o2_e&quot;), 0.24766)    ((&quot;O2t&quot;, &quot;EX_nh4_e&quot;), 0.183392)
 ((&quot;NH4t&quot;, &quot;EX_h2o_e&quot;), 0.407666)  ((&quot;NH4t&quot;, &quot;EX_co2_e&quot;), 0.485204)  ((&quot;NH4t&quot;, &quot;EX_o2_e&quot;), 0.24766)   ((&quot;NH4t&quot;, &quot;EX_nh4_e&quot;), 0.183392)</code></pre><p>This may be easily used for e.g. scrutinizing all possible reaction pairs, to find the ones that are redundant and not.</p><div class="admonition is-success"><header class="admonition-header">Notebook available</header><div class="admonition-body"><p>A notebook is available that demonstrates <a href="../../notebooks/6_screening/">the screening on a larger scale</a>.</p></div></div><p>There are many other variant &quot;specifications&quot; to choose from. You may use <a href="../../functions/#COBREXA.with_added_reactions-Tuple"><code>with_added_reactions</code></a>, <a href="../../functions/#COBREXA.with_removed_reactions-Tuple"><code>with_removed_reactions</code></a>, <a href="../../functions/#COBREXA.with_removed_metabolites-Tuple"><code>with_removed_metabolites</code></a>, and others. Function reference contains a complete list; as a convention, names of the specifications all start with <code>with_</code>.</p><h2 id="Writing-custom-variant-functions"><a class="docs-heading-anchor" href="#Writing-custom-variant-functions">Writing custom variant functions</a><a id="Writing-custom-variant-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-custom-variant-functions" title="Permalink"></a></h2><p>It is actually very easy to create custom specifications that do any modification that you can implement, to be later used with <a href="../../functions/#COBREXA.screen_variants-Tuple{Any, Any, Any}"><code>screen_variants</code></a> and <a href="../../functions/#COBREXA.screen-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{T}, Tuple{V}} where {V&lt;:(AbstractVector{T} where T), T&lt;:Tuple, N}"><code>screen</code></a>.</p><p>Generally, the &quot;specifications&quot; are supposed to return a <em>function</em> that creates a modified copy of the model. The copy of the model may be shallow, but the functions should always prevent modifying the original model structure – <code>screen</code> is keeping a single copy of the original model at each worker to prevent unnecessary bulk data transport, and if that is changed in-place, all following analyses of the model will work on inconsistent data, usually returning wrong results (even randomly changing ones, because of the asynchronous nature of <a href="../../functions/#COBREXA.screen-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{T}, Tuple{V}} where {V&lt;:(AbstractVector{T} where T), T&lt;:Tuple, N}"><code>screen</code></a> execution).</p><p>Despite of that, writing a modification is easy. The simplest modification that &quot;does nothing&quot; (isomorphic to standard <code>identity</code>) can be formatted as follows:</p><pre><code class="language-julia">with_no_change = model -&gt; model</code></pre><p>The modifications may change the model, provided it is copied properly. The following modification will remove a reaction called &quot;O2t&quot;, effectively removing the possibility to transport oxygen. We require a specific type of model where this change is easy to perform (generally, not all variants may be feasible on all model types).</p><pre><code class="language-julia">with_disabled_oxygen_transport = (model::StandardModel) -&gt; begin

    # make &quot;as shallow as possible&quot; copy of the `model`.
    # Utilizing `deepcopy` is also possible, but inefficient.
    new_model = copy(model)
    new_model.reactions = copy(model.reactions)

    # remove the O2 transport from the model copy
    delete!(new_model.reactions, &quot;O2t&quot;)

    return new_model #return the newly created variant
end</code></pre><p>Finally, the whole definition may be parametrized as a normal function. The following variant removes any user-selected reaction:</p><pre><code class="language-julia">with_disabled_reaction(reaction_id) = (model::StandardModel) -&gt; begin
    new_model = copy(model)
    new_model.reactions = copy(model.reactions)
    delete!(new_model.reactions, reaction_id) # use the parameter from the specification
    return new_model
end</code></pre><p>In turn, these variants can be used in <a href="../../functions/#COBREXA.screen_variants-Tuple{Any, Any, Any}"><code>screen_variants</code></a> just as we used <a href="../../functions/#COBREXA.with_changed_bound-Tuple"><code>with_changed_bound</code></a> above:</p><pre><code class="language-julia">screen_variants(
    m,    # the model for screening
    [
        [with_no_change],
        [with_disabled_oxygen_transport],
        [with_disabled_reaction(&quot;NH4t&quot;)],
    ],
    m -&gt; flux_balance_analysis_dict(m, Tulip.Optimizer)[&quot;BIOMASS_Ecoli_core_w_GAM&quot;],
)</code></pre><p>That should get you the results for all new variants of the model:</p><pre><code class="language-none">3-element Vector{Float64}:
 0.8739215022674809
 0.21166294865468896
 1.2907224478973395e-15</code></pre><div class="admonition is-warning"><header class="admonition-header">Custom variants with distributed processing</header><div class="admonition-body"><p>If using distributed evaluation, remember the variant-generating functions need to be defined on all used workers (generating the variants in parallel on the workers allows COBREXA to run the screening process very efficiently, without unnecessary sending of bulk model data). Prefixing the definition with <code>@everywhere</code> is usually sufficient for that purpose.</p></div></div><h2 id="Passing-extra-arguments-to-the-analysis-function"><a class="docs-heading-anchor" href="#Passing-extra-arguments-to-the-analysis-function">Passing extra arguments to the analysis function</a><a id="Passing-extra-arguments-to-the-analysis-function-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-extra-arguments-to-the-analysis-function" title="Permalink"></a></h2><p>Some analysis functions may take additional arguments, which you might want to vary for the analysis. <code>modifications</code> argument of <a href="../../functions/#COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any, N} where N}"><code>flux_balance_analysis_dict</code></a> is one example of such argument, allowing you to specify details of the optimization procedure.</p><p><a href="../../functions/#COBREXA.screen-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{T}, Tuple{V}} where {V&lt;:(AbstractVector{T} where T), T&lt;:Tuple, N}"><code>screen</code></a> function allows you to do precisely that – apart from <code>variants</code>, you may also specify an array of <code>args</code> of the same shape as <code>variants</code>, the entries of which will get passed together with the generated model variants to your specified analysis function. If either of the arguments is missing (or set to <code>nothing</code>), it is defaulted to &quot;no modifications&quot; or &quot;no arguments&quot;.</p><p>The arguments <em>must</em> be tuples; you may need to make 1-tuples from your data (e.g. using <code>(value,)</code>) if you want to pass just a single argument.</p><p>Let&#39;s try to use that functionality for trying to find a sufficient amount of iterations needed for Tulip solver to find a feasible solution:</p><pre><code class="language-julia">screen(m,
    args = [(i,) for i in 5:15],  # the iteration counts, packed in 1-tuples
    analysis = (m,a) -&gt; # `args` elements get passed as the extra parameter here
        flux_balance_analysis_vec(m,
            Tulip.Optimizer;
            modifications=[change_optimizer_attribute(&quot;IPM_IterationsLimit&quot;, a)],
        ),
)</code></pre><p>From the result, we can see that Tulip would need at least 14 iterations to find a feasible region:</p><pre><code class="language-none">11-element Vector{Union{Nothing, Vector{Float64}}}:
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 nothing
 [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]
 [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 4 August 2021 10:43">Wednesday 4 August 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
