<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis functions · COBREXA.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="COBREXA.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="COBREXA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">COBREXA.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">COBREXA.jl in 10 minutes</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Contents</a></li><li><a class="tocitem" href="../../examples/01_loading/">Loading models</a></li><li><a class="tocitem" href="../../examples/02_convert_save/">Converting, modifying and saving models</a></li><li><a class="tocitem" href="../../examples/03_exploring/">Exploring model contents</a></li><li><a class="tocitem" href="../../examples/03b_accessors/">Generic accessors</a></li><li><a class="tocitem" href="../../examples/04_core_model/"><code>CoreModel</code> usage</a></li><li><a class="tocitem" href="../../examples/04_standardmodel/">Basic usage of <code>StandardModel</code></a></li><li><a class="tocitem" href="../../examples/04b_standardmodel_construction/">Model construction and modification</a></li><li><a class="tocitem" href="../../examples/05a_fba/">Flux balance analysis (FBA)</a></li><li><a class="tocitem" href="../../examples/05b_fba_mods/">Extending FBA with modifications</a></li><li><a class="tocitem" href="../../examples/06_fva/">Flux variability analysis (FVA)</a></li><li><a class="tocitem" href="../../examples/07_gene_deletion/">Gene knockouts</a></li><li><a class="tocitem" href="../../examples/07_restricting_reactions/">Restricting and disabling individual reactions</a></li><li><a class="tocitem" href="../../examples/08_pfba/">Parsimonious flux balance analysis (pFBA)</a></li><li><a class="tocitem" href="../../examples/09_loopless/">Loopless FBA</a></li><li><a class="tocitem" href="../../examples/10_crowding/">FBA with crowding</a></li><li><a class="tocitem" href="../../examples/11_growth/">Growth media analysis</a></li><li><a class="tocitem" href="../../examples/12_mmdf/">Maximum-minimum driving force analysis</a></li><li><a class="tocitem" href="../../examples/13_moma/">Minimization of metabolic adjustment (MOMA)</a></li><li><a class="tocitem" href="../../examples/14_smoment/">sMOMENT</a></li><li><a class="tocitem" href="../../examples/15_gecko/">GECKO</a></li><li><a class="tocitem" href="../../examples/16_hit_and_run/">Hit and run sampling</a></li><li><a class="tocitem" href="../../examples/17_envelopes/">Production envelopes</a></li></ul></li><li><span class="tocitem">Parallel, distributed and HPC processing</span><ul><li><a class="tocitem" href="../../distributed/">Contents</a></li><li><a class="tocitem" href="../../distributed/1_functions/">Parallel processing overview</a></li><li><a class="tocitem" href="../../distributed/2_parallel/">Local parallel processing</a></li><li><a class="tocitem" href="../../distributed/3_slurm/">Working in a HPC environment</a></li><li><a class="tocitem" href="../../distributed/4_serialized/">Faster model distribution</a></li></ul></li><li><span class="tocitem">Core concepts guide</span><ul><li><a class="tocitem" href="../../concepts/">Contents</a></li><li><a class="tocitem" href="../../concepts/1_screen/">Screening many model variants</a></li><li><a class="tocitem" href="../../concepts/2_modifications/">Writing custom optimizer modifications</a></li><li><a class="tocitem" href="../../concepts/3_custom_models/">Working with custom models</a></li><li><a class="tocitem" href="../../concepts/4_wrappers/">Extending the models</a></li></ul></li><li><span class="tocitem">Reference (Functions and types)</span><ul><li><a class="tocitem" href="../">Contents</a></li><li class="is-active"><a class="tocitem" href>Analysis functions</a><ul class="internal"><li><a class="tocitem" href="#Common-analysis-functions"><span>Common analysis functions</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Analysis-modifiers"><span>Analysis modifiers</span></a></li></ul></li><li><a class="tocitem" href="../base/">Base functions</a></li><li><a class="tocitem" href="../io/">Input and output</a></li><li><a class="tocitem" href="../reconstruction/">Model construction functions</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul></li><li><a class="tocitem" href="../../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference (Functions and types)</a></li><li class="is-active"><a href>Analysis functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/functions/analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Analysis-functions"><a class="docs-heading-anchor" href="#Analysis-functions">Analysis functions</a><a id="Analysis-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-functions" title="Permalink"></a></h1><h2 id="Common-analysis-functions"><a class="docs-heading-anchor" href="#Common-analysis-functions">Common analysis functions</a><a id="Common-analysis-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-analysis-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}" href="#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}"><code>COBREXA.envelope_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">envelope_lattice(model::MetabolicModel, ridxs::Vector{Int64}; samples, ranges, reaction_samples) -&gt; Base.Generator{_A, COBREXA.var&quot;#448#449&quot;} where _A
</code></pre><p>Create a lattice (list of &quot;tick&quot; vectors) for reactions at indexes <code>ridxs</code> in a model. Arguments <code>samples</code>, <code>ranges</code>, and <code>reaction_samples</code> may be optionally specified to customize the lattice creation process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/envelopes.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{String}}" href="#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{String}}"><code>COBREXA.envelope_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">envelope_lattice(model::MetabolicModel, rids::Vector{String}; kwargs...) -&gt; Base.Generator{_A, COBREXA.var&quot;#448#449&quot;} where _A
</code></pre><p>Version of <a href="#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}"><code>envelope_lattice</code></a> that works on string reaction IDs instead of integer indexes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/envelopes.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{Int64}, Any}" href="#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{Int64}, Any}"><code>COBREXA.objective_envelope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objective_envelope(model::MetabolicModel, ridxs::Vector{Int64}, optimizer; modifications, lattice_args, lattice, analysis, kwargs...) -&gt; NamedTuple{(:lattice, :values), _A} where _A&lt;:Tuple{Any, Array}
</code></pre><p>Compute an array of objective values for the <code>model</code> for rates of reactions specified <code>ridxs</code> fixed to a regular range of values between their respective lower and upper bounds.</p><p>This can be used to compute a &quot;production envelope&quot; of a metabolite; but generalizes to any specifiable objective and to multiple dimensions of the examined space. For example, to retrieve a production envelope of any metabolite, set the objective coefficient vector of the <code>model</code> to a vector that contains a single <code>1</code> for the exchange reaction that &quot;outputs&quot; this metabolite, and run <a href="#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{Int64}, Any}"><code>objective_envelope</code></a> with the exchange reaction of the &quot;parameter&quot; metabolite specified in <code>ridxs</code>.</p><p>Returns a named tuple that contains <code>lattice</code> with reference values of the metabolites, and an N-dimensional array <code>values</code> with the computed objective values, where N is the number of specified reactions.  Because of the increasing dimensionality, the computation gets very voluminous with increasing length of <code>ridxs</code>. The <code>lattice</code> for computing the optima can be supplied in the argument; by default it is created by <a href="#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}"><code>envelope_lattice</code></a> called on the model and reaction indexes. Additional arguments for the call to <a href="#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}"><code>envelope_lattice</code></a> can be optionally specified in <code>lattice_args</code>.</p><p><code>kwargs</code> are internally forwarded to <a href="#COBREXA.screen_optmodel_modifications-Tuple"><code>screen_optmodel_modifications</code></a>. <code>modifications</code> are appended to the list of modifications after the lattice bounds are set. By default, this returns the objective values for all points in the lattice; alternate outputs can be implemented via the <code>analysis</code> argument.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; m = load_model(&quot;e_coli_core.xml&quot;);

julia&gt; envelope = objective_envelope(m, [&quot;R_EX_gln__L_e&quot;, &quot;R_EX_fum_e&quot;],
                                     Tulip.Optimizer;
                                     lattice_args=(samples=6,));

julia&gt; envelope.lattice   # the reaction rates for which the optima were computed
2-element Vector{Vector{Float64}}:
 [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]
 [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]

julia&gt; envelope.values   # the computed flux objective values for each reaction rate combination
6×6 Matrix{Float64}:
  0.873922   9.25815  17.4538  19.56   20.4121  20.4121
 13.0354    17.508    19.9369  21.894  22.6825  22.6825
 16.6666    18.6097   20.2847  21.894  22.6825  22.6825
 16.6666    18.6097   20.2847  21.894  22.6825  22.6825
 16.6666    18.6097   20.2847  21.894  22.6825  22.6825
 16.6666    18.6097   20.2847  21.894  22.6825  22.6825</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/envelopes.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{String}, Vararg{Any}}" href="#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{String}, Vararg{Any}}"><code>COBREXA.objective_envelope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objective_envelope(model::MetabolicModel, rids::Vector{String}, args...; kwargs...) -&gt; NamedTuple{(:lattice, :values), _A} where _A&lt;:Tuple{Any, Array}
</code></pre><p>Version of <a href="#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{Int64}, Any}"><code>objective_envelope</code></a> that works on string reaction IDs instead of integer indexes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/envelopes.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel" href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>COBREXA.flux_balance_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux_balance_analysis(model::MetabolicModel, optimizer; modifications) -&gt; JuMP.Model
</code></pre><p>Run flux balance analysis (FBA) on the <code>model</code> optionally specifying <code>modifications</code> to the problem.  Basically, FBA solves this optimization problem:</p><pre><code class="language-none">max cᵀx
s.t. S x = b
     xₗ ≤ x ≤ xᵤ</code></pre><p>See &quot;Orth, J., Thiele, I. &amp; Palsson, B. What is flux balance analysis?. Nat Biotechnol 28, 245-248 (2010). https://doi.org/10.1038/nbt.1614&quot; for more information.</p><p>The <code>optimizer</code> must be set to a <code>JuMP</code>-compatible optimizer, such as <code>GLPK.Optimizer</code> or <code>Tulip.Optimizer</code></p><p>Optionally, you may specify one or more modifications to be applied to the model before the analysis, such as <a href="#COBREXA.change_optimizer_attribute-Tuple{Any, Any}"><code>change_optimizer_attribute</code></a>, <a href="#COBREXA.change_objective-Tuple{Union{String, Vector{String}}}"><code>change_objective</code></a>, and <a href="#COBREXA.change_sense-Tuple{Any}"><code>change_sense</code></a>.</p><p>Returns an optimized <code>JuMP</code> model.</p><p><strong>Example</strong></p><pre><code class="language-none">model = load_model(&quot;e_coli_core.json&quot;)
solution = flux_balance_analysis(model, GLPK.optimizer)
value.(solution[:x])  # extract flux steady state from the optimizer

biomass_reaction_id = findfirst(model.reactions, &quot;BIOMASS_Ecoli_core_w_GAM&quot;)

modified_solution = flux_balance_analysis(model, GLPK.optimizer;
    modifications=[change_objective(biomass_reaction_id)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_balance_analysis.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}" href="#COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}"><code>COBREXA.flux_balance_analysis_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux_balance_analysis_dict(model::MetabolicModel, args...; kwargs...) -&gt; Union{Nothing, Dict{String, Float64}}
</code></pre><p>A variant of FBA that returns a dictionary assigning fluxes to reactions, if the solution is found. Arguments are passed to <a href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a>.</p><p>This function is kept for backwards compatibility, use <a href="../base/#COBREXA.flux_dict-Tuple{MetabolicModel, Any}"><code>flux_dict</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_balance_analysis.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}" href="#COBREXA.flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}"><code>COBREXA.flux_balance_analysis_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux_balance_analysis_vec(model::MetabolicModel, args...; kwargs...) -&gt; Union{Nothing, Vector{Float64}}
</code></pre><p>A variant of FBA that returns a vector of fluxes in the same order as reactions of the model, if the solution is found.</p><p>Arguments are passed to <a href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a>.</p><p>This function is kept for backwards compatibility, use <a href="../base/#COBREXA.flux_vector-Tuple{MetabolicModel, Any}"><code>flux_vector</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_balance_analysis.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._max_variability_flux-NTuple{4, Any}" href="#COBREXA._max_variability_flux-NTuple{4, Any}"><code>COBREXA._max_variability_flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_max_variability_flux(opt_model, flux, sense, ret) -&gt; Any
</code></pre><p>Internal helper for maximizing reactions in optimization model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_variability_analysis.jl#L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}" href="#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>COBREXA.flux_variability_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux_variability_analysis(model::MetabolicModel, optimizer; kwargs...) -&gt; Array
</code></pre><p>A simpler version of <a href="#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis</code></a> that maximizes and minimizes all declared fluxes in the model. Arguments are forwarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_variability_analysis.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.flux_variability_analysis-Tuple{MetabolicModel, SparseArrays.SparseMatrixCSC{Float64, Int64}, Any}" href="#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, SparseArrays.SparseMatrixCSC{Float64, Int64}, Any}"><code>COBREXA.flux_variability_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux_variability_analysis(model::MetabolicModel, fluxes::SparseArrays.SparseMatrixCSC{Float64, Int64}, optimizer; modifications, workers, optimal_objective_value, bounds, ret) -&gt; Array
</code></pre><p>Flux variability analysis solves a pair of optimization problems in <code>model</code> for each flux <code>f</code> described in <code>fluxes</code>:</p><pre><code class="language-none">min,max fᵀxᵢ
s.t. S x = b
    xₗ ≤ x ≤ xᵤ
     cᵀx ≥ bounds(Z₀)[1]
     cᵀx ≤ bounds(Z₀)[2]</code></pre><p>where Z₀:= cᵀx₀ is the objective value of an optimal solution of the associated FBA problem (see <a href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a> for a related analysis, also for explanation of the <code>modifications</code> argument).</p><p>The <code>bounds</code> is a user-supplied function that specifies the objective bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in FBA. It can return <code>-Inf</code> and <code>Inf</code> in first and second pair to remove the limit. Use <a href="../utils/#COBREXA.gamma_bounds-Tuple{Any}"><code>gamma_bounds</code></a> and <a href="../utils/#COBREXA.objective_bounds-Tuple{Any}"><code>objective_bounds</code></a> for simple bounds.</p><p><code>optimizer</code> must be set to a <code>JuMP</code>-compatible optimizer. The computation of the individual optimization problems is transparently distributed to <code>workers</code> (see <code>Distributed.workers()</code>).  The value of Z₀ can be optionally supplied in argument <code>optimal_objective_value</code>, which prevents this function from calling the non-parallelizable FBA. Separating the single-threaded FBA and multithreaded variability computation can be used to improve resource allocation efficiency in many common use-cases.</p><p><code>ret</code> is a function used to extract results from optimized JuMP models of the individual fluxes. By default, it calls and returns the value of <code>JuMP.objective_value</code>. More information can be extracted e.g. by setting it to a function that returns a more elaborate data structure; such as <code>m -&gt; (JuMP.objective_value(m), JuMP.value.(m[:x]))</code>.</p><p>Returns a matrix of extracted <code>ret</code> values for minima and maxima, of total size (<code>size(fluxes,2)</code>,2). The optimizer result status is checked with <a href="../base/#COBREXA.is_solved-Tuple{Any}"><code>is_solved</code></a>; <code>nothing</code> is returned if the optimization failed for any reason.</p><p><strong>Example</strong></p><pre><code class="language-none">model = load_model(&quot;e_coli_core.json&quot;)
flux_variability_analysis(model, [1, 2, 3, 42], GLPK.optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_variability_analysis.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}" href="#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}"><code>COBREXA.flux_variability_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux_variability_analysis(model::MetabolicModel, flux_indexes::Vector{Int64}, optimizer; kwargs...) -&gt; Array
</code></pre><p>An overload of <a href="#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis</code></a> that explores the fluxes specified by integer indexes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_variability_analysis.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.flux_variability_analysis_dict-Tuple{MetabolicModel, Any}" href="#COBREXA.flux_variability_analysis_dict-Tuple{MetabolicModel, Any}"><code>COBREXA.flux_variability_analysis_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux_variability_analysis_dict(model::MetabolicModel, optimizer; kwargs...) -&gt; Tuple{Any, Any}
</code></pre><p>A variant of <a href="#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis</code></a> that returns the individual maximized and minimized fluxes as two dictionaries (of dictionaries). All keyword arguments except <code>ret</code> are passed through.</p><p><strong>Example</strong></p><pre><code class="language-none">mins, maxs = flux_variability_analysis_dict(
    model,
    Tulip.Optimizer;
    bounds = objective_bounds(0.99),
    modifications = [
        change_optimizer_attribute(&quot;IPM_IterationsLimit&quot;, 500),
        change_constraint(&quot;EX_glc__D_e&quot;; lb = -10, ub = -10),
        change_constraint(&quot;EX_o2_e&quot;; lb = 0, ub = 0),
    ],
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_variability_analysis.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Any}" href="#COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Any}"><code>COBREXA.reaction_variability_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reaction_variability_analysis(model::MetabolicModel, optimizer; kwargs...) -&gt; Array
</code></pre><p>Shortcut for <a href="#COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Any}"><code>reaction_variability_analysis</code></a> that examines all reactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_variability_analysis.jl#L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}" href="#COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}"><code>COBREXA.reaction_variability_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reaction_variability_analysis(model::MetabolicModel, reaction_indexes::Vector{Int64}, optimizer; kwargs...) -&gt; Array
</code></pre><p>A variant for <a href="#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis</code></a> that examines actual reactions (selected by their indexes in <code>reactions</code> argument) instead of whole fluxes. This may be useful for models where the sets of reactions and fluxes differ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/flux_variability_analysis.jl#L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.make_gecko_model-Tuple{MetabolicModel}" href="#COBREXA.make_gecko_model-Tuple{MetabolicModel}"><code>COBREXA.make_gecko_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_gecko_model(model::MetabolicModel; reaction_isozymes, gene_product_bounds, gene_product_molar_mass, gene_product_mass_group, gene_product_mass_group_bound)
</code></pre><p>Wrap a model into a <a href="../types/#COBREXA.GeckoModel"><code>GeckoModel</code></a>, following the structure given by GECKO algorithm (see <a href="../types/#COBREXA.GeckoModel"><code>GeckoModel</code></a> documentation for details).</p><p><strong>Arguments</strong></p><ul><li><code>reaction_isozymes</code> is a function that returns a vector of <a href="../types/#COBREXA.Isozyme"><code>Isozyme</code></a>s for each reaction, or empty vector if the reaction is not enzymatic.</li><li><code>gene_product_bounds</code> is a function that returns lower and upper bound for concentration for a given gene product (specified by the same string gene ID as in <code>reaction_isozymes</code>), as <code>Tuple{Float64,Float64}</code>.</li><li><code>gene_product_molar_mass</code> is a function that returns a numeric molar mass of a given gene product specified by string gene ID.</li><li><code>gene_product_mass_group</code> is a function that returns a string group identifier for a given gene product, again specified by string gene ID. By default, all gene products belong to group <code>&quot;uncategorized&quot;</code> which is the behavior of original GECKO.</li><li><code>gene_product_mass_group_bound</code> is a function that returns the maximum mass for a given mass group.</li></ul><p>Alternatively, all function arguments may be also supplied as dictionaries that provide the same data lookup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/gecko.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._mmdf_add_df_bound-Tuple{Any, Any}" href="#COBREXA._mmdf_add_df_bound-Tuple{Any, Any}"><code>COBREXA._mmdf_add_df_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_mmdf_add_df_bound(lb, ub) -&gt; COBREXA.var&quot;#534#535&quot;
</code></pre><p>Helper function to add a new constraint on the driving force.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/max_min_driving_force.jl#L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._mmdf_concen_objective-Tuple{Any, Any}" href="#COBREXA._mmdf_concen_objective-Tuple{Any, Any}"><code>COBREXA._mmdf_concen_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_mmdf_concen_objective(midx, sense) -&gt; COBREXA.var&quot;#532#533&quot;
</code></pre><p>Helper function to change the objective to optimizing some concentration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/max_min_driving_force.jl#L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._mmdf_dgr_objective-Tuple{Any, Any}" href="#COBREXA._mmdf_dgr_objective-Tuple{Any, Any}"><code>COBREXA._mmdf_dgr_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_mmdf_dgr_objective(ridx, sense) -&gt; COBREXA.var&quot;#530#531&quot;
</code></pre><p>Helper function to change the objective to optimizing some dG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/max_min_driving_force.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.max_min_driving_force-Tuple{MetabolicModel, Dict{String, Float64}, Any}" href="#COBREXA.max_min_driving_force-Tuple{MetabolicModel, Dict{String, Float64}, Any}"><code>COBREXA.max_min_driving_force</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_min_driving_force(model::MetabolicModel, reaction_standard_gibbs_free_energies::Dict{String, Float64}, optimizer; flux_solution, proton_ids, water_ids, constant_concentrations, concentration_ratios, concentration_lb, concentration_ub, T, R, small_flux_tol, modifications, ignore_reaction_ids) -&gt; Union{Nothing, NamedTuple{(:mmdf, :dg_reactions, :concentrations), _A} where _A&lt;:Tuple{Any, Dict, Dict}}
</code></pre><p>Perform a max-min driving force analysis on the <code>model</code>, as defined by Noor, et al., &quot;Pathway thermodynamics highlights kinetic obstacles in central metabolism.&quot;, PLoS computational biology, 2014.</p><p>The function uses the supplied <code>optimizer</code> and <code>reaction_standard_gibbs_free_energies</code>. Optionally, <code>flux_solution</code> can be used to set the directions of each reaction in <code>model</code> (all reactions are assumed to proceed forward and are active by default). The supplied <code>flux_solution</code> should be free of internal cycles i.e. thermodynamically consistent. This optional input is important if a reaction in <code>model</code> normally runs in reverse (negative flux). Note, reactions in <code>flux_solution</code> that are smaller than <code>small_flux_tol</code> are also ignored in the analysis function (for numerical stability).</p><p>The max-min driving force algorithm returns the Gibbs free energy of the reactions, the concentrations of metabolites and the actual maximum minimum driving force. The optimization problem solved is:</p><pre><code class="language-none">max min -ΔᵣG
s.t. ΔᵣG = ΔrG⁰ + R T S&#39; ln(C)
     ΔᵣG ≤ 0
     ln(Cₗ) ≤ ln(C) ≤ ln(Cᵤ)</code></pre><p>where <code>ΔrG</code> are the Gibbs energies dissipated by the reactions, R is the gas constant, T is the temperature, S is the stoichiometry of the model, and C is the vector of metabolite concentrations (and their respective lower and upper bounds).</p><p>In case no feasible solution exists, <code>nothing</code> is returned.</p><p>Reactions specified in <code>ignore_reaction_ids</code> are internally ignored when calculating the max-min driving force. This should include water and proton importers.</p><p>Since biochemical thermodynamics are assumed, the <code>proton_ids</code> and <code>water_ids</code> need to be specified so that they can be ignored in the calculations. Effectively this assumes an aqueous environment at constant pH is used.</p><p><code>constant_concentrations</code> is used to fix the concentrations of certain metabolites (such as CO₂). <code>concentration_ratios</code> is used to specify additional constraints on metabolite pair concentrations (typically, this is done with various cofactors such as the ATP/ADP ratio. For example, you can fix the concentration of ATP to be always 5× higher than of ADP by specifying <code>Dict((&quot;ATP&quot;,&quot;ADP&quot;) =&gt; 5.0)</code></p><p><code>concentration_lb</code> and <code>concentration_ub</code> set the <code>Cₗ</code> and <code>Cᵤ</code> in the optimization problems.</p><p><code>T</code> and <code>R</code> can be specified in the corresponding units; defaults are K and kJ/K/mol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/max_min_driving_force.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.max_min_driving_force_variability-Tuple{MetabolicModel, Dict{String, Float64}, Any}" href="#COBREXA.max_min_driving_force_variability-Tuple{MetabolicModel, Dict{String, Float64}, Any}"><code>COBREXA.max_min_driving_force_variability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_min_driving_force_variability(model::MetabolicModel, reaction_standard_gibbs_free_energies::Dict{String, Float64}, optimizer; workers, optimal_objective_value, bounds, modifications, kwargs...) -&gt; Array
</code></pre><p>Perform a variant of flux variability analysis on a max min driving force type problem. Arguments are forwarded to <a href="#COBREXA.max_min_driving_force-Tuple{MetabolicModel, Dict{String, Float64}, Any}"><code>max_min_driving_force</code></a>. Calls <a href="#COBREXA.screen-Tuple"><code>screen</code></a> internally and possibly distributes computation across <code>workers</code>. If <code>optimal_objective_value = nothing</code>, the function first performs regular max min driving force analysis to find the max min driving force of the model and sets this to <code>optimal_objective_value</code>. Then iteratively maximizes and minimizes the driving force across each reaction, and then the concentrations while staying close to the original max min driving force as specified in <code>bounds</code>.</p><p>The <code>bounds</code> is a user-supplied function that specifies the max min driving force bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in the normal max min driving force analysis. It can return <code>-Inf</code> and <code>Inf</code> in first and second pair to remove the limit. Use <a href="../utils/#COBREXA.gamma_bounds-Tuple{Any}"><code>gamma_bounds</code></a> and <a href="../utils/#COBREXA.objective_bounds-Tuple{Any}"><code>objective_bounds</code></a> for simple bounds.</p><p>Returns a matrix of solutions to <a href="#COBREXA.max_min_driving_force-Tuple{MetabolicModel, Dict{String, Float64}, Any}"><code>max_min_driving_force</code></a> additionally constrained as described above, where the rows are in the order of the reactions and then the metabolites of the <code>model</code>. For the reaction rows the first column is the maximum dG of that reaction, and the second column is the minimum dG of that reaction subject to the above constraints. For the metabolite rows, the first column is the maximum concentration, and the second column is the minimum concentration subject to the constraints above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/max_min_driving_force.jl#L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.minimize_metabolic_adjustment-Tuple{Dict{String, Float64}}" href="#COBREXA.minimize_metabolic_adjustment-Tuple{Dict{String, Float64}}"><code>COBREXA.minimize_metabolic_adjustment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimize_metabolic_adjustment(flux_ref_dict::Dict{String, Float64}) -&gt; COBREXA.var&quot;#539#541&quot;{Dict{String, Float64}}
</code></pre><p>Overload of <a href="#COBREXA.minimize_metabolic_adjustment-Tuple{Dict{String, Float64}}"><code>minimize_metabolic_adjustment</code></a> that works with a dictionary of fluxes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/minimize_metabolic_adjustment.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.minimize_metabolic_adjustment-Tuple{Vector{Float64}}" href="#COBREXA.minimize_metabolic_adjustment-Tuple{Vector{Float64}}"><code>COBREXA.minimize_metabolic_adjustment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimize_metabolic_adjustment(flux_ref::Vector{Float64}) -&gt; COBREXA.var&quot;#537#538&quot;{Vector{Float64}}
</code></pre><p>An optimization model modification that implements the MOMA in <a href="#COBREXA.minimize_metabolic_adjustment_analysis-Tuple{MetabolicModel, Union{Dict{String, Float64}, Vector{Float64}}, Any}"><code>minimize_metabolic_adjustment_analysis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/minimize_metabolic_adjustment.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.minimize_metabolic_adjustment_analysis-Tuple{MetabolicModel, Union{Dict{String, Float64}, Vector{Float64}}, Any}" href="#COBREXA.minimize_metabolic_adjustment_analysis-Tuple{MetabolicModel, Union{Dict{String, Float64}, Vector{Float64}}, Any}"><code>COBREXA.minimize_metabolic_adjustment_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimize_metabolic_adjustment_analysis(model::MetabolicModel, flux_ref::Union{Dict{String, Float64}, Vector{Float64}}, optimizer; modifications, kwargs...) -&gt; JuMP.Model
</code></pre><p>Run minimization of metabolic adjustment (MOMA) on <code>model</code> with respect to <code>flux_ref</code>, which is a vector of fluxes in the order of <code>reactions(model)</code>. MOMA finds the shortest Euclidian distance between <code>flux_ref</code> and <code>model</code> with <code>modifications</code>:</p><pre><code class="language-none">min Σᵢ (xᵢ - flux_refᵢ)²
s.t. S x = b
     xₗ ≤ x ≤ xᵤ</code></pre><p>Because the problem has a quadratic objective, a QP solver is required. See &quot;Daniel, Vitkup &amp; Church, Analysis of Optimality in Natural and Perturbed Metabolic Networks, Proceedings of the National Academy of Sciences, 2002&quot; for more details.</p><p>Additional arguments are passed to <a href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a>.</p><p>Returns an optimized model that contains the resultant nearest flux.</p><p><strong>Example</strong></p><pre><code class="language-none">model = load_model(&quot;e_coli_core.json&quot;)
flux_ref = flux_balance_analysis_vec(model, Gurobi.Optimizer)
optmodel = minimize_metabolic_adjustment(
    model,
    flux_ref,
    Gurobi.Optimizer;
    modifications = [change_constraint(&quot;PFL&quot;; lb=0, ub=0)], # find flux of mutant that is closest to the wild type (reference) model
    )
value.(solution[:x])  # extract the flux from the optimizer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/minimize_metabolic_adjustment.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.minimize_metabolic_adjustment_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}" href="#COBREXA.minimize_metabolic_adjustment_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}"><code>COBREXA.minimize_metabolic_adjustment_analysis_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimize_metabolic_adjustment_analysis_dict(model::MetabolicModel, args...; kwargs...) -&gt; Union{Nothing, Dict{String, Float64}}
</code></pre><p>Perform minimization of metabolic adjustment (MOMA) and return a dictionary mapping the reaction IDs to fluxes. Arguments are forwarded to <a href="#COBREXA.minimize_metabolic_adjustment-Tuple{Dict{String, Float64}}"><code>minimize_metabolic_adjustment</code></a> internally.</p><p>This function is kept for backwards compatibility, use <a href="../base/#COBREXA.flux_vector-Tuple{MetabolicModel, Any}"><code>flux_vector</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/minimize_metabolic_adjustment.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.minimize_metabolic_adjustment_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}" href="#COBREXA.minimize_metabolic_adjustment_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}"><code>COBREXA.minimize_metabolic_adjustment_analysis_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimize_metabolic_adjustment_analysis_vec(model::MetabolicModel, args...; kwargs...) -&gt; Union{Nothing, Vector{Float64}}
</code></pre><p>Perform minimization of metabolic adjustment (MOMA) and return a vector of fluxes in the same order as the reactions in <code>model</code>. Arguments are forwarded to <a href="#COBREXA.minimize_metabolic_adjustment-Tuple{Dict{String, Float64}}"><code>minimize_metabolic_adjustment</code></a> internally.</p><p>This function is kept for backwards compatibility, use <a href="../base/#COBREXA.flux_vector-Tuple{MetabolicModel, Any}"><code>flux_vector</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/minimize_metabolic_adjustment.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}" href="#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}"><code>COBREXA.parsimonious_flux_balance_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonious_flux_balance_analysis(model::MetabolicModel, optimizer; modifications, qp_modifications, relax_bounds) -&gt; JuMP.Model
</code></pre><p>Run parsimonious flux balance analysis (pFBA) on the <code>model</code>. In short, pFBA runs two consecutive optimization problems. The first is traditional FBA:</p><pre><code class="language-none">max cᵀx = μ
s.t. S x = b
     xₗ ≤ x ≤ xᵤ</code></pre><p>And the second is a quadratic optimization problem:</p><pre><code class="language-none">min Σᵢ xᵢ²
s.t. S x = b
     xₗ ≤ x ≤ xᵤ
     μ = μ⁰</code></pre><p>Where the optimal solution of the FBA problem, μ⁰, has been added as an additional constraint. See &quot;Lewis, Nathan E, Hixson, Kim K, Conrad, Tom M, Lerman, Joshua A, Charusanti, Pep, Polpitiya, Ashoka D, Adkins, Joshua N, Schramm, Gunnar, Purvine, Samuel O, Lopez-Ferrer, Daniel, Weitz, Karl K, Eils, Roland, König, Rainer, Smith, Richard D, Palsson, Bernhard Ø, (2010) Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6. 390. doi: accession:10.1038/msb.2010.47&quot; for more details.</p><p>pFBA gets the model optimum by standard FBA (using <a href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a> with <code>optimizer</code> and <code>modifications</code>), then finds a minimal total flux through the model that still satisfies the (slightly relaxed) optimum. This is done using a quadratic problem optimizer. If the original optimizer does not support quadratic optimization, it can be changed using the callback in <code>qp_modifications</code>, which are applied after the FBA. See the documentation of <a href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a> for usage examples of modifications.</p><p>Thhe optimum relaxation sequence can be specified in <code>relax</code> parameter, it defaults to multiplicative range of <code>[1.0, 0.999999, ..., 0.99]</code> of the original bound.</p><p>Returns an optimized model that contains the pFBA solution (or an unsolved model if something went wrong).</p><p><strong>Example</strong></p><pre><code class="language-none">model = load_model(&quot;e_coli_core.json&quot;)
optmodel = parsimonious_flux_balance_analysis(model, biomass, Gurobi.Optimizer)
value.(solution[:x])  # extract the flux from the optimizer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/parsimonious_flux_balance_analysis.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.parsimonious_flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}" href="#COBREXA.parsimonious_flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}"><code>COBREXA.parsimonious_flux_balance_analysis_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonious_flux_balance_analysis_dict(model::MetabolicModel, args...; kwargs...) -&gt; Union{Nothing, Dict{String, Float64}}
</code></pre><p>Perform parsimonious flux balance analysis on <code>model</code> using <code>optimizer</code>. Returns a dictionary mapping the reaction IDs to fluxes. Arguments are forwarded to <a href="#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}"><code>parsimonious_flux_balance_analysis</code></a> internally.</p><p>This function is kept for backwards compatibility, use <a href="../base/#COBREXA.flux_dict-Tuple{MetabolicModel, Any}"><code>flux_dict</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/parsimonious_flux_balance_analysis.jl#L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.parsimonious_flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}" href="#COBREXA.parsimonious_flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}"><code>COBREXA.parsimonious_flux_balance_analysis_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsimonious_flux_balance_analysis_vec(model::MetabolicModel, args...; kwargs...) -&gt; Union{Nothing, Vector{Float64}}
</code></pre><p>Perform parsimonious flux balance analysis on <code>model</code> using <code>optimizer</code>. Returns a vector of fluxes in the same order as the reactions in <code>model</code>. Arguments are forwarded to <a href="#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}"><code>parsimonious_flux_balance_analysis</code></a> internally.</p><p>This function is kept for backwards compatibility, use <a href="../base/#COBREXA.flux_vector-Tuple{MetabolicModel, Any}"><code>flux_vector</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/parsimonious_flux_balance_analysis.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._screen_args-Tuple{Any, Any, Any}" href="#COBREXA._screen_args-Tuple{Any, Any, Any}"><code>COBREXA._screen_args</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_screen_args(argtuple, kwargtuple, modsname) -&gt; Union{Tuple{}, NamedTuple}
</code></pre><p>Internal helper to check the presence and shape of modification and argument arrays in <a href="#COBREXA.screen-Tuple"><code>screen</code></a> and pals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._screen_impl-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{A}, Tuple{V}} where {V&lt;:(AbstractVector), A, N}" href="#COBREXA._screen_impl-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{A}, Tuple{V}} where {V&lt;:(AbstractVector), A, N}"><code>COBREXA._screen_impl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_screen_impl(model::MetabolicModel; variants, analysis, args, workers)
</code></pre><p>The actual implementation of <a href="#COBREXA.screen-Tuple"><code>screen</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._screen_optmodel_item-Tuple{Any}" href="#COBREXA._screen_optmodel_item-Tuple{Any}"><code>COBREXA._screen_optmodel_item</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_screen_optmodel_item() -&gt; Any
</code></pre><p>Internal helper for <a href="#COBREXA.screen_optmodel_modifications-Tuple"><code>screen_optmodel_modifications</code></a> that computes one item of the screening task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._screen_optmodel_modifications_impl-Union{Tuple{N}, Tuple{A}, Tuple{VF}, Tuple{V}, Tuple{MetabolicModel, Any}} where {V&lt;:(AbstractVector), VF&lt;:(AbstractVector), A, N}" href="#COBREXA._screen_optmodel_modifications_impl-Union{Tuple{N}, Tuple{A}, Tuple{VF}, Tuple{V}, Tuple{MetabolicModel, Any}} where {V&lt;:(AbstractVector), VF&lt;:(AbstractVector), A, N}"><code>COBREXA._screen_optmodel_modifications_impl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_screen_optmodel_modifications_impl(model::MetabolicModel, optimizer; common_modifications, modifications, args, analysis, workers)
</code></pre><p>The actual implementation of <a href="#COBREXA.screen_optmodel_modifications-Tuple"><code>screen_optmodel_modifications</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._screen_optmodel_prepare-Tuple{Any, Any, Any}" href="#COBREXA._screen_optmodel_prepare-Tuple{Any, Any, Any}"><code>COBREXA._screen_optmodel_prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_screen_optmodel_prepare(model, optimizer, common_modifications) -&gt; Tuple{Any, JuMP.Model}
</code></pre><p>Internal helper for <a href="#COBREXA.screen_optmodel_modifications-Tuple"><code>screen_optmodel_modifications</code></a> that creates the model and applies the modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.screen-Tuple" href="#COBREXA.screen-Tuple"><code>COBREXA.screen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">screen(args...; kwargs...)
</code></pre><p>Take an array of model-modifying function vectors in <code>variants</code>, and execute the function <code>analysis</code> on all variants of the <code>model</code> specified by <code>variants</code>. The computation is distributed over worker IDs in <code>workers</code>. If <code>args</code> are supplied (as an array of the same size as the <code>variants</code>), they are forwarded as arguments to the corresponding analysis function calls.</p><p>The array of variants must contain vectors of single-parameter functions, these are applied to model in order. The functions must <em>not</em> modify the model, but rather return a modified copy. The copy should be made as shallow as possible, to increase memory efficiency of the process. Variant generators that modify the argument model in-place will cause unpredictable results. Refer to the definition of <a href="#COBREXA.screen_variant"><code>screen_variant</code></a> for details.</p><p>The function <code>analysis</code> will receive a single argument (the modified model), together with arguments from <code>args</code> expanded by <code>...</code>. Supply an array of tuples or vectors to pass in multiple arguments to each function. If the argument values should be left intact (not expanded to multiple arguments), they must be wrapped in single-item tuple or vector.</p><p>The modification and analysis functions are transferred to <code>workers</code> as-is; all packages required to run them (e.g. the optimization solvers) must be loaded there. Typically, you want to use the macro <code>@everywhere using MyFavoriteSolver</code> from <code>Distributed</code> package for loading the solvers.</p><p><strong>Return value</strong></p><p>The results of running <code>analysis</code> are collected in to the resulting array, in a way that preserves the shape of the <code>variants</code>, similarly as with <code>pmap</code>.</p><p>The results of <code>analysis</code> function must be serializable, preferably made only from pure Julia structures, because they may be transferred over the network between the computation nodes. For that reason, functions that return whole JuMP models that contain pointers to allocated C structures (such as <a href="#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a> used with <code>GLPK</code> or <code>Gurobi</code> otimizers) will generally not work in this context.</p><p>Note: this function is a thin argument-handling wrapper around <a href="#COBREXA._screen_impl-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{A}, Tuple{V}} where {V&lt;:(AbstractVector), A, N}"><code>_screen_impl</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-none">function reverse_reaction(i::Int)
    (model::CoreModel) -&gt; begin
        mod = copy(model)
        mod.S[:,i] .*= -1   # this is unrealistic but sufficient for demonstration
        mod
    end
end

m = load_model(CoreModel, &quot;e_coli_core.xml&quot;)

screen(m,
    variants = [
        [reverse_reaction(5)],
        [reverse_reaction(3), reverse_reaction(6)]
    ],
    analysis = mod -&gt; mod.S[:,3])  # observe the changes in S

screen(m,
    variants = [
        [reverse_reaction(5)],
        [reverse_reaction(3), reverse_reaction(6)]
    ],
    analysis = mod -&gt; flux_balance_analysis_vec(mod, GLPK.Optimizer))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.screen_optimize_objective-Tuple{Any, Any}" href="#COBREXA.screen_optimize_objective-Tuple{Any, Any}"><code>COBREXA.screen_optimize_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">screen_optimize_objective(_, optmodel) -&gt; Union{Nothing, Float64}
</code></pre><p>A variant of <a href="../base/#COBREXA.optimize_objective-Tuple{Any}"><code>optimize_objective</code></a> directly usable in <a href="#COBREXA.screen_optmodel_modifications-Tuple"><code>screen_optmodel_modifications</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.screen_optmodel_modifications-Tuple" href="#COBREXA.screen_optmodel_modifications-Tuple"><code>COBREXA.screen_optmodel_modifications</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">screen_optmodel_modifications(args...; kwargs...)
</code></pre><p>Screen multiple modifications of the same optimization model.</p><p>This function is potentially more efficient than <a href="#COBREXA.screen-Tuple"><code>screen</code></a> because it avoids making variants of the model structure and remaking of the optimization model. On the other hand, modification functions need to keep the optimization model in a recoverable state (one that leaves the model usable for the next modification), which limits the possible spectrum of modifications applied.</p><p>Internally, <code>model</code> is distributed to <code>workers</code> and transformed into the optimization model using <a href="../base/#COBREXA.make_optimization_model-Tuple{MetabolicModel, Any}"><code>make_optimization_model</code></a>. <code>common_modifications</code> are applied to the models at that point. Next, vectors of functions in <code>modifications</code> are consecutively applied, and the result of <code>analysis</code> function called on model are collected to an array of the same extent as <code>modifications</code>. Calls of <code>analysis</code> are optionally supplied with extra arguments from <code>args</code> expanded with <code>...</code>, just like in <a href="#COBREXA.screen-Tuple"><code>screen</code></a>.</p><p>Both the modification functions (in vectors) and the analysis function here have 2 base parameters (as opposed to 1 with <a href="#COBREXA.screen-Tuple"><code>screen</code></a>): first is the <code>model</code> (carried through as-is), second is the prepared JuMP optimization model that may be modified and acted upon. As an example, you can use modification <a href="#COBREXA.change_constraint-Tuple{String}"><code>change_constraint</code></a> and analysis <a href="#COBREXA.screen_optimize_objective-Tuple{Any, Any}"><code>screen_optimize_objective</code></a>.</p><p>Note: This function is a thin argument-handling wrapper around <a href="#COBREXA._screen_optmodel_modifications_impl-Union{Tuple{N}, Tuple{A}, Tuple{VF}, Tuple{V}, Tuple{MetabolicModel, Any}} where {V&lt;:(AbstractVector), VF&lt;:(AbstractVector), A, N}"><code>_screen_optmodel_modifications_impl</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.screen_variant" href="#COBREXA.screen_variant"><code>COBREXA.screen_variant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">screen_variant(model::MetabolicModel, variant::Vector, analysis) -&gt; Any
screen_variant(model::MetabolicModel, variant::Vector, analysis, args) -&gt; Any
</code></pre><p>Helper function for <a href="#COBREXA.screen-Tuple"><code>screen</code></a> that applies all single-argument functions in <code>variant</code> to the <code>model</code> (in order from &quot;first&quot; to &quot;last&quot;), and executes <code>analysis</code> on the result.</p><p>Can be used to test model variants locally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.screen_variants-Tuple{Any, Any, Any}" href="#COBREXA.screen_variants-Tuple{Any, Any, Any}"><code>COBREXA.screen_variants</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">screen_variants(model, variants, analysis; workers) -&gt; Array
</code></pre><p>A shortcut for <a href="#COBREXA.screen-Tuple"><code>screen</code></a> that only works with model variants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/screening.jl#L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.make_smoment_model-Tuple{MetabolicModel}" href="#COBREXA.make_smoment_model-Tuple{MetabolicModel}"><code>COBREXA.make_smoment_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_smoment_model(model::MetabolicModel; reaction_isozyme, gene_product_molar_mass, total_enzyme_capacity)
</code></pre><p>Construct a model with a structure given by sMOMENT algorithm; returns a <a href="../types/#COBREXA.SMomentModel"><code>SMomentModel</code></a> (see the documentation for details).</p><p><strong>Arguments</strong></p><ul><li><code>reaction_isozyme</code> parameter is a function that returns a single <a href="../types/#COBREXA.Isozyme"><code>Isozyme</code></a> for each reaction, or <code>nothing</code> if the reaction is not enzymatic. If the reaction has multiple isozymes, use <a href="../utils/#COBREXA.smoment_isozyme_speed-Tuple{Function}"><code>smoment_isozyme_speed</code></a> to select the fastest one, as recommended by the sMOMENT paper.</li><li><code>gene_product_molar_mass</code> parameter is a function that returns a molar mass of each gene product as specified by sMOMENT.</li><li><code>total_enzyme_capacity</code> is the maximum &quot;enzyme capacity&quot; in the model.</li></ul><p>Alternatively, all function arguments also accept dictionaries that are used to provide the same data lookup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/smoment.jl#L2">source</a></section></article><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="COBREXA._affine_hit_and_run_chain-NTuple{8, Any}" href="#COBREXA._affine_hit_and_run_chain-NTuple{8, Any}"><code>COBREXA._affine_hit_and_run_chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_affine_hit_and_run_chain(warmup, lbs, ubs, C, cl, cu, iters, seed) -&gt; Matrix{Float64}
</code></pre><p>Internal helper function for computing a single affine hit-and-run chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/sampling/affine_hit_and_run.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.affine_hit_and_run-Tuple{MetabolicModel, Matrix{Float64}}" href="#COBREXA.affine_hit_and_run-Tuple{MetabolicModel, Matrix{Float64}}"><code>COBREXA.affine_hit_and_run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">affine_hit_and_run(m::MetabolicModel, warmup_points::Matrix{Float64}; sample_iters, workers, chains, seed) -&gt; Any
</code></pre><p>Run a hit-and-run style sampling that starts from <code>warmup_points</code> and uses their affine combinations for generating the run directions to sample the space delimited by <code>lbs</code> and <code>ubs</code>.  The reaction rate vectors in <code>warmup_points</code> should be organized in columns, i.e. <code>warmup_points[:,1]</code> is the first set of reaction rates.</p><p>There are total <code>chains</code> of hit-and-run runs, each on a batch of <code>size(warmup_points, 2)</code> points. The runs are scheduled on <code>workers</code>, for good load balancing <code>chains</code> should be ideally much greater than <code>length(workers)</code>.</p><p>Each run continues for <code>maximum(sample_iters)</code> iterations; the numbers in <code>sample_iters</code> represent the iterations at which the whole &quot;current&quot; batch of points is collected for output. For example, <code>sample_iters=[1,4,5]</code> causes the process run for 5 iterations, returning the sample batch that was produced by 1st, 4th and last (5th) iteration.</p><p>Returns a matrix of sampled reaction rates (in columns), with all collected samples horizontally concatenated. The total number of samples (columns) will be <code>size(warmup_points,2) * chains * length(sample_iters)</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">warmup_points = warmup_from_variability(model, GLPK.Optimizer)
samples = affine_hit_and_run(model, warmup_points, sample_iters = 101:105)

# convert the result to flux (for models where the distinction matters):
fluxes = reaction_flux(model)&#39; * samples</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/sampling/affine_hit_and_run.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._maximize_warmup_reaction-Tuple{Any, Any, Any}" href="#COBREXA._maximize_warmup_reaction-Tuple{Any, Any, Any}"><code>COBREXA._maximize_warmup_reaction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_maximize_warmup_reaction(opt_model, rid, ret) -&gt; Any
</code></pre><p>A helper function for finding warmup points from reaction variability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/sampling/warmup_variability.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.warmup_from_variability" href="#COBREXA.warmup_from_variability"><code>COBREXA.warmup_from_variability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">warmup_from_variability(model::MetabolicModel, optimizer, n_points::Int64) -&gt; Matrix{Float64}
warmup_from_variability(model::MetabolicModel, optimizer, n_points::Int64, seed; kwargs...) -&gt; Matrix{Float64}
</code></pre><p>Generates FVA-like warmup points for samplers, by selecting random points by minimizing and maximizing reactions. Can not return more than 2 times the number of reactions in the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/sampling/warmup_variability.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.warmup_from_variability" href="#COBREXA.warmup_from_variability"><code>COBREXA.warmup_from_variability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">warmup_from_variability(model::MetabolicModel, optimizer) -&gt; Matrix{Float64}
warmup_from_variability(model::MetabolicModel, optimizer, min_reactions::AbstractVector{Int64}) -&gt; Matrix{Float64}
warmup_from_variability(model::MetabolicModel, optimizer, min_reactions::AbstractVector{Int64}, max_reactions::AbstractVector{Int64}; modifications, workers) -&gt; Matrix{Float64}
</code></pre><p>Generate FVA-like warmup points for samplers, by minimizing and maximizing the specified reactions. The result is returned as a matrix, each point occupies as single column in the result.</p><p>!!! warning Limited effect of modifications in <code>warmup_from_variability</code>     Modifications of the optimization model applied in <code>modifications</code>     parameter that change the semantics of the model have an effect on the     warmup points, but do not automatically carry to the subsequent sampling.     Users are expected to manually transplant any semantic changes to the     actual sampling functions, such as <a href="#COBREXA.affine_hit_and_run-Tuple{MetabolicModel, Matrix{Float64}}"><code>affine_hit_and_run</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/sampling/warmup_variability.jl#L34">source</a></section></article><h2 id="Analysis-modifiers"><a class="docs-heading-anchor" href="#Analysis-modifiers">Analysis modifiers</a><a id="Analysis-modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-modifiers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="COBREXA.add_crowding_constraints-Tuple{Dict{Int64, Float64}}" href="#COBREXA.add_crowding_constraints-Tuple{Dict{Int64, Float64}}"><code>COBREXA.add_crowding_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_crowding_constraints(weights::Dict{Int64, Float64}) -&gt; COBREXA.var&quot;#566#568&quot;{Dict{Int64, Float64}}
</code></pre><p>Adds a molecular crowding constraint to the optimization problem: <code>∑ wᵢ × vᵢ ≤ 1</code> where <code>wᵢ</code> is a weight and <code>vᵢ</code> is a flux index in the model&#39;s reactions specified in <code>weights</code> as <code>vᵢ =&gt; wᵢ</code> pairs.</p><p>See Beg, Qasim K., et al. &quot;Intracellular crowding defines the mode and sequence of substrate uptake by Escherichia coli and constrains its metabolic activity.&quot; Proceedings of the National Academy of Sciences 104.31 (2007) for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/crowding.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.add_crowding_constraints-Tuple{Dict{String, Float64}}" href="#COBREXA.add_crowding_constraints-Tuple{Dict{String, Float64}}"><code>COBREXA.add_crowding_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_crowding_constraints(weights::Dict{String, Float64}) -&gt; COBREXA.var&quot;#570#571&quot;{Dict{String, Float64}}
</code></pre><p>Variant of <a href="#COBREXA.add_crowding_constraints-Tuple{Dict{Int64, Float64}}"><code>add_crowding_constraints</code></a> that takes a dictinary of reactions <code>ids</code> instead of reaction indices mapped to weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/crowding.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.change_constraint-Tuple{String}" href="#COBREXA.change_constraint-Tuple{String}"><code>COBREXA.change_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_constraint(id::String; lb, ub) -&gt; COBREXA.var&quot;#575#576&quot;{Nothing, Nothing, String}
</code></pre><p>Change the lower and upper bounds (<code>lb</code> and <code>ub</code> respectively) of reaction <code>id</code> if supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/generic.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.change_objective-Tuple{Union{String, Vector{String}}}" href="#COBREXA.change_objective-Tuple{Union{String, Vector{String}}}"><code>COBREXA.change_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_objective(new_objective::Union{String, Vector{String}}; weights, sense) -&gt; Union{COBREXA.var&quot;#578#580&quot;{MathOptInterface.OptimizationSense, Vector{String}}, COBREXA.var&quot;#578#580&quot;{MathOptInterface.OptimizationSense, String}}
</code></pre><p>Modification that changes the objective function used in a constraint based analysis function.  <code>new_objective</code> can be a single reaction identifier, or an array of reactions identifiers.</p><p>Optionally, the objective can be weighted by a vector of <code>weights</code>, and a optimization <code>sense</code> can be set to either <code>MAX_SENSE</code> or <code>MIN_SENSE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/generic.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.constrain_objective_value-Tuple{Any}" href="#COBREXA.constrain_objective_value-Tuple{Any}"><code>COBREXA.constrain_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constrain_objective_value(tolerance) -&gt; COBREXA.var&quot;#572#573&quot;
</code></pre><p>Limit the objective value to <code>tolerance</code>-times the current objective value, as with <a href="../utils/#COBREXA.objective_bounds-Tuple{Any}"><code>objective_bounds</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/generic.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA._do_knockout-Tuple{MetabolicModel, Any, Vector{String}}" href="#COBREXA._do_knockout-Tuple{MetabolicModel, Any, Vector{String}}"><code>COBREXA._do_knockout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_do_knockout(model::MetabolicModel, opt_model, gene_ids::Vector{String})
</code></pre><p>Internal helper for knockouts on generic MetabolicModels. This can be overloaded so that the knockouts may work differently (more efficiently) with other models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/knockout.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.knockout-Tuple{String}" href="#COBREXA.knockout-Tuple{String}"><code>COBREXA.knockout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">knockout(gene_id::String) -&gt; COBREXA.var&quot;#582#583&quot;{Vector{String}}
</code></pre><p>A helper variant of <a href="#COBREXA.knockout-Tuple{String}"><code>knockout</code></a> for a single gene.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/knockout.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.knockout-Tuple{Vector{String}}" href="#COBREXA.knockout-Tuple{Vector{String}}"><code>COBREXA.knockout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">knockout(gene_ids::Vector{String}) -&gt; COBREXA.var&quot;#582#583&quot;{Vector{String}}
</code></pre><p>A modification that zeroes the bounds of all reactions that would be knocked out by the combination of specified genes (effectively disabling the reactions).</p><p>A slightly counter-intuitive behavior may occur if knocking out multiple genes: Because this only changes the reaction bounds, multiple gene knockouts <em>must</em> be specified in a single call to <a href="#COBREXA.knockout-Tuple{String}"><code>knockout</code></a>, because the modifications have no way to remember which genes are already knocked out and which not.</p><p>In turn, having a reaction that can be catalyzed either by Gene1 or by Gene2, specifying <code>modifications = [knockout([&quot;Gene1&quot;, &quot;Gene2&quot;])]</code> does indeed disable the reaction, but <code>modifications = [knockout(&quot;Gene1&quot;), knockout(&quot;Gene2&quot;)]</code> does <em>not</em> disable the reaction (although reactions that depend either only on Gene1 or only on Gene2 are disabled).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/knockout.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.add_loopless_constraints-Tuple{}" href="#COBREXA.add_loopless_constraints-Tuple{}"><code>COBREXA.add_loopless_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_loopless_constraints(; max_flux_bound, strict_inequality_tolerance) -&gt; COBREXA.var&quot;#587#592&quot;{Float64, Int64}
</code></pre><p>Add quasi-thermodynamic constraints to the model to ensure that no thermodynamically infeasible internal cycles can occur. Adds the following constraints to the problem:</p><pre><code class="language-none">-max_flux_bound × (1 - yᵢ) ≤ xᵢ ≤ max_flux_bound × yᵢ
-max_flux_bound × yᵢ + strict_inequality_tolerance × (1 - yᵢ) ≤ Gᵢ
Gᵢ ≤ -strict_inequality_tolerance × yᵢ + max_flux_bound × (1 - yᵢ)
Nᵢₙₜ&#39; × G = 0
yᵢ ∈ {0, 1}
Gᵢ ∈ ℝ
i ∈ internal reactions
Nᵢₙₜ is the nullspace of the internal stoichiometric matrix</code></pre><p>Note, this modification introduces binary variables, so an optimization solver capable of handing mixed integer problems needs to be used. The arguments <code>max_flux_bound</code> and <code>strict_inequality_tolerance</code> implement the &quot;big-M&quot; method of indicator constraints.</p><p>For more details about the algorithm, see <code>Schellenberger, Lewis, and, Palsson. &quot;Elimination of thermodynamically infeasible loops in steady-state metabolic models.&quot;, Biophysical journal, 2011</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/loopless.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.add_moment_constraints-Tuple{Dict{String, Float64}, Float64}" href="#COBREXA.add_moment_constraints-Tuple{Dict{String, Float64}, Float64}"><code>COBREXA.add_moment_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_moment_constraints(kcats::Dict{String, Float64}, protein_mass_fraction::Float64) -&gt; COBREXA.var&quot;#597#603&quot;{Dict{String, Float64}, Float64}
</code></pre><p>A modification that adds enzyme capacity constraints to the problem using a <em>modified</em> version of the MOMENT algorithm. Requires specific activities, <code>ksas</code> [mmol product/g enzyme/h], for each reaction. Proteins are identified by their associated gene IDs. Adds a variable vector <code>y</code> to the problem corresponding to the protein concentration [g enzyme/gDW cell] of each gene product in the order of <code>genes(model)</code>. The total protein concentration [g protein/gDW cell] is constrained to be less than or equal to the <code>protein_mass_fraction</code>. Reaction flux constraints are changed to the MOMENT constraints (see below) for all reactions that have a gene reaction rule, otherwise the flux bounds are left unaltered.</p><p>See Adadi, Roi, et al. &quot;Prediction of microbial growth rate versus biomass yield by a metabolic network with kinetic parameters.&quot; PLoS computational biology (2012) for more details of the original algorithm.</p><p>Here, a streamlined version of the algorithm is implemented to ensure that the correct units are used. Specifically, this implementation uses specific activities instead of <code>kcats</code>. Thus, for a reaction that can only proceed forward and is catalyzed by protein <code>a</code>, the flux <code>x[i]</code> is bounded by <code>x[i] &lt;= ksas[i] * y[a]</code>. If isozymes <code>a</code> or <code>b</code> catalyse the reaction, then <code>x[i] &lt;= ksas[i] * (y[a] + y[b])</code>. If a reaction is catalyzed by subunits <code>a</code> and <code>b</code> then <code>x[i] &lt;= ksas[i] * min(y[a], y[b])</code>. These rules are applied recursively in the model like in the original algorithm. The enzyme capacity constraint is then implemented by <code>sum(y) ≤ protein_mass_fraction</code>. The major benefit of using <code>ksas</code> instead of <code>kcats</code> is that active site number and unit issues are prevented.</p><p><strong>Example</strong></p><pre><code class="language-none">flux_balance_analysis(
    ...,
    modifications = [ add_moment_constraints(my_kcats, 0.6) ],
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/moment.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.change_optimizer-Tuple{Any}" href="#COBREXA.change_optimizer-Tuple{Any}"><code>COBREXA.change_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_optimizer(optimizer) -&gt; COBREXA.var&quot;#611#612&quot;
</code></pre><p>Change the JuMP optimizer used to run the optimization.</p><p>This may be used to try different approaches for reaching the optimum, and in problems that may require different optimizers for different parts, such as the <a href="#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}"><code>parsimonious_flux_balance_analysis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/optimizer.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.change_optimizer_attribute-Tuple{Any, Any}" href="#COBREXA.change_optimizer_attribute-Tuple{Any, Any}"><code>COBREXA.change_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_optimizer_attribute(attribute_key, value) -&gt; COBREXA.var&quot;#613#614&quot;
</code></pre><p>Change a JuMP optimizer attribute. The attributes are optimizer-specific, refer to the JuMP documentation and the documentation of the specific optimizer for usable keys and values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/optimizer.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.change_sense-Tuple{Any}" href="#COBREXA.change_sense-Tuple{Any}"><code>COBREXA.change_sense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_sense(objective_sense) -&gt; COBREXA.var&quot;#609#610&quot;
</code></pre><p>Change the objective sense of optimization. Possible arguments are <code>MAX_SENSE</code> and <code>MIN_SENSE</code>.</p><p>If you want to change the objective and sense at the same time, use <a href="#COBREXA.change_objective-Tuple{Union{String, Vector{String}}}"><code>change_objective</code></a> instead to do both at once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/optimizer.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="COBREXA.silence" href="#COBREXA.silence"><code>COBREXA.silence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">silence</code></pre><p>Modification that disable all output from the JuMP optimizer (shortcut for <code>set_silent</code> from JuMP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lcsb-biocore/COBREXA.jl/blob/677b0991423d361ce4045317957b5c6145464648/src/analysis/modifications/optimizer.jl#L35-L40">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Contents</a><a class="docs-footer-nextpage" href="../base/">Base functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 14 October 2022 11:12">Friday 14 October 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
