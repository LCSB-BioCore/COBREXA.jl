var documenterSearchIndex = {"docs":
[{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/14_smoment.jl\"","category":"page"},{"location":"examples/14_smoment/#sMOMENT","page":"sMOMENT","title":"sMOMENT","text":"","category":"section"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"sMOMENT algorithm can be used to easily adjust the metabolic activity within the cell to respect known enzymatic parameters and enzyme mass constraints measured by proteomics and other methods.","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"The original description from sMOMENT is by Bekiaris, and Klamt, \"Automatic construction of metabolic models with enzyme constraints.\", BMC bioinformatics, 2020","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"Let's load some packages:","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"We will necessarily need the enzyme turnover numbers (aka \"kcats\") and masses of the required gene products.  You do not necessarily need to know all data for the given model, but the more you have, the better the approximation will be.","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"For the demonstration purpose, we will generate the data randomly. In a realistic setting, you would input experimental or database-originating data here:","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"import Random\nRandom.seed!(1) # repeatability\n\ngene_product_masses = Dict(genes(model) .=> randn(n_genes(model)) .* 10 .+ 60)","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"We only take the reactions that have gene products (i.e., enzymes) associated with them):","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"rxns = filter(\n    x ->\n        !looks_like_biomass_reaction(x) &&\n            !looks_like_exchange_reaction(x) &&\n            !isnothing(reaction_gene_association(model, x)),\n    reactions(model),\n)","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"The information about each enzyme and its capabilities is stored in an Isozyme structure. For simplicity, sMOMENT ignores much of the information about the multiplicity of required gene products and other.","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"rxn_isozymes = Dict(\n    rxn => Isozyme(\n        Dict(vcat(reaction_gene_association(model, rxn)...) .=> 1),\n        randn() * 100 + 600, #forward kcat\n        randn() * 100 + 500, #reverse kcat\n    ) for rxn in rxns\n)","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"In case some of the reactions are missing in rxn_isozymes, sMOMENT simply ignores them.","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"Once the data is gathered, we create a model that wraps the original model with additional sMOMENT structure:","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"smoment_model =\n    model |> with_smoment(\n        reaction_isozyme = rxn_isozymes,\n        gene_product_molar_mass = gene_product_masses,\n        total_enzyme_capacity = 50.0,\n    )","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"(You could alternatively use the make_smoment_model to create the structure more manually; but with_smoment is easier to use e.g. with screen.)","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"In turn, you should have a complete model with unidirectional reactions and additional coupling, as specified by the sMOMENT method:","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"[stoichiometry(smoment_model); coupling(smoment_model)]","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"the type (SMomentModel) is a model wrapper â€“ it is a thin additional layer that just adds the necessary sMOMENT-relevant information atop the original model, which is unmodified. That makes the process very efficient and suitable for large-scale data processing. You can still access the original \"base\" model hidden in the SMomentModel using unwrap_model.","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"Other than that, the SMomentModel is a model type like any other, and you can run any analysis you want on it, such as FBA:","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"flux_balance_analysis_dict(smoment_model, GLPK.Optimizer)","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"(Notice that the total reaction fluxes are reported despite the fact that reactions are indeed split in the model! The underlying mechanism is provided by reaction_flux accessor.)","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"Variability of the sMOMENT model can be explored as such:","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"flux_variability_analysis(smoment_model, GLPK.Optimizer, bounds = gamma_bounds(0.95))","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"...and a sMOMENT model sample can be obtained as usual with sampling:","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"(\n    affine_hit_and_run(\n        smoment_model,\n        warmup_from_variability(smoment_model, GLPK.Optimizer),\n    )' * reaction_flux(smoment_model)\n)","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"","category":"page"},{"location":"examples/14_smoment/","page":"sMOMENT","title":"sMOMENT","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/17_envelopes.jl\"","category":"page"},{"location":"examples/17_envelopes/#Production-envelopes","page":"Production envelopes","title":"Production envelopes","text":"","category":"section"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"Production envelopes show what a model is capable of doing on a wide range of parameters. Usually, you choose a regular grid of a small dimension in the parameter space, and get an information about how well the model runs at each point.","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"As usual, we start by loading everything:","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"The envelope analysis \"structure\" is similar to what you can obtain using screen; but COBREXA provides a special functions that run the process in a very optimized manner. For envelopes, there is envelope_lattice that generates the rectangular lattice of points for a given model and reactions, and objective_envelope that computes the output (usually as the objective value) of the model at the lattice points. You do not need to call envelope_lattice directly because it is taken as a \"default\" way to create the lattice by objective_envelope.","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"In short, we can compute the envelope of a single reaction in the E. coli model as follows:","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"envelope = objective_envelope(\n    model,\n    [\"R_EX_o2_e\"],\n    GLPK.Optimizer,\n    lattice_args = (ranges = [(-50, 0)],),\n)","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"(The named tuple given in lattice_args argument is passed to the internal call of envelope_lattice, giving you an easy way to customize its behavior.)","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"The result has 2 fields which can be used to easily plot the envelope. We also need to \"fix\" the missing values (represented as nothing) where the model failed to solve â€“ we will simply omit them here).","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"using CairoMakie\n\nvalid = .!(isnothing.(envelope.values))\nlines(envelope.lattice[1][valid], float.(envelope.values[valid]))","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"Additional resolution can be obtained either by supplying your own larger lattice, or simply forwarding the samples argument to the internal call of envelope_lattice:","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"envelope = objective_envelope(\n    model,\n    [\"R_EX_co2_e\"],\n    GLPK.Optimizer,\n    lattice_args = (samples = 1000, ranges = [(-50, 100)]),\n)\n\nvalid = .!(isnothing.(envelope.values))\nlines(envelope.lattice[1][valid], float.(envelope.values[valid]))","category":"page"},{"location":"examples/17_envelopes/#Multi-dimensional-envelopes","page":"Production envelopes","title":"Multi-dimensional envelopes","text":"","category":"section"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"The lattice functions generalize well to more dimensions; you can easily explore the production of the model depending on the relative fluxes of 2 reactions:","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"envelope = objective_envelope(\n    model,\n    [\"R_EX_o2_e\", \"R_EX_co2_e\"],\n    GLPK.Optimizer,\n    lattice_args = (samples = 100, ranges = [(-60, 0), (-15, 60)]),\n)\n\nheatmap(\n    envelope.lattice[1],\n    envelope.lattice[2],\n    [isnothing(x) ? 0 : x for x in envelope.values],\n    axis = (; xlabel = \"Oxygen exchange\", ylabel = \"Carbon dioxide exchange\"),\n)","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"","category":"page"},{"location":"examples/17_envelopes/","page":"Production envelopes","title":"Production envelopes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"concepts/4_wrappers/#Extending-the-models","page":"Extending the models","title":"Extending the models","text":"","category":"section"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"To simplify doing (and undoing) simple modifications to the existing model structure, COBREXA.jl supports a class of model wrappers, which are basically small layers that add or change the functionality of a given base models.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"Types Serialized, CoreCoupling, SMomentModel, and GeckoModel all work in this manner â€“ add some extra functionality to the \"base\". Technically, they are all subtypes of the abstract type ModelWrapper, which itself is a subtype of MetabolicModel and can thus be used in all standard analysis functions.  Similarly, the model wraps can be stacked â€“ it is easy to e.g. serialize a GeckoModel, or to add coupling to an existing SMomentModel.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"As the main benefit of the approach, creating model variants using the wrapper approach is usually more efficient than recomputing the models in place. The wrappers are thin, and if all values can get computed and materialized only once the model data is actually needed, we may save a great amount of computing power.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"At the same time, since the original model stays unchanged (and may even be immutable), undoing the modifications caused by the wrapper is extremely easy and fast â€“ we just discard the wrapper.","category":"page"},{"location":"concepts/4_wrappers/#Writing-a-model-wrapper","page":"Extending the models","title":"Writing a model wrapper","text":"","category":"section"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"Creating a model wrapper structure is simple â€“ by declaring it a subtype of ModelWrapper and implementing a single function unwrap_model, we get default implementations of all accessors that should work for any MetabolicModel.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"As a technical example, we may make a minimal model wrapper that does not do anything:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"struct IdentityWrap <: ModelWrapper\n    mdl::MetabolicModel\nend\n\nCOBREXA.unwrap_model(x::IdentityWrap) = x.mdl","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"This is instantly usable in all analysis functions, although there is no actual \"new\" functionality:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"m = IdentityWrap(load_model(\"e_coli_core.xml\"))\nflux_balance_analysis_vec(m, GLPK.Optimizer)","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"To modify the functionality, we simply add specific methods for accessors that we want modified, such as bounds, stoichiometry and objective. We demonstrate that on several examples below.","category":"page"},{"location":"concepts/4_wrappers/#Example-1:-Slower-model","page":"Extending the models","title":"Example 1: Slower model","text":"","category":"section"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"Here, we construct a type RateChangedModel that has all bounds multiplied by a constant factor. This can be used to e.g. simulate higher or lower abundance of certain organism in a model.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"struct RateChangedModel <: ModelWrapper\n    factor::Float64\n    mdl::MetabolicModel\nend","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"The overloaded accessors typically reach for basic information into the \"inner\" wrapped model, and modify them in a certain way.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"COBREXA.unwrap_model(x::RateChangedModel) = x.mdl\nfunction COBREXA.bounds(x::RateChangedModel)\n    (l, u) = bounds(x.mdl) # extract the original bounds\n    return (l .* x.factor, u .* x.factor) # return customized bounds\nend","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"To make a 2 times faster or slower model from a base model, we can run:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"faster_e_coli = RateChangedModel(2.0, load_model(\"e_coli_core.xml\"))\nslower_e_coli = RateChangedModel(1/2, load_model(\"e_coli_core.xml\"))","category":"page"},{"location":"concepts/4_wrappers/#Example-2:-Leaky-model","page":"Extending the models","title":"Example 2: Leaky model","text":"","category":"section"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"As the second example, we construct a hypothetical model that is \"leaking\" all metabolites at once at a constant fixed small rate. Again, the modification is not quite realistic, but may be useful to validate the mathematical robustness of the models.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"struct LeakyModel <: ModelWrapper\n    leaking_metabolites::Vector{String}\n    leak_rate::Float64\n    mdl::MetabolicModel\nend","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"Technically, we implement the leaks by adding an extra reaction bounded to the precise leak_rate, which permanently removes all metabolites. That is done by modifying the reaction list, stoichiometry, and bounds:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"COBREXA.unwrap_model(x::LeakyModel) = x.mdl\nCOBREXA.n_reactions(x::LeakyModel) = n_reactions(x.mdl) + 1\nCOBREXA.reactions(x::LeakyModel) = [reactions(x.mdl); \"The Leak\"]\nCOBREXA.stoichiometry(x::LeakyModel) = [stoichiometry(x.mdl) [m in x.leaking_metabolites ? -1.0 : 0.0 for m = metabolites(x.mdl)]]\nfunction COBREXA.bounds(x::LeakyModel)\n    (l, u) = bounds(x.mdl)\n    return ([l; x.leak_rate], [u; x.leak_rate])\nend","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"To make the wrapper complete and consistent, we also have to modify the accessors that depend on correct sizes of the model items.","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"COBREXA.objective(x::LeakyModel) = [objective(x.mdl); 0]\nCOBREXA.reaction_flux(x::LeakyModel) = [reaction_flux(x.mdl); zeros(1, n_reactions(x.mdl))]\nCOBREXA.coupling(x::LeakyModel) = [coupling(x.mdl) zeros(n_coupling_constraints(x.mdl))]","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"(Among other, we modified the reaction_flux so that all analysis methods ignore the leak reaction.)","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"Now, any model can be made to lose some chosen metabolites as follows:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"leaks = [\"M_o2_c\", \"M_pi_c\", \"M_glx_c\"]\nleaky_e_coli = LeakyModel(leaks, 5, load_model(\"e_coli_core.xml\"))","category":"page"},{"location":"concepts/4_wrappers/#Example-3:-Combining-the-wrappers","page":"Extending the models","title":"Example 3: Combining the wrappers","text":"","category":"section"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"With both wrappers implemented individually, it is easy to combine them by re-wrapping. We can easily create a model that is slowed down and moreover leaks the metabolites as follows:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"leaky_slow_e_coli = LeakyModel(leaks, 5, RateChangedModel(1/2, load_model(\"e_coli_core.xml\")))","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"As with all wrapping operations, take care about the exact order of applying the wraps. The other combination of the model wraps differs by also changing the rate of the metabolite leaks, which did not happen with the leaky_slow_e_coli above:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"slowly_leaking_slow_e_coli = RateChangedModel(1/2, LeakyModel(leaks, 5, load_model(\"e_coli_core.xml\")))","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"Expectably, the model can be solved with standard functions:","category":"page"},{"location":"concepts/4_wrappers/","page":"Extending the models","title":"Extending the models","text":"v = flux_balance_analysis_dict(slowly_leaking_slow_e_coli, GLPK.Optimizer)\nv[\"R_BIOMASS_Ecoli_core_w_GAM\"]  # prints out ~0.38","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/02_convert_save.jl\"","category":"page"},{"location":"examples/02_convert_save/#Converting,-modifying-and-saving-models","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"","category":"section"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"COBREXA.jl can export JSON and MATLAB-style model formats, which can be useful when exchanging the model data with other software.","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"For a test, let's download and open a SBML model:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"using COBREXA\n\n!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\");\n\nsbml_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"You can save the model as .json or .mat file using the save_model function:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"save_model(sbml_model, \"converted_e_coli.json\")\nsave_model(sbml_model, \"converted_e_coli.mat\")","category":"page"},{"location":"examples/02_convert_save/#Using-serialization-for-quick-loading-and-saving","page":"Converting, modifying and saving models","title":"Using serialization for quick loading and saving","text":"","category":"section"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"If you are saving the models only for future processing in Julia environment, it is often wasteful to encode the models to external formats and decode them back. Instead, you can use the \"native\" Julia data format, accessible with package Serialization.","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"This way, you can use serialize to save any model format (even the complicated StandardModel, which does not have a \"native\" file format representation):","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"using Serialization\n\nsm = convert(StandardModel, sbml_model)\n\nopen(f -> serialize(f, sm), \"myModel.stdmodel\", \"w\")","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"The models can then be loaded back using deserialize:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"sm2 = deserialize(\"myModel.stdmodel\")\nissetequal(metabolites(sm), metabolites(sm2))","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"This form of loading operation is usually pretty quick:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"t = @elapsed deserialize(\"myModel.stdmodel\")\n@info \"Deserialization took $t seconds\"","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"Notably, large and complicated models with thousands of reactions and annotations can take tens of seconds to decode properly. Serialization allows you to minimize this overhead, and scales well to tens of millions of reactions.","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"warning: Compatibility\nThe format of serialized models may change between Julia versions. In particular, never use the the serialized format for publishing models â€“ others will have hard time finding the correct Julia version to open them. Similarly, never use serialized models for long-term storage â€“ your future self will have hard time finding the historic Julia version that was used to write the data.","category":"page"},{"location":"examples/02_convert_save/#Converting-and-saving-a-modified-model","page":"Converting, modifying and saving models","title":"Converting and saving a modified model","text":"","category":"section"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"To modify the models easily, it is useful to convert them to a format that simplifies this modification. You may use e.g. CoreModel that exposes the usual matrix-and-vectors structure of models as used in MATLAB COBRA implementations, and StandardModel that contains structures, lists and dictionaries of model contents, as typical in Python COBRA implementations. The object-oriented nature of StandardModel is better for making small modifications that utilize known identifiers of model contents.","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"Conversion of any model to StandardModel can be performed using the standard Julia convert:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"sm = convert(StandardModel, sbml_model)","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"The conversion can be also achieved right away when loading the model, using an extra parameter of load_model:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"sm = load_model(StandardModel, \"e_coli_core.json\")","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"As an example, we change an upper bound on one of the reactions:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"sm.reactions[\"PFK\"].ub = 10.0","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"After possibly applying more modifications, you can again save the modified model in a desirable exchange format:","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"save_model(sm, \"modified_e_coli.json\")\nsave_model(sm, \"modified_e_coli.mat\")","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"More information about StandardModel internals is available in a separate example.","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"","category":"page"},{"location":"examples/02_convert_save/","page":"Converting, modifying and saving models","title":"Converting, modifying and saving models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howToContribute/#Contributing-to-COBREXA.jl","page":"How to contribute","title":"Contributing to COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"ðŸ‘ðŸŽ‰ Thanks for taking the time to contribute to COBREXA.jl! ðŸŽ‰ðŸ‘","category":"page"},{"location":"howToContribute/#How-to-report-a-bug-or-suggest-an-enhancement","page":"How to contribute","title":"How to report a bug or suggest an enhancement","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Please use the GitHub issue tracker to report any problems with the software, and discuss any potential questions about COBREXA use.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Before creating bug reports, please check the open issues, you might find out that the issue is already reported and known.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"General guidelines for reporting issues:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If creating a bug report, include a complete description of how we can reproduce the bug, including e.g. links to datasets and any external scripts used. Ideally, try to create a code snippet that causes the problem on a fresh installation of COBREXA.jl (often called the \"minimal crashing example\")\nIf possible, use the supplied issue templates and fill in all fields.\nIf your issue is already described in an issue that is \"closed\", do not reopen it. Instead, open a new issue and include a link to the original issue. (The fact that the original issue might have been mistakenly closed may be an issue on its own.)\nEnhancement proposals should refer a viable way for implementing the enhancement. If there are multiple possibilities for implementation, we will welcome a discussion about which one is optimal for COBREXA.jl.","category":"page"},{"location":"howToContribute/#How-to-test-a-development-version-of-the-package?","page":"How to contribute","title":"How to test a development version of the package?","text":"","category":"section"},{"location":"howToContribute/#Step-1:-Load-COBREXA.jl-from-the-source-from-the-git-repository","page":"How to contribute","title":"Step 1: Load COBREXA.jl from the source from the git repository","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"There are two ways that you can retrieve a local copy of the development repo: you can either clone the repository manually, or use Julia package manager to get a development version for you.","category":"page"},{"location":"howToContribute/#Option-1:-Using-Julia-package-manager","page":"How to contribute","title":"Option 1: Using Julia package manager","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When you are used to using the Julia package manager for developing or contributing to packages, you can type:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This will install the COBREXA package locally and check it out for development. You can check the location of the package with:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status\n    Status `~/.julia/environments/v1.4/Project.toml`\n  [a03a9c34] COBREXA v0.0.5 [`~/.julia/dev/COBREXA`]","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The default location of the package is ~/.julia/dev/COBREXA.","category":"page"},{"location":"howToContribute/#Option-2:-Cloning-with-git-manually","page":"How to contribute","title":"Option 2: Cloning with git manually","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You can use git to get the sources as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git clone git@github.com:LCSB-BioCore/COBREXA.jl.git","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the cloning process finishes, you shold see the package cloned in a new directory COBREXA.jl. To install this version to your Julia, change to the directory first, and start Julia:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd COBREXA.jl\n$ julia","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With Julia, you can install the development version of the package from the directory as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> add .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(press ] to get into the packaging environment)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This adds the COBREXA.jl package and all its dependencies. You can verify that the installation worked by typing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If you are planning to develop the package, it is often easier to install the package in development mode, with dev command:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"That causes the package to always load with whatever code changes that you added to the source directory.","category":"page"},{"location":"howToContribute/#Finally:-load-COBREXA.jl","page":"How to contribute","title":"Finally: load COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With both of above options, you should get COBREXA.jl installed, which means that the following command should, without errors, load the package and make COBREXA.jl functions available for testing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"julia> using COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You may now freely modify the code and test the result.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Remember that if you want to work in the environment of the package, you need to activate it. That causes, among other, that the additional dependencies specified with packaging add command will be written automaticaly to Project.toml file of your local COBREXA.jl clone, not to your global environment. Activation is simple: when in the directory of the package, just type the command into the packaging shell:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> activate","category":"page"},{"location":"howToContribute/#Step-2:-Publish-your-changes","page":"How to contribute","title":"Step 2: Publish your changes","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You are expected to make a fork of the main COBREXA.jl repository, and open a pull request from that one to the develop branch of the main repository. For creating the fork, just hit the \"Fork\" button on GitHub.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After that, change the directory to your repository and adjust the remotes:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd ~/.julia/dev/COBREXA             # or any other directory, as needed\n$ git remote rename origin upstream   # renames the origin (the main COBREXA.jl repo) to upstream\n$ git remote add origin git@github.com:yourUsername/COBREXA.jl.git  # adds the link to your clone as new origin\n$ git fetch origin                    # fetches the refs from your repo","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"In the above code, change yourUsername is your GitHub username.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the renaming is done, start a new branch at upstream/master. In the code snippet, substitute yn for your initials (Your Name here) and give the new feature a better name than somefeature:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git checkout -b yn-somefeature origin/master","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Commit any changes and features that you like to the new branch. When the commits look complete to you, push the branch to your repository fork:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git push -u origin yn-somefeature","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This makes your changes visible in your repository. After that, you can navigate to GitHub's pull request page, where you should immediately see a big green button that helps you to create a pull request for this branch. Read the section below for precise details and guidelines on submitting the pull requests.","category":"page"},{"location":"howToContribute/#How-to-submit-a-pull-request-(PR)-with-your-modification/enhancement?","page":"How to contribute","title":"How to submit a pull request (PR) with your modification/enhancement?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Make a fork of the repository, commit the modifications in a separate branch and push the branch to your fork.\nMake a pull request where you describe the motivation and expected outcome for the users. Specifically, consider any possible incompatibilities, and the necessity to increment the version number after your changes are applied. Set the target branch to develop.\nAfter submitting the pull request, verify that all status checks (tests, documentation) are passing. Make sure any new contribution is properly documented and tested (you may want to check with coverage tools, using test --coverage from the Julia packaging shell)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After you submitted a pull request, a label might be assigned that allows us to track and manage issues and pull requests.","category":"page"},{"location":"howToContribute/#Code-culture-and-style-recommendations","page":"How to contribute","title":"Code culture and style recommendations","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Follow basic rules for software maintainability and extensibility:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Do not reimplement functionality that is available in other packages, unless the reimplementation is either trivial and short, or there is a grave need to do so because the other implementations are deficient in some manner.\nTry to keep the function names and interfaces consistent with ecosystem standards and the other functions in the package. Consistency reduces the amount of surprise on the user side, thus lowers the need to reach for documentation, and in turn makes the software much easier and faster to use.\nCode less. Shorter code is almost always better unless demonstrated otherwise, e.g. with a benchmark. Avoid repetitive boilerplate (there should be ways to generate it, if needed).\nKeep the functionality \"open\" and composable. In particular, avoid all unnecessarily opaque and leaky abstractions (common in object-oriented programming).\nAvoid producing lots of \"informative\" text side-output by default, unless that is what the user asked for.\nAdhere to the code formatting rules defined by JuliaFormatter. We usually have a bot running that checks all PRs and reports whether the code is properly formatted.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Follow the common rules for making easily mergable and reviewable PRs:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Create one PR for each logical \"feature\" you want to merge. If your change is more complex and contains multiple \"stages\", open multiple PRs.\nKeep the test coverage reasonably high.\nIf you commit many small, partial changes in a PR, you may help us save energy by prefixing your commit names with [skip ci], which deactivates the CI trigger on that commit. With each skipped CI, you save a few watt-hours of energy. Testing just the \"final\" commit of the pull-request branch is sufficient.","category":"page"},{"location":"howToContribute/#For-developers:-What-is-the-expected-branch-management/workflow?","page":"How to contribute","title":"For developers: What is the expected branch management/workflow?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The workflow is based on GitLab flow, i.e., a develop branch with feature branches being merged into the develop branch, all periodically merged to master branch. Depending on your access rights, you may open the feature branch in this repository, or in your fork.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The guidelines can be summarized as such:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"when making a contribution, create one new branch and open one new PR for each new independent feature or bugfix\ndo not push to another branch unless it is your own\ntry to get a review before merging unless the change is trivial and non-impacting\nconsider prefixing your branch names with your initials, so that one can easily see who owns which branch (e.g. ad-somefeature would be committed by Arthur Dent)","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/07_gene_deletion.jl\"","category":"page"},{"location":"examples/07_gene_deletion/#Gene-knockouts","page":"Gene knockouts","title":"Gene knockouts","text":"","category":"section"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"Here we will use the knockout function to modify the optimization model before solving, in order to simulate genes knocked out. We can pass knockout to many analysis functions that support parameter modifications, including flux_balance_analysis, flux_variability_analysis, and others.","category":"page"},{"location":"examples/07_gene_deletion/#Deleting-a-single-gene","page":"Gene knockouts","title":"Deleting a single gene","text":"","category":"section"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"First, let's compute the \"original\" flux, with no knockouts.","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"original_flux = flux_balance_analysis_dict(model, GLPK.Optimizer);\nnothing #hide","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"One can find gene IDs that we can knock out using genes and gene_name functions:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"genes(model)","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"It is possible to sort the genes by gene name to allow easier lookups:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"sort(gene_name.(Ref(model), genes(model)) .=> genes(model))","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"Compute the flux with a genes knocked out:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"flux_with_knockout =\n    flux_balance_analysis_dict(model, GLPK.Optimizer, modifications = [knockout(\"G_b3236\")])","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"We can see there is a small decrease in production upon knocking out the gene:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"biomass_id = \"R_BIOMASS_Ecoli_core_w_GAM\"\nflux_with_knockout[biomass_id] / original_flux[biomass_id]","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"Similarly, we can explore how the flux variability has changed once the gene is knocked out:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"variability_with_knockout =\n    flux_variability_analysis(model, GLPK.Optimizer, modifications = [knockout(\"G_b3236\")])","category":"page"},{"location":"examples/07_gene_deletion/#Knocking-out-multiple-genes","page":"Gene knockouts","title":"Knocking out multiple genes","text":"","category":"section"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"Multiple genes can be knocked out by simply passing a vector of genes to the knockout modification. This knocks out all genes that can run the FBA reaction:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"reaction_gene_association(model, \"R_FBA\")","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"flux_with_double_knockout = flux_balance_analysis_dict(\n    model,\n    GLPK.Optimizer,\n    modifications = [knockout([\"G_b2097\", \"G_b1773\", \"G_b2925\"])],\n)","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"flux_with_double_knockout[biomass_id] / original_flux[biomass_id]","category":"page"},{"location":"examples/07_gene_deletion/#Processing-all-single-gene-knockouts","page":"Gene knockouts","title":"Processing all single gene knockouts","text":"","category":"section"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"Function screen provides a parallelizable and extensible way to run the flux balance analysis with the knockout over all genes:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"knockout_fluxes = screen(\n    model,\n    args = tuple.(genes(model)),\n    analysis = (m, gene) -> begin\n        res = flux_balance_analysis_dict(m, GLPK.Optimizer, modifications = [knockout(gene)])\n        if !isnothing(res)\n            res[biomass_id]\n        end\n    end,\n)","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"It is useful to display the biomass growth rates of the knockout models together with the gene name:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"sort(gene_name.(Ref(model), genes(model)) .=> knockout_fluxes, by = first)","category":"page"},{"location":"examples/07_gene_deletion/#Processing-all-multiple-gene-deletions","page":"Gene knockouts","title":"Processing all multiple-gene deletions","text":"","category":"section"},{"location":"examples/07_gene_deletion/#Double-gene-knockouts","page":"Gene knockouts","title":"Double gene knockouts","text":"","category":"section"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"Since we can generate any kind of argument matrix for screen to process, it is straightforward to generate the matrix of all double gene knockouts and let the function process it. This computes the biomass production of all double-gene knockouts:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"gene_groups = [[g1, g2] for g1 in genes(model), g2 in genes(model)];\ndouble_knockout_fluxes = screen(\n    model,\n    args = tuple.(gene_groups),\n    analysis = (m, gene_groups) -> begin\n        res = flux_balance_analysis_dict(\n            m,\n            GLPK.Optimizer,\n            modifications = [knockout(gene_groups)],\n        )\n        if !isnothing(res)\n            res[biomass_id]\n        end\n    end,\n)","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"The results can be converted to an easily scrutinizable form as follows:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"reshape([gene_name.(Ref(model), p) for p in gene_groups] .=> double_knockout_fluxes, :)","category":"page"},{"location":"examples/07_gene_deletion/#Triple-gene-knockouts-(and-others)","page":"Gene knockouts","title":"Triple gene knockouts (and others)","text":"","category":"section"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"We can extend the same analysis to triple or other gene knockouts by generating a different array of gene pairs. For example, one can generate gene_groups for triple gene deletion screening:","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"gene_groups = [[g1, g2, g3] for g1 in genes(model), g2 in genes(model), g3 in genes(model)];\nnothing #hide","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"!!! warning Full triple gene deletion analysis may take a long time to compute.     We may use parallel processing with screen to speed up the     analysis. Alternatively, process only a subset of the genes triples.","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"","category":"page"},{"location":"examples/07_gene_deletion/","page":"Gene knockouts","title":"Gene knockouts","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/13_moma.jl\"","category":"page"},{"location":"examples/13_moma/#Minimization-of-metabolic-adjustment-(MOMA)","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"","category":"section"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"MOMA allows you to find a feasible solution of the model that is closest (in an Euclidean metric) to a reference solution. Often this gives a realistic estimate of the organism behavior that has undergone a radical change (such as a gene knockout) that prevents it from metabolizing optimally, but the rest of the metabolism has not yet adjusted to compensate for the change.","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"The original description of MOMA is by Segre, Vitkup, and Church, \"Analysis of optimality in natural and perturbed metabolic networks\", Proceedings of the National Academy of Sciences, 2002.","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"As always, let's start with downloading a model.","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA\n\nmodel = load_model(StandardModel, \"e_coli_core.xml\")","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"MOMA analysis requires solution of a quadratic model, we will thus use OSQP as the main optimizer.","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"using OSQP","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"We will need a reference solution, which represents the original state of the organism before the change.","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"reference_flux = flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [silence, change_optimizer_attribute(\"polish\", true)],\n)","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"As the change here, we manually knock out CYTBD reaction:","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"changed_model = change_bound(model, \"R_CYTBD\", lower = 0.0, upper = 0.0);\nnothing #hide","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"Now, let's find a flux that minimizes the organism's metabolic adjustment for this model:","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"flux_summary(\n    minimize_metabolic_adjustment_analysis_dict(\n        changed_model,\n        reference_flux,\n        OSQP.Optimizer;\n        modifications = [silence, change_optimizer_attribute(\"polish\", true)],\n    ),\n)","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"For illustration, you can compare the result to the flux that is found by simple optimization:","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"flux_summary(\n    flux_balance_analysis_dict(\n        changed_model,\n        OSQP.Optimizer;\n        modifications = [silence, change_optimizer_attribute(\"polish\", true)],\n    ),\n)","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"","category":"page"},{"location":"examples/13_moma/","page":"Minimization of metabolic adjustment (MOMA)","title":"Minimization of metabolic adjustment (MOMA)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/15_gecko.jl\"","category":"page"},{"location":"examples/15_gecko/#GECKO","page":"GECKO","title":"GECKO","text":"","category":"section"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"GECKO algorithm can be used to easily adjust the metabolic activity within the cell to respect many known parameters, measured by proteomics and other methods.","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"The original description from GECKO is by: SÃ¡nchez, et. al., \"Improving the phenotype predictions of a yeast genomeâ€scale metabolic model by incorporating enzymatic constraints.\", Molecular systems biology, 2017.","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"The analysis method and implementation in COBREXA is similar to sMOMENT, but GECKO is able to process and represent much larger scale of the constraints â€“ mainly, it supports multiple isozymes for each reaction, and the isozymes can be grouped into \"enzyme mass groups\" to simplify interpretation of data from proteomics.","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"For demonstration, we will generate artificial random data in a way similar to the sMOMENT example:","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(\"e_coli_core.json\")\n\nimport Random\nRandom.seed!(1) # repeatability\n\ngene_product_masses = Dict(genes(model) .=> randn(n_genes(model)) .* 10 .+ 60)\n\nrxns = filter(\n    x ->\n        !looks_like_biomass_reaction(x) &&\n            !looks_like_exchange_reaction(x) &&\n            !isnothing(reaction_gene_association(model, x)),\n    reactions(model),\n)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"The main difference from sMOMENT comes from allowing multiple isozymes per reaction (reactions with missing isozyme informations will be ignored, leaving them as-is):","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"rxn_isozymes = Dict(\n    rxn => [\n        Isozyme(\n            Dict(isozyme_genes .=> 1),\n            randn() * 100 + 600, #forward kcat\n            randn() * 100 + 500, #reverse kcat\n        ) for isozyme_genes in reaction_gene_association(model, rxn)\n    ] for rxn in rxns\n)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"We also construct similar bounds for total gene product amounts:","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"gene_product_bounds = Dict(genes(model) .=> Ref((0.0, 10.0)))","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"With this, the construction of the model constrained by all enzymatic information is straightforward:","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"gecko_model =\n    model |> with_gecko(;\n        reaction_isozymes = rxn_isozymes,\n        gene_product_bounds,\n        gene_product_molar_mass = gene_product_masses,\n        gene_product_mass_group = _ -> \"uncategorized\", # all products belong to the same \"uncategorized\" category\n        gene_product_mass_group_bound = _ -> 100.0, # the total limit of mass in the single category\n    )","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"(Alternatively, you may use make_gecko_model, which does the same without piping by |>.)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"The stoichiometry and coupling in the gecko model is noticeably more complex; you may notice new \"reactions\" added that simulate the gene product utilization:","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"[stoichiometry(gecko_model); coupling(gecko_model)]","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"Again, the resulting model can be used in any type of analysis. For example, flux balance analysis:","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"opt_model = flux_balance_analysis(gecko_model, GLPK.Optimizer)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"Get the fluxes","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"flux_sol = flux_dict(gecko_model, opt_model)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"Get the gene product concentrations","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"gp_concs = gene_product_dict(gecko_model, opt_model)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"Get the total masses assigned to each mass group","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"gene_product_mass_group_dict(gecko_model, opt_model)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"Variability:","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"flux_variability_analysis(gecko_model, GLPK.Optimizer, bounds = gamma_bounds(0.95))","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"...and sampling:","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"affine_hit_and_run(gecko_model, warmup_from_variability(gecko_model, GLPK.Optimizer))' *\nreaction_flux(gecko_model)","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"","category":"page"},{"location":"examples/15_gecko/","page":"GECKO","title":"GECKO","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/09_loopless.jl\"","category":"page"},{"location":"examples/09_loopless/#Loopless-FBA","page":"Loopless FBA","title":"Loopless FBA","text":"","category":"section"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"Here we will use flux_balance_analysis and flux_variability_analysis to analyze a toy model of E. coli that is constrained in a way that removes all thermodynamically infeasible loops in the flux solution. For more details about the algorithm, see Schellenberger, and, Palsson., \"Elimination of thermodynamically infeasible loops in steady-state metabolic models.\", Biophysical Journal, 2011.","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"If it is not already present, download the model:","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"In COBREXA.jl, the Loopless FBA is implemented as a modification of the normal FBA, called add_loopless_constraints. We use GLPK optimizer here, because the loopless constraints add integer programming into the problem. Simpler solvers (such as Tulip) may not be able to solve the mixed integer-linear (MILP) programs.","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"loopless_flux = flux_balance_analysis_vec(\n    model,\n    GLPK.Optimizer,\n    modifications = [add_loopless_constraints()],\n)","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"The representation is particularly convenient since it allows to also explore other properties of loopless models, such as variability and parsimonious balance, as well as other analyses that accept modifications parameter:","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"loopless_variability = flux_variability_analysis(\n    model,\n    GLPK.Optimizer,\n    modifications = [add_loopless_constraints()],\n)","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"For details about the loopless method, refer to Schellenberger, Jan, Nathan E. Lewis, and Bernhard Ã˜. Palsson: \"Elimination of thermodynamically infeasible loops in steady-state metabolic models.\" Biophysical journal 100, no. 3 (2011), pp. 544-553.","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"","category":"page"},{"location":"examples/09_loopless/","page":"Loopless FBA","title":"Loopless FBA","text":"This page was generated using Literate.jl.","category":"page"},{"location":"distributed/3_slurm/#Working-in-a-HPC-environment","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"","category":"section"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Many researchers have access to institutional HPC facilities that allow time-sharing of the capacity of a large computer cluster between many users. Julia and COBREXA.jl work well within this environment, and the COBREXA analyses usually require only minimal additional customization to be able to find and utilize the resources available from the HPC.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"When executed in a HPC environment, the analysis script must solve several relatively complex tasks:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"It needs to find out how many resources were allocated for the analysis\nIt needs to add the remote workers precisely at the allocated places","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Fortunately, the package ClusterManagers.jl does that for us. For simplicily, here we assume that your HPC is scheduled by Slurm, but other scheduling environments are supported in a very similar way.","category":"page"},{"location":"distributed/3_slurm/#Interacting-with-Slurm","page":"Working in a HPC environment","title":"Interacting with Slurm","text":"","category":"section"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Adding of the Slurm-provided is done as follows:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"you import the ClusterManagers package\nyou find how many processes to spawn from the environment from SLURM_NTASKS environment variable\nyou use the function addprocs_slurm to precisely connect to your allocated computational resources","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"After adding the Slurm workers, you may continue as if the workers were added using normal addprocs â€“- typically you load the model and (for example) run the flux_variability_analysis as if you would use the local workers.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"The Julia script that does a parallel analysis in a Slurm cluster may look as follows:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"using COBREXA, Distributed, ClusterManagers, GLPK\n\navailable_workers = parse(Int, ENV[\"SLURM_NTASKS\"])\n\naddprocs_slurm(available_workers)\n\n# ... load models, prepare data, etc. ...\n\nresult = flux_variability_analysis(...; workers=workers())\n\n# ... save the results into a file ...","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"tip: What about the other HPC schedulers?\nClusterManagers.jl supports many other common HPC scheduling systems, including LFS, Sun Grid, SGE, PBS, and Scyld, in a way almost identical to Slurm. See the package documentation for details.","category":"page"},{"location":"distributed/3_slurm/#Wrapping-your-script-in-a-Slurm-batch-job","page":"Working in a HPC environment","title":"Wrapping your script in a Slurm batch job","text":"","category":"section"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"To be able to submit your script for later processing using the sbatch Slurm command, you need to wrap it in a small \"batch\" script that tells Slurm how many resources the process needs.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Assuming you have a Julia computation script written down in myJob.jl and saved on your HPC cluster's access node, the corresponding Slurm batch script (let's call it myJob.sbatch) may look as follows:","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"#!/bin/bash -l\n#SBATCH -n 100           # the job will require 100 individual workers\n#SBATCH -c 1             # each worker will sit on a single CPU\n#SBATCH -t 30            # the whole job will take less than 30 minutes\n#SBATCH -J myJob         # the name of the job\n\nmodule load lang/Julia   # this is usually required to make Julia available to your job\n\njulia myJob.jl","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"To run the computation, simply run sbatch myJob.sbatch on the cluster access node.  The job will be scheduled and eventually executed. You may watch the output of commands sacct and squeue in the meantime, to see the progress.","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"Remember that you need to explicitly save the result of your Julia script computation to files, to be able to retrieve them later. Standard outputs of the jobs are often mangled and discarded. If you still want to collect the standard output of your Julia script, you may change the last line of the batch script to","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"julia myJob.jl > myJob.log","category":"page"},{"location":"distributed/3_slurm/","page":"Working in a HPC environment","title":"Working in a HPC environment","text":"and collect the output from myJob.log later. This is convenient especially if your script logs various computation details using @info and similar macros.","category":"page"},{"location":"functions/reconstruction/#Model-construction-functions","page":"Model construction functions","title":"Model construction functions","text":"","category":"section"},{"location":"functions/reconstruction/#Functions-for-changing-the-models","page":"Model construction functions","title":"Functions for changing the models","text":"","category":"section"},{"location":"functions/reconstruction/","page":"Model construction functions","title":"Model construction functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"reconstruction\", file), readdir(\"../src/reconstruction\"))","category":"page"},{"location":"functions/reconstruction/#COBREXA.add_reaction!-Tuple{CoreModel, Reaction}","page":"Model construction functions","title":"COBREXA.add_reaction!","text":"add_reaction!(model::CoreModel, rxn::Reaction)\n\n\nAdd rxn to model. The model must already contain the metabolites used by rxn in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions!-Tuple{CoreModel, Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.add_reactions!","text":"add_reactions!(model::CoreModel, rxns::Vector{Reaction})\n\n\nAdd rxns to model efficiently. The model must already contain the metabolites used by rxns in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractMatrix{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{String}, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModel, Sp::AbstractMatrix{Float64}, b::AbstractVector{Float64}, c::AbstractVector{Float64}, xl::AbstractVector{Float64}, xu::AbstractVector{Float64}, rxns::AbstractVector{String}, mets::AbstractVector{String}; check_consistency) -> Union{CoreModel, Tuple{CoreModel, Any, Any}}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractMatrix{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModel, Sp::AbstractMatrix{Float64}, b::AbstractVector{Float64}, c::AbstractVector{Float64}, xl::AbstractVector{Float64}, xu::AbstractVector{Float64}; check_consistency) -> Union{CoreModel, Tuple{CoreModel, Any, Any}}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractVector{Float64}, AbstractVector{Float64}, AbstractFloat, AbstractFloat, AbstractFloat, String, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModel, s::AbstractVector{Float64}, b::AbstractVector{Float64}, c::AbstractFloat, xl::AbstractFloat, xu::AbstractFloat, rxn::String, mets::AbstractVector{String}; check_consistency) -> Union{CoreModel, Tuple{CoreModel, Vector{Int64}, Any}}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractVector{Float64}, AbstractVector{Float64}, AbstractFloat, AbstractFloat, AbstractFloat}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModel, s::AbstractVector{Float64}, b::AbstractVector{Float64}, c::AbstractFloat, xl::AbstractFloat, xu::AbstractFloat; check_consistency) -> Union{CoreModel, Tuple{CoreModel, Vector{Int64}, Any}}\n\n\nAdd reaction(s) to a CoreModel model m.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, CoreModel}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m1::CoreModel, m2::CoreModel; check_consistency) -> Union{CoreModel, Tuple{CoreModel, Vector{Int64}, Vector{Int64}}}\n\n\nAdd all reactions from m2 to m1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModel,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModel,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModel,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModel,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::CoreModel, rxn_idx::Int64)\n\n\nChange objective function of a CoreModel to a single 1 at reaction index rxn_idx.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::CoreModel, rxn_id::String)\n\n\nChange objective function of a CoreModel to a single 1 at the given reaction ID.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, Vector{Int64}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::CoreModel, rxn_idxs::Vector{Int64}; weights)\n\n\nChange the objective to reactions at given indexes, optionally specifying their weights in the same order. By default, all set weights are 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, Vector{String}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::CoreModel, rxn_ids::Vector{String}; weights)\n\n\nChange objective of given reaction IDs, optionally specifying objective weights in the same order as rxn_ids. By default, all set weights are 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModel, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModel, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModel, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModel, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModel, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModel, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModel, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModel, reaction_id::String)\n\nRemove reaction from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModel, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModel, reaction_id::String)\n\nRemove reaction from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModel, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModel, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.verify_consistency-Union{Tuple{K}, Tuple{B}, Tuple{V}, Tuple{M}, Tuple{CoreModel, M, V, V, B, B, K, K, Any, Any}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, B<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.verify_consistency","text":"verify_consistency(m::CoreModel, Sp::AbstractMatrix{Float64}, b::AbstractVector{Float64}, c::AbstractVector{Float64}, xl::AbstractVector{Float64}, xu::AbstractVector{Float64}, names::AbstractVector{String}, mets::AbstractVector{String}, new_reactions, new_metabolites) -> Tuple{Any, Any}\n\n\nCheck the consistency of given reactions with existing reactions in m.\n\nTODO: work in progress, doesn't return consistency status.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints!-Tuple{CoreCoupling, AbstractVector{Float64}, AbstractFloat, AbstractFloat}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints!","text":"add_coupling_constraints!(m::CoreCoupling, c::AbstractVector{Float64}, cl::AbstractFloat, cu::AbstractFloat)\n\n\nOverload for adding a single coupling constraint.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints!-Union{Tuple{V}, Tuple{CoreCoupling, AbstractMatrix{Float64}, V, V}} where V<:AbstractVector{Float64}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints!","text":"add_coupling_constraints!(m::CoreCoupling, C::AbstractMatrix{Float64}, cl::AbstractVector{Float64}, cu::AbstractVector{Float64})\n\n\nIn-place add a single coupling constraint in form\n\n    câ‚— â‰¤ C x â‰¤ cáµ¤\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints-Tuple{CoreCoupling, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints","text":"add_coupling_constraints(m::CoreCoupling, args...) -> CoreCoupling\n\n\nAdd constraints of the following form to CoreCoupling and return the modified model.\n\nThe arguments are same as for in-place add_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints-Tuple{CoreModel, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints","text":"add_coupling_constraints(m::CoreModel, args...) -> CoreModelCoupled\n\n\nAdd coupling constraints to a plain CoreModel (returns a CoreModelCoupled).\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModelCoupled, CoreModel}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m1::CoreModelCoupled, m2::CoreModel; check_consistency) -> CoreModelCoupled\n\n\nAdd all reactions from m2 to m1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V2}, Tuple{V1}, Tuple{CoreModelCoupled, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat, String, K}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModelCoupled, s::AbstractVector{Float64}, b::AbstractVector{Float64}, c::AbstractFloat, xl::AbstractFloat, xu::AbstractFloat, rxn::String, mets::AbstractVector{String}; check_consistency) -> CoreModelCoupled\n\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V}, Tuple{M}, Tuple{CoreModelCoupled, M, V, V, V, V, K, K}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModelCoupled, Sp::AbstractMatrix{Float64}, b::AbstractVector{Float64}, c::AbstractVector{Float64}, xl::AbstractVector{Float64}, xu::AbstractVector{Float64}, rxns::AbstractVector{String}, mets::AbstractVector{String}; check_consistency) -> CoreModelCoupled\n\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{V2}, Tuple{V1}, Tuple{CoreModelCoupled, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModelCoupled, s::AbstractVector{Float64}, b::AbstractVector{Float64}, c::AbstractFloat, xl::AbstractFloat, xu::AbstractFloat; check_consistency) -> CoreModelCoupled\n\n\nAdd reaction(s) to a CoreModelCoupled model m.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{V}, Tuple{M}, Tuple{CoreModelCoupled, M, V, V, V, V}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m::CoreModelCoupled, Sp::AbstractMatrix{Float64}, b::AbstractVector{Float64}, c::AbstractVector{Float64}, xl::AbstractVector{Float64}, xu::AbstractVector{Float64}; check_consistency) -> CoreModelCoupled\n\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreCoupling,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreCoupling,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreCoupling,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreCoupling,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreCoupling,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreCoupling,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreCoupling,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreCoupling,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_coupling_bounds!-Union{Tuple{V}, Tuple{CoreCoupling, Vector{Int64}}} where V<:AbstractVector{Float64}","page":"Model construction functions","title":"COBREXA.change_coupling_bounds!","text":"change_coupling_bounds!(model::CoreCoupling, constraints::Vector{Int64}; cl, cu)\n\n\nChange the lower and/or upper bounds (cl and cu) for the given list of coupling constraints.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreCoupling, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::CoreCoupling, args...; kwargs...) -> Any\n\n\nForwards arguments to change_objective! of the internal model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_coupling_constraints!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_coupling_constraints!","text":"remove_coupling_constraints!(m::CoreCoupling, constraint::Int64)\n\n\nRemoves a single coupling constraints from a CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_coupling_constraints!-Tuple{CoreCoupling, Vector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_coupling_constraints!","text":"remove_coupling_constraints!(m::CoreCoupling, constraints::Vector{Int64})\n\n\nRemoves a set of coupling constraints from a CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_coupling_constraints-Tuple{CoreCoupling, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_coupling_constraints","text":"remove_coupling_constraints(m::CoreCoupling, args...) -> CoreCoupling\n\n\nRemove coupling constraints from the linear model, and return the modified model. Arguments are the same as for in-place version remove_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreCoupling, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreCoupling, metabolite_id::String)\n\nRemove metabolite from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreCoupling, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreCoupling, metabolite_id::String)\n\nRemove metabolite from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreCoupling, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreCoupling, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreCoupling, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreCoupling, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreCoupling, reaction_idx::Int)\n\nRemove reaction from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreCoupling, reaction_id::String)\n\nRemove reaction from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreCoupling, reaction_idx::Int)\n\nRemove reaction from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreCoupling, reaction_id::String)\n\nRemove reaction from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreCoupling, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreCoupling, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreCoupling, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreCoupling, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA._Stoichiometry","page":"Model construction functions","title":"COBREXA._Stoichiometry","text":"struct _Stoichiometry\n\nA small helper type for constructing reactions inline\n\nFields\n\ns::Dict{String, Float64}\n\n\n\n\n\n","category":"type"},{"location":"functions/reconstruction/#Base.:+-Tuple{Union{Metabolite, COBREXA._Stoichiometry}, Union{Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"Base.:+","text":"+(a::Union{Metabolite, COBREXA._Stoichiometry}, b::Union{Metabolite, COBREXA._Stoichiometry}) -> COBREXA._Stoichiometry\n\n\nShorthand for metabolite1 + metabolite2. Add 2 groups of Metabolites together to form reactions inline. Use with +, *, â†’ and similar operators.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.:â†-Tuple{Union{Nothing, Metabolite, COBREXA._Stoichiometry}, Union{Nothing, Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"COBREXA.:â†","text":"â†(substrates::Union{Nothing, Metabolite, COBREXA._Stoichiometry}, products::Union{Nothing, Metabolite, COBREXA._Stoichiometry}) -> Reaction\n\n\nShorthand for substrates â† products. Make a reverse-only Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.:â†’-Tuple{Union{Nothing, Metabolite, COBREXA._Stoichiometry}, Union{Nothing, Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"COBREXA.:â†’","text":"â†’(substrates::Union{Nothing, Metabolite, COBREXA._Stoichiometry}, products::Union{Nothing, Metabolite, COBREXA._Stoichiometry}) -> Reaction\n\n\nShorthand for substrates â†’ products. Make a forward-only Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.:â†”-Tuple{Union{Nothing, Metabolite, COBREXA._Stoichiometry}, Union{Nothing, Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"COBREXA.:â†”","text":"â†”(substrates::Union{Nothing, Metabolite, COBREXA._Stoichiometry}, products::Union{Nothing, Metabolite, COBREXA._Stoichiometry}) -> Reaction\n\n\nShorthand for substrates â†” products. Make a bidirectional (reversible) Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA._make_reaction_dict-Tuple{Any, Any}","page":"Model construction functions","title":"COBREXA._make_reaction_dict","text":"_make_reaction_dict(r, p) -> Dict{String, Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(model::Serialized, ...)\n\nCalls add_reactions of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(model::Serialized, ...)\n\nCalls change_bound of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(model::Serialized, ...)\n\nCalls change_bounds of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::Serialized, ...)\n\nCalls remove_metabolite of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::Serialized, ...)\n\nCalls remove_metabolites of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::Serialized, ...)\n\nCalls remove_reaction of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::Serialized, ...)\n\nCalls remove_reactions of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.unwrap_serialized-Tuple{Serialized}","page":"Model construction functions","title":"COBREXA.unwrap_serialized","text":"unwrap_serialized(model::Serialized) -> Union{Nothing, M} where M\n\n\nReturns the model stored in the serialized structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_gene!-Tuple{StandardModel, Gene}","page":"Model construction functions","title":"COBREXA.add_gene!","text":"add_gene!(model::StandardModel, gene::Gene)\n\n\nAdd gene to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_genes!-Tuple{StandardModel, Vector{Gene}}","page":"Model construction functions","title":"COBREXA.add_genes!","text":"add_genes!(model::StandardModel, genes::Vector{Gene})\n\n\nAdd genes to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_metabolite!-Tuple{StandardModel, Metabolite}","page":"Model construction functions","title":"COBREXA.add_metabolite!","text":"add_metabolite!(model::StandardModel, met::Metabolite)\n\n\nAdd met to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_metabolites!-Tuple{StandardModel, Vector{Metabolite}}","page":"Model construction functions","title":"COBREXA.add_metabolites!","text":"add_metabolites!(model::StandardModel, mets::Vector{Metabolite})\n\n\nAdd mets to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reaction!-Tuple{StandardModel, Reaction}","page":"Model construction functions","title":"COBREXA.add_reaction!","text":"add_reaction!(model::StandardModel, rxn::Reaction)\n\n\nAdd rxn to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions!-Tuple{StandardModel, Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.add_reactions!","text":"add_reactions!(model::StandardModel, rxns::Vector{Reaction})\n\n\nAdd rxns to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::StandardModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::StandardModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::StandardModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::StandardModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{StandardModel, Vector{String}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::StandardModel, rxn_ids::Vector{String}; weights)\n\n\nChange the objective for model to reaction(s) with rxn_ids, optionally specifying their weights. By default, assume equal weights. If no objective exists in model, sets objective.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_gene!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_gene!","text":"remove_gene!(model::StandardModel, gid::String; knockout_reactions)\n\n\nRemove gene with id from model. If knockout_reactions is true, then also constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_gene!(model, \"g1\")\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_genes!-Tuple{StandardModel, Vector{String}}","page":"Model construction functions","title":"COBREXA.remove_genes!","text":"remove_genes!(model::StandardModel, gids::Vector{String}; knockout_reactions)\n\n\nRemove all genes with ids from model. If knockout_reactions is true, then also constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_genes!(model, [\"g1\", \"g2\"])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::StandardModel, metabolite_id::String)\n\nRemove metabolite from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::StandardModel, metabolite_id::String)\n\nRemove metabolite from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::StandardModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::StandardModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::StandardModel, reaction_id::String)\n\nRemove reaction from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::StandardModel, reaction_id::String)\n\nRemove reaction from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::StandardModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::StandardModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.@add_reactions!-Tuple{Symbol, Expr}","page":"Model construction functions","title":"COBREXA.@add_reactions!","text":"Shortcut to add multiple reactions and their lower and upper bounds\n\nCall variants\n\n@add_reactions! model begin\n    reaction_name, reaction\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound, upper_bound\nend\n\nExamples\n\n@add_reactions! model begin\n    \"v1\", nothing â†’ A, 0, 500\n    \"v2\", A â†” B + C, -500\n    \"v3\", B + C â†’ nothing\nend\n\n\n\n\n\n","category":"macro"},{"location":"functions/reconstruction/#COBREXA.add_community_objective!-Tuple{CoreModel, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.add_community_objective!","text":"add_community_objective!(community::CoreModel, objective_mets_weights::Dict{String, Float64}; objective_id)\n\n\nAdd an objective column to the community model with optional id objective_id. Supply a dictionary mapping the string names of the objective metabolites to their weights in objective_mets_weights. Note, the weights are negated inside the function so that positive weights are seen as reagents/substrates, NOT products in the reaction equation.\n\nExample\n\nadd_community_objective!(model, Dict(\"met1\"=>1.0, \"met2\"=>2.0))\n\nSee also: update_community_objective!\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_community_objective!-Tuple{StandardModel, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.add_community_objective!","text":"add_community_objective!(community::StandardModel, objective_mets_weights::Dict{String, Float64}; objective_id)\n\n\nVariant of [add_community_objective!] that takes a StandardModel community model as input.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_model_with_exchanges!-Tuple{StandardModel, MetabolicModel, Dict{String, String}}","page":"Model construction functions","title":"COBREXA.add_model_with_exchanges!","text":"add_model_with_exchanges!(community::StandardModel, model::MetabolicModel, exchange_rxn_mets::Dict{String, String}; model_name, biomass_id)\n\n\nThe StandardModel variant of add_model_with_exchanges, but is in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_model_with_exchanges-Tuple{CoreModel, MetabolicModel, Dict{String, String}}","page":"Model construction functions","title":"COBREXA.add_model_with_exchanges","text":"add_model_with_exchanges(community::CoreModel, model::MetabolicModel, exchange_rxn_mets::Dict{String, String}; model_name, biomass_id) -> CoreModel\n\n\nAdd model to community, which is a pre-existing community model with exchange reactions and metabolites in the dictionary exchange_rxn_mets. The model_name is appended to each reaction and metabolite, see join_with_exchanges. If biomass_id is specified then a biomass metabolite for model is also added to the resulting model. The column corresponding to the biomass_id reaction then produces this new biomass metabolite with unit coefficient. The exchange reactions and metabolites in exchange_rxn_mets must already exist in community. Always returns a new community model because it is more efficient than resizing all the matrices.\n\nNo in-place variant for CoreModels exists yet.\n\nExample\n\ncommunity = add_model_with_exchanges(community,\n    model,\n    exchange_rxn_mets;\n    model_name=\"species_2\",\n    biomass_id=\"BIOMASS_Ecoli_core_w_GAM\")\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_model_with_exchanges-Tuple{StandardModel, MetabolicModel, Dict{String, String}}","page":"Model construction functions","title":"COBREXA.add_model_with_exchanges","text":"add_model_with_exchanges(community::StandardModel, model::MetabolicModel, exchange_rxn_mets::Dict{String, String}; model_name, biomass_id) -> StandardModel\n\n\nThe StandardModel variant of add_model_with_exchanges. Makes a deepcopy of community and calls the inplace variant of this function on that copy.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.join_with_exchanges-Union{Tuple{M}, Tuple{Type{CoreModel}, Vector{M}, Dict{String, String}}} where M<:MetabolicModel","page":"Model construction functions","title":"COBREXA.join_with_exchanges","text":"join_with_exchanges(::Type{CoreModel}, models::Array{M<:MetabolicModel, 1}, exchange_rxn_mets::Dict{String, String}; biomass_ids, model_names) -> CoreModel\n\n\nReturn a CoreModel representing the community model of models joined through their exchange reactions and metabolites in the dictionary exchange_rxn_mets, which maps exchange reactions to their associated metabolite. These exchange reactions and metabolites link model metabolites to environmental metabolites and reactions. Optionally specify model_names to append a specific name to each reaction and metabolite of an organism for easier reference (default is species_i for each model index i in models). Note, the bounds of the environmental variables are all set to zero. Thus, to run a simulation you need to constrain them appropriately. All the other bounds are inherited from the models used to construct the community model.\n\nIf biomass_ids is supplied, then a community model is returned that has an extra reaction added to the end of the stoichiometric matrix (last column) that can be assigned as the objective reaction. It also creates biomass \"metabolites\" that can be used in this objective reaction. In the returned mode, these biomass metabolites are produced by the reaction corresponding to biomass_ids in each model respectively. Note, this reaction is unspecified, further action needs to be taken to specify it, e.g. assign weights to the last column of the stoichiometric matrix in the rows corresponding to the biomass metabolites.\n\nTo further clarify how this join works. Suppose you have 2 organisms with stoichiometric matrices Sâ‚ and Sâ‚‚ and you want to link them with exchange_rxn_mets = Dict(erâ‚ => emâ‚, erâ‚‚ => emâ‚‚, erâ‚ƒ => emâ‚ƒ, ...). Then a new community stoichiometric matrix is constructed that looks like this:\n\n            _      erâ‚  erâ‚‚  erâ‚ƒ  ...  b_\n           |Sâ‚                           |\n           |   Sâ‚‚                        |\n        emâ‚|                             |\nS   =   emâ‚‚|                             |\n        emâ‚ƒ|                             |\n        ...|                             |\n        bmâ‚|                             |\n        bmâ‚‚|_                           _|\n\n\nThe exchange reactions in each model get linked to environmental metabolites, emáµ¢, and these get linked to environmental exchanges, eráµ¢. These eráµ¢ behave like normal single organism exchange reactions. When biomass_ids are supplied, each model's biomass reaction produces a pseudo-metabolite (bmáµ¢). These can be weighted in column b, called the community_biomass reaction in the community model, if desired. Refer to the tutorial if this is unclear.\n\nExample\n\nm1 = load_model(core_model_path)\nm2 = load_model(CoreModel, core_model_path)\n\n# need to list ALL the exchanges that will form part of the entire model\nexchange_rxn_mets = Dict(k => first(keys(reaction_stoichiometry(m1, ex_rxn)))\n    for filter(looks_like_exchange_reaction, reactions(m1)))\n\nbiomass_ids = [\"BIOMASS_Ecoli_core_w_GAM\", \"BIOMASS_Ecoli_core_w_GAM\"]\n\ncommunity = join_with_exchanges(\n    CoreModel,\n    [m1, m2],\n    exchange_rxn_mets;\n    biomass_ids = biomass_ids,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.join_with_exchanges-Union{Tuple{M}, Tuple{Type{StandardModel}, Vector{M}, Dict{String, String}}} where M<:MetabolicModel","page":"Model construction functions","title":"COBREXA.join_with_exchanges","text":"join_with_exchanges(::Type{StandardModel}, models::Array{M<:MetabolicModel, 1}, exchange_rxn_mets::Dict{String, String}; biomass_ids, model_names) -> StandardModel\n\n\nA variant of join_with_exchanges that returns a StandardModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.update_community_objective!-Tuple{CoreModel, String, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.update_community_objective!","text":"update_community_objective!(community::CoreModel, objective_id::String, objective_mets_weights::Dict{String, Float64})\n\n\nUpdate the weights for the objective column with id objective_id in community using objective_mets_weights, which maps metabolite ids to weights. The current weights are reset to 0 before being updated to the supplied weights. Note, the weights are negated inside the function so that the objective metabolites are seen as reagents/substrates, NOT products in the reaction equation.\n\nExample\n\nupdate_community_objective!(model, \"community_biomass\", Dict(\"met1\"=>1.0, \"met2\"=>2.0))\n\nSee also: add_community_objective!\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.update_community_objective!-Tuple{StandardModel, String, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.update_community_objective!","text":"update_community_objective!(community::StandardModel, objective_id::String, objective_mets_weights::Dict{String, Float64})\n\n\nVariant of [update_community_objective!] that takes a StandardModel community model as input.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_gecko-Tuple{}","page":"Model construction functions","title":"COBREXA.with_gecko","text":"with_gecko(; kwargs...) -> COBREXA.var\"#386#387\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nSpecifies a model variant which adds extra semantics of the Gecko algorithm, giving a GeckoModel. The arguments are forwarded to make_gecko_model. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_smoment-Tuple{}","page":"Model construction functions","title":"COBREXA.with_smoment","text":"with_smoment(; kwargs...) -> COBREXA.var\"#383#384\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nSpecifies a model variant which adds extra semantics of the sMOMENT algorithm, giving a SMomentModel. The arguments are forwarded to make_smoment_model. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA._universal_stoichiometry-Tuple{Vector{Reaction}, Vector{String}}","page":"Model construction functions","title":"COBREXA._universal_stoichiometry","text":"_universal_stoichiometry(urxns::Vector{Reaction}, mids::Vector{String}) -> NamedTuple{(:stoichiometry, :lbs, :ubs, :new_mids), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}, Vector{Float64}, Vector{String}}}\n\n\nA helper function that constructs the stoichiometric matrix of a set of universal_reactions. The order of the metabolites is determined with mids, so that this stoichiometric matrix can be combined with another one.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfill_minimum_reactions-Tuple{MetabolicModel, Vector{Reaction}, Any}","page":"Model construction functions","title":"COBREXA.gapfill_minimum_reactions","text":"gapfill_minimum_reactions(model::MetabolicModel, universal_reactions::Vector{Reaction}, optimizer; objective_bounds, maximum_new_reactions, weights, modifications) -> JuMP.Model\n\n\nFind a minimal set of reactions from universal_reactions that should be added to model so that the model has a feasible solution with bounds on its objective function given in objective_bounds.  Weights of the added reactions may be specified in weights to prefer adding reactions with lower weights.\n\nInternally, this builds and solves a mixed integer program, following the method of Reed et al. (Reed, Jennifer L., et al. \"Systems approach to refining genome annotation.\" Proceedings of the National Academy of Sciences (2006)).\n\nThe function returns a solved JuMP optimization model, with the boolean reaction inclusion indicators in variable vector y. Use gapfilled_mask or gapfilled_rids to collect the reaction information in Julia datatypes.\n\nTo reduce the uncertainty in the MILP solver (and likely reduce the complexity), you may put a limit on the size of the added reaction set in maximum_new_reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfilled_mask-Tuple{Any}","page":"Model construction functions","title":"COBREXA.gapfilled_mask","text":"gapfilled_mask(opt_model) -> BitVector\n\n\nGet a BitVector of added reactions from the model solved by gapfill_minimum_reactions. The bit indexes correspond to the indexes of universal_reactions given to the gapfilling function. In case the model is not solved, this returns nothing.\n\nExample\n\ngapfill_minimum_reactions(myModel, myReactions, Tulip.Optimizer) |> gapfilled_mask\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfilled_rids-Tuple{Any, Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.gapfilled_rids","text":"gapfilled_rids(opt_model, universal_reactions::Vector{Reaction}) -> Vector{String}\n\n\nUtility to extract a short vector of IDs of the reactions added by the gapfilling algorithm. Use with opt_model returned from gapfill_minimum_reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfilled_rids-Tuple{Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.gapfilled_rids","text":"gapfilled_rids(universal_reactions::Vector{Reaction}) -> COBREXA.var\"#397#398\"{Vector{Reaction}}\n\n\nOverload of gapfilled_rids that can be piped easily.\n\nExample\n\ngapfill_minimum_reactions(myModel, myReactions, Tulip.Optimizer) |> gapfilled_rids(myReactions)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#Variant-specifiers","page":"Model construction functions","title":"Variant specifiers","text":"","category":"section"},{"location":"functions/reconstruction/","page":"Model construction functions","title":"Model construction functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"reconstruction\", \"modifications\", file), readdir(\"../src/reconstruction/modifications\"))","category":"page"},{"location":"functions/reconstruction/#COBREXA.with_added_reactions-Tuple","page":"Model construction functions","title":"COBREXA.with_added_reactions","text":"with_added_reactions(args...; kwargs...) -> COBREXA.var\"#431#432\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nSpecifies a model variant with reactions added. Forwards the arguments to add_reactions. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_changed_bound-Tuple","page":"Model construction functions","title":"COBREXA.with_changed_bound","text":"with_changed_bound(args...; kwargs...) -> COBREXA.var\"#419#420\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nSpecifies a model variant that has a new bound set. Forwards arguments to change_bound. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_changed_bounds-Tuple","page":"Model construction functions","title":"COBREXA.with_changed_bounds","text":"with_changed_bounds(args...; kwargs...) -> COBREXA.var\"#422#423\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nSpecifies a model variant that has new bounds set. Forwards arguments to change_bounds. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_metabolite-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_metabolite","text":"with_removed_metabolite(args...; kwargs...) -> COBREXA.var\"#425#426\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nSpecifies a model variant without a certain metabolite. Forwards arguments to remove_metabolite. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_metabolites-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_metabolites","text":"with_removed_metabolites(args...; kwargs...) -> COBREXA.var\"#428#429\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nPlural version of with_removed_metabolite, calls remove_metabolites internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_reaction-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_reaction","text":"with_removed_reaction(args...; kwargs...) -> COBREXA.var\"#434#435\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nSpecifies a model variant without a certain reaction. Forwards arguments to remove_reaction. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_reactions-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_reactions","text":"with_removed_reactions(args...; kwargs...) -> COBREXA.var\"#437#438\"{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}\n\n\nPlural version of with_removed_reaction, calls remove_reactions internally.\n\n\n\n\n\n","category":"method"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/05a_fba.jl\"","category":"page"},{"location":"examples/05a_fba/#Flux-balance-analysis-(FBA)","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"","category":"section"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"We will use flux_balance_analysis and several related functions to find the optimal flux in the E. coli \"core\" model.","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"If it is not already present, download the model and load the package:","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"To perform any optimization-based analysis, we need to use a linear programming solver (also called an optimizer). Any of the JuMP.jl-supported optimizers will work. Here, we will demonstrate Tulip.jl and GLPK; other solvers will likely work just as well.","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"using Tulip\n\nsolved_model = flux_balance_analysis(model, Tulip.Optimizer)","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"solved_model is now an instance of optimized JuMP model. To get the variable values out manually, we can use JuMP.value function. Flux variables are stored as vector x:","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"using JuMP\nvalue.(solved_model[:x])","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"To simplify things, there is a variant of the FBA function that does this for us automatically:","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"flux_balance_analysis_vec(model, Tulip.Optimizer)","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"Likewise, there is another variant that returns the fluxes annotated by reaction names, in a dictionary:","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"Switching solvers is easy, and may be useful in case we need advanced functionality or performance present only in certain solvers. To switch to GLPK, we simply load the package and use a different optimizer to run the analysis:","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"using GLPK\nflux_balance_analysis_dict(model, GLPK.Optimizer)","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"To get a shortened but useful overview of what was found in the analysis, you can use flux_summary function:","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"flux_summary(flux_balance_analysis_dict(model, GLPK.Optimizer))","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"","category":"page"},{"location":"examples/05a_fba/","page":"Flux balance analysis (FBA)","title":"Flux balance analysis (FBA)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/04_standardmodel.jl\"","category":"page"},{"location":"examples/04_standardmodel/#Basic-usage-of-StandardModel","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"section"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"In this tutorial we will use COBREXA's StandardModel and functions that specifically operate on it. As usual we will use the toy model of E. coli for demonstration.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nusing COBREXA","category":"page"},{"location":"examples/04_standardmodel/#Loading-a-model-in-the-StandardModel-format","page":"Basic usage of StandardModel","title":"Loading a model in the StandardModel format","text":"","category":"section"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model = load_model(StandardModel, \"e_coli_core.json\") # we specifically want to load a StandardModel from the model file","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"note: Note: Loading `StandardModel`s implicitly uses `convert`\nWhen using load_model(StandardModel, file_location) the model at   file_location is first loaded into its inferred format and is then   converted to a StandardModel using the generic accessor interface.   Thus, data loss may occur. Always check your model to ensure that   nothing important has been lost.","category":"page"},{"location":"examples/04_standardmodel/#Internals-of-StandardModel","page":"Basic usage of StandardModel","title":"Internals of StandardModel","text":"","category":"section"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"A benefit of StandardModel is that it supports a richer internal infrastructure that can be used to manipulate internal model attributes in a systematic way. Specifically, the genes, reactions, and metabolites with of a model each have a type. This is particularly useful when modifying or even constructing a model from scratch.","category":"page"},{"location":"examples/04_standardmodel/#Genes,-Reactions,-and-Metabolites","page":"Basic usage of StandardModel","title":"Genes, Reactions, and Metabolites","text":"","category":"section"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel is composed of ordered dictionaries of Genes, Metabolites and Reactions. Ordered dictionaries are used because the order of the reactions and metabolites are important for constructing a stoichiometric matrix since the rows and columns should correspond to the order of the metabolites and reactions returned by calling the accessors metabolites and reactions.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Each StandardModel is composed of the following fields:","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(StandardModel) # fields of a StandardModel","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The :genes field of a StandardModel contains an ordered dictionary of gene ids mapped to Genes.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model.genes # the keys of this dictionary are the same as genes(model)","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The Gene type is a struct that can be used to store information about genes in a StandardModel. Each Gene is composed of the following fields:","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(Gene)","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"tip: Tip: Use <tab> complete to explore the structure of types\nUse <tab> to quickly explore the fields of a struct. For example,   Gene.<tab> will list all the fields shown above.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The keys used in the ordered dictionaries in model.genes are the ids returned using the generic accessor genes. Genes have pretty printing, as demonstrated below for a random gene drawn from the model:","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_gene_id = genes(model)[rand(1:n_genes(model))]\nmodel.genes[random_gene_id]","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The same idea holds for both metabolites (stored as Metabolites) and reactions (stored as Reactions). This is demonstrated below.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_metabolite_id = metabolites(model)[rand(1:n_metabolites(model))]\nmodel.metabolites[random_metabolite_id]","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_reaction_id = reactions(model)[rand(1:n_reactions(model))]\nmodel.reactions[random_reaction_id]","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel can be used to build your own metabolic model or modify an existing one. One of the main use cases for StandardModel is that it can be used to merge multiple models or parts of multiple models together. Since the internals are uniform inside each StandardModel, attributes of other model types are squashed into the required format (using the generic accessors). This ensures that the internals of all StandardModels are the same - allowing easy systematic evaluation.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"warning: Warning: Combining models with different namespaces is tricky\nCombining models that use different namespaces requires care.   For example, in some models the water exchange reaction is called   EX_h2o_e, while in others it is called R_EX_h2o_s. This needs to   manually addressed to prevent duplicates, e.g. reactions,   from being added.","category":"page"},{"location":"examples/04_standardmodel/#Checking-the-internals-of-StandardModels:-annotation_index","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: annotation_index","text":"","category":"section"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Often when models are automatically reconstructed duplicate genes, reactions or metabolites end up in a model. COBREXA exports annotation_index to check for cases where the id of a struct may be different, but the annotations the same (possibly suggesting a duplication). annotation_index builds a dictionary mapping annotation features to the ids of whatever struct you are inspecting. This makes it easy to find structs that share certain annotation features.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations = annotation_index(model.reactions)","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations[\"ec-code\"]","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The annotation_index function can also be used on Reactions and Genes in the same way.","category":"page"},{"location":"examples/04_standardmodel/#Checking-the-internals-of-StandardModels:-check_duplicate_reaction","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: check_duplicate_reaction","text":"","category":"section"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another useful function is check_duplicate_reaction, which checks for reactions that have duplicate (or similar) reaction equations.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"pgm_duplicate = Reaction()\npgm_duplicate.id = \"pgm2\" # Phosphoglycerate mutase\npgm_duplicate.metabolites = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1)\npgm_duplicate","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"check_duplicate_reaction(pgm_duplicate, model.reactions; only_metabolites = false) # can also just check if only the metabolites are the same but different stoichiometry is used","category":"page"},{"location":"examples/04_standardmodel/#Checking-the-internals-of-StandardModels:-reaction_mass_balanced","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: reaction_mass_balanced","text":"","category":"section"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Finally, reaction_mass_balanced can be used to check if a reaction is mass balanced based on the formulas of the reaction equation.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_dict = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1, \"h2o_c\" => 1)\nreaction_mass_balanced(model, rxn_dict)","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Now to determine which atoms are unbalanced, you can use reaction_atom_balance","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"reaction_atom_balance(model, rxn_dict)","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Note, since pgm_duplicate is not in the model, we cannot use the other variants of this function because they find the reaction equation stored inside the model.","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"page"},{"location":"examples/04_standardmodel/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/11_growth.jl\"","category":"page"},{"location":"examples/11_growth/#Growth-media-analysis","page":"Growth media analysis","title":"Growth media analysis","text":"","category":"section"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"Nutrient availability is a major driving factor for growth of microorganisms and energy production in cells. Here, we demonstrate two main ways to examine the nutrient consumption with COBREXA.jl: Simulating deficiency of nutrients, and finding the minimal flux of nutrients required to support certain model output.","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"As always, we work on the toy model of E. coli:","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"using COBREXA, GLPK\n\n!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nmodel = load_model(StandardModel, \"e_coli_core.xml\")","category":"page"},{"location":"examples/11_growth/#What-nutrients-does-my-model-need-to-grow?","page":"Growth media analysis","title":"What nutrients does my model need to grow?","text":"","category":"section"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"The models usually ingest nutrients through exchange reactions. By changing the bounds on the exchange reactions, you can limit the intake of the nutrients and thus simulate the nutrient deficiency. If applied programatically to multiple exchanges, this can give you a good overview of what nutrients impact the model most.","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"To check the viability of a single nutrient, you can simply change a bound on a selected exchange reaction and simulate the model with a limited amount.","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"biomass = \"R_BIOMASS_Ecoli_core_w_GAM\"\n\nmodel_limited = change_bound(model, \"R_EX_glc__D_e\", lower = -1.0)","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"tip: Exchange directions\nBy a convention, the direction of exchange reaction usually goes from the model into the environment, representing the \"production\". Limiting the intake thus happens by disabling the \"negative production\", i.e., placing a lower bound.","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"original_production = flux_balance_analysis_dict(model, GLPK.Optimizer)[biomass]\nlimited_production = flux_balance_analysis_dict(model_limited, GLPK.Optimizer)[biomass]\n\noriginal_production, limited_production","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"Function flux_summary can help with quickly spotting what has changed:","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"flux_summary(flux_balance_analysis_dict(model_limited, GLPK.Optimizer))","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"Similarly, you can check that the model can survive without oxygen, at the cost of switching the metabolism to ethanol production:","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"flux_summary(\n    flux_balance_analysis_dict(\n        change_bound(model, \"R_EX_o2_e\", lower = 0.0),\n        GLPK.Optimizer,\n    ),\n)","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"The effect of all nutrients on the metabolism can be scanned using screen. The change_bound function is, for this purpose, packed in a variant specified with_changed_bound:","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"exchanges = filter(looks_like_exchange_reaction, reactions(model))\n\nexchanges .=> screen(\n    model,\n    variants = [[with_changed_bound(exchange, lower = 0.0)] for exchange in exchanges],\n    analysis = m -> begin\n        res = flux_balance_analysis_dict(m, GLPK.Optimizer)\n        isnothing(res) ? nothing : res[biomass]\n    end,\n)","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"Similarly to gene knockouts, you can also examine the effect of combined nutrient deficiencies. To obtain a more interesting result, we may examine the effect of slight deficiencies of pairs of intake metabolites. For simplicity, we show the result only on a small subset of the exchanges:","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"selected_exchanges = [\n    \"R_EX_pi_e\",\n    \"R_EX_gln__L_e\",\n    \"R_EX_nh4_e\",\n    \"R_EX_pyr_e\",\n    \"R_EX_fru_e\",\n    \"R_EX_glu__L_e\",\n    \"R_EX_glc__D_e\",\n    \"R_EX_o2_e\",\n]\n\nscreen(\n    model,\n    variants = [\n        [with_changed_bounds([e1, e2], lower = [-1.0, -0.1])] for e1 in selected_exchanges,\n        e2 in selected_exchanges\n    ],\n    analysis = m -> begin\n        res = flux_balance_analysis_dict(m, GLPK.Optimizer)\n        isnothing(res) ? nothing : res[biomass]\n    end,\n)","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"The result describes combinations of nutrient deficiencies â€“ the nutrient that corresponds to the row is mildly deficient (limited to uptake 1.0), and the one that corresponds to the column is severely limited (to uptake 0.1).","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"tip: Screening can be easily parallelized\nTo speed up larger analyses, remember that execution of screen can be parallelized to gain speedup. Parallelization in screen is optimized to avoid unnecessary data transfers that may occur when using trivial pmap.","category":"page"},{"location":"examples/11_growth/#What-is-the-minimal-flux-of-nutrients-for-my-model-to-grow?","page":"Growth media analysis","title":"What is the minimal flux of nutrients for my model to grow?","text":"","category":"section"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"You can compute the minimal flux (i.e., mass per time) of required nutrients by constraining the model growth to a desired lower bound, and then optimize the model with an objective that minimizes intake of all exchanges (i.e., given the directionality convention of the exchanges, actually maximizes the flux through all exchange reactions along their direction).","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"model_with_bounded_production = change_bound(model, biomass, lower = 0.1) #minimum required growth\n\nminimal_intake_production = flux_balance_analysis_dict(\n    model_with_bounded_production,\n    GLPK.Optimizer,\n    modifications = [change_objective(exchanges)],\n);\nnothing #hide","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"Metabolite \"cost\" data may be supplemented using the weights argument of change_objective, to reflect e.g. the different molar masses or energetic values of different nutrients.","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"In our simple case, we obtain the following minimal required intake:","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"flux_summary(minimal_intake_production)","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"","category":"page"},{"location":"examples/11_growth/","page":"Growth media analysis","title":"Growth media analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"functions/types/#Base-types","page":"Types","title":"Base types","text":"","category":"section"},{"location":"functions/types/","page":"Types","title":"Types","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", \"abstract\", file), readdir(\"../src/base/types/abstract\"))","category":"page"},{"location":"functions/types/#COBREXA.Maybe","page":"Types","title":"COBREXA.Maybe","text":"Maybe{T} = Union{Nothing, T}\n\nA nice name for \"nullable\" type.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._default-Union{Tuple{T}, Tuple{T, Union{Nothing, T}}} where T","page":"Types","title":"COBREXA._default","text":"_default(d, x::Union{Nothing, T} where T) -> Any\n\n\nFold the Maybe{T} down to T by defaulting.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA._maybemap-Tuple{Any, Any}","page":"Types","title":"COBREXA._maybemap","text":"_maybemap(f, x) -> Any\n\n\nApply a function to x only if it is not nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Annotations","page":"Types","title":"COBREXA.Annotations","text":"Annotations = Dict{String,Vector{String}}\n\nDictionary used to store (possible multiple) standardized annotations of something, such as a Metabolite and a Reaction.\n\nExample\n\nAnnotations(\"PubChem\" => [\"CID12345\", \"CID54321\"])\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.GeneAssociation","page":"Types","title":"COBREXA.GeneAssociation","text":"GeneAssociation = Vector{Vector{String}}\n\nAn association to genes, represented as a logical formula in a positive disjunctive normal form (DNF). (The 2nd-level vectors of strings are connected by \"and\" to form conjunctions, and the 1st-level vectors of these conjunctions are connected by \"or\" to form the DNF.)\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.MetabolicModel","page":"Types","title":"COBREXA.MetabolicModel","text":"abstract type MetabolicModel end\n\nA helper supertype of everything usable as a linear-like model for COBREXA functions.\n\nIf you want your model type to work with COBREXA, add the MetabolicModel as its supertype, and implement the accessor functions. Accessors reactions, metabolites, stoichiometry, bounds and objective must be implemented; others are not mandatory and default to safe \"empty\" values.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.MetaboliteFormula","page":"Types","title":"COBREXA.MetaboliteFormula","text":"MetaboliteFormula = Dict{String,Int}\n\nDictionary of atoms and their abundances in a molecule.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.ModelWrapper","page":"Types","title":"COBREXA.ModelWrapper","text":"abstract type ModelWrapper <: MetabolicModel end\n\nA helper supertype of all \"wrapper\" types that contain precisely one other MetabolicModel.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Notes","page":"Types","title":"COBREXA.Notes","text":"Notes = Dict{String,Vector{String}}\n\nFree-form notes about something (e.g. a Gene), categorized by \"topic\".\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Model-types-and-contents","page":"Types","title":"Model types and contents","text":"","category":"section"},{"location":"functions/types/","page":"Types","title":"Types","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", file), readdir(\"../src/base/types\"))","category":"page"},{"location":"functions/types/#COBREXA.CoreModel","page":"Types","title":"COBREXA.CoreModel","text":"mutable struct CoreModel <: MetabolicModel\n\nA \"bare bones\" core linear optimization problem of the form, with reaction and metabolite names.\n\nmin c^T x\ns.t. S x = b\n      xâ‚— â‰¤ x â‰¤ xáµ¤\n\nFields\n\nS::SparseArrays.SparseMatrixCSC{Float64, Int64}\nb::SparseArrays.SparseVector{Float64, Int64}\nc::SparseArrays.SparseVector{Float64, Int64}\nxl::Vector{Float64}\nxu::Vector{Float64}\nrxns::Vector{String}\nmets::Vector{String}\ngrrs::Vector{Union{Nothing, Vector{Vector{String}}}}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Union{Tuple{M}, Tuple{Type{CoreModel}, M}} where M<:MetabolicModel","page":"Types","title":"Base.convert","text":"convert(_::Type{CoreModel}, m::MetabolicModel) -> MetabolicModel\n\n\nMake a CoreModel out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{CoreModel}","page":"Types","title":"COBREXA.balance","text":"balance(a::CoreModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nCoreModel target flux balance.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{CoreModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(a::CoreModel) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nCoreModel flux bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{CoreModel}","page":"Types","title":"COBREXA.genes","text":"genes(a::CoreModel) -> Vector{String}\n\n\nCollect all genes contained in the CoreModel. The call is expensive for large models, because the vector is not stored and instead gets rebuilt each time this function is called.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{CoreModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(a::CoreModel) -> Vector{String}\n\n\nMetabolites in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{CoreModel}","page":"Types","title":"COBREXA.objective","text":"objective(a::CoreModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nCoreModel objective vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{CoreModel, Int64}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::CoreModel, ridx::Int64) -> Union{Nothing, Vector{Vector{String}}}\n\n\nRetrieve the GeneAssociation from CoreModel by reaction index.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{CoreModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::CoreModel, rid::String) -> Union{Nothing, Vector{Vector{String}}}\n\n\nRetrieve the GeneAssociation from CoreModel by reaction ID.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association_vec-Tuple{CoreModel}","page":"Types","title":"COBREXA.reaction_gene_association_vec","text":"reaction_gene_association_vec(model::CoreModel) -> Vector{Union{Nothing, Vector{Vector{String}}}}\n\n\nRetrieve a vector of all gene associations in a CoreModel, in the same order as reactions(model).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{CoreModel, Any}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(m::CoreModel, ridx) -> Dict{String, Float64}\n\n\nReturn the stoichiometry of reaction at index ridx.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{CoreModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(m::CoreModel, rid::String) -> Dict{String, Float64}\n\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{CoreModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(a::CoreModel) -> Vector{String}\n\n\nGet the reactions in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{CoreModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(a::CoreModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nCoreModel stoichiometry matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.CoreCoupling","page":"Types","title":"COBREXA.CoreCoupling","text":"mutable struct CoreCoupling{M} <: ModelWrapper\n\nA matrix-based wrap that adds reaction coupling matrix to the inner model. A flux x feasible in this model must satisfy:\n\n    câ‚— â‰¤ C x â‰¤ cáµ¤\n\nFields\n\nlm::Any\nC::SparseArrays.SparseMatrixCSC{Float64, Int64}\ncl::Vector{Float64}\ncu::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.CoreModelCoupled","page":"Types","title":"COBREXA.CoreModelCoupled","text":"const CoreModelCoupled = CoreCoupling{CoreModel}\n\nA matrix-based linear model with additional coupling constraints in the form:\n\n    câ‚— â‰¤ C x â‰¤ cáµ¤\n\nInternally, the model is implemented using CoreCoupling that contains a single CoreModel.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Union{Tuple{M}, Tuple{Type{CoreCoupling{M}}, MetabolicModel}} where M","page":"Types","title":"Base.convert","text":"convert(::Type{CoreCoupling{M}}, mm::MetabolicModel; clone_coupling) -> MetabolicModel\n\n\nMake a CoreCoupling out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.coupling","text":"coupling(a::CoreCoupling) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nCoupling constraint matrix for a CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::CoreCoupling) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nCoupling bounds for a CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::CoreCoupling) -> Int64\n\n\nThe number of coupling constraints in a CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association_vec-Tuple{CoreModelCoupled}","page":"Types","title":"COBREXA.reaction_gene_association_vec","text":"reaction_gene_association_vec(model::CoreModelCoupled)\n\nEvaluates reaction_gene_association_vec on the model contained in CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{CoreModelCoupled, Int64}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModelCoupled, ridx::Int)\n\nEvaluates reaction_stoichiometry on the model contained in CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.unwrap_model-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.unwrap_model","text":"unwrap_model(a::CoreCoupling) -> Any\n\n\nGet the internal CoreModel out of CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.FluxSummary","page":"Types","title":"COBREXA.FluxSummary","text":"struct FluxSummary\n\nA struct used to store summary information about the solution of a constraint based analysis result.\n\nFields\n\nbiomass_fluxes::OrderedCollections.OrderedDict{String, Float64}\nimport_fluxes::OrderedCollections.OrderedDict{String, Float64}\nexport_fluxes::OrderedCollections.OrderedDict{String, Float64}\nunbounded_fluxes::OrderedCollections.OrderedDict{String, Float64}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.FluxSummary-Tuple{}","page":"Types","title":"COBREXA.FluxSummary","text":"FluxSummary() -> FluxSummary\n\n\nA default empty constructor for FluxSummary.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.flux_summary-Tuple{Union{Nothing, Dict{String, Float64}}}","page":"Types","title":"COBREXA.flux_summary","text":"flux_summary(flux_result::Union{Nothing, Dict{String, Float64}}; exclude_exchanges, exchange_prefixes, biomass_strings, exclude_biomass, small_flux_bound, large_flux_bound, keep_unbounded) -> FluxSummary\n\n\nSummarize a dictionary of fluxes into small, useful representation of the most important information contained. Useful for pretty-printing and quickly exploring the results. Internally this function uses looks_like_biomass_reaction and looks_like_exchange_reaction. The corresponding keyword arguments passed to these functions. Use this if your model has non-standard ids for reactions. Fluxes smaller than small_flux_bound are not stored, while fluxes larger than large_flux_bound are only stored if keep_unbounded is true.\n\nExample\n\njulia> sol = flux_dict(flux_balance_analysis(model, Tulip.Optimizer))\njulia> fr = flux_summary(sol)\nBiomass:\n  BIOMASS_Ecoli_core_w_GAM: 0.8739\nImport:\n  EX_o2_e:     -21.7995\n  EX_glc__D_e: -10.0\n  EX_nh4_e:    -4.7653\n  EX_pi_e:     -3.2149\nExport:\n  EX_h_e:      17.5309\n  EX_co2_e:    22.8098\n  EX_h2o_e:    29.1758\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.FluxVariabilitySummary","page":"Types","title":"COBREXA.FluxVariabilitySummary","text":"struct FluxVariabilitySummary\n\nStores summary information about the result of a flux variability analysis.\n\nFields\n\nbiomass_fluxes::Dict{String, Vector{Union{Nothing, Float64}}}\nexchange_fluxes::Dict{String, Vector{Union{Nothing, Float64}}}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.FluxVariabilitySummary-Tuple{}","page":"Types","title":"COBREXA.FluxVariabilitySummary","text":"FluxVariabilitySummary() -> FluxVariabilitySummary\n\n\nA default empty constructor for FluxVariabilitySummary.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.flux_variability_summary-Tuple{Tuple{Dict{String, Dict{String, Float64}}, Dict{String, Dict{String, Float64}}}}","page":"Types","title":"COBREXA.flux_variability_summary","text":"flux_variability_summary(flux_result::Tuple{Dict{String, Dict{String, Float64}}, Dict{String, Dict{String, Float64}}}; exclude_exchanges, exchange_prefixes, biomass_strings, exclude_biomass) -> FluxVariabilitySummary\n\n\nSummarize a dictionary of flux dictionaries obtained eg. from flux_variability_analysis_dict. The simplified summary representation is useful for pretty-printing and easily showing the most important results.\n\nInternally this function uses looks_like_biomass_reaction and looks_like_exchange_reaction. The corresponding keyword arguments are passed to these functions. Use this if your model has an uncommon naming of reactions.\n\nExample\n\njulia> sol = flux_variability_analysis_dict(model, Gurobi.Optimizer; bounds = objective_bounds(0.99))\njulia> flux_res = flux_variability_summary(sol)\nBiomass                     Lower bound   Upper bound\n  BIOMASS_Ecoli_core_w_GAM: 0.8652        0.8652\nExchange\n  EX_h2o_e:                 28.34         28.34\n  EX_co2_e:                 22.0377       22.0377\n  EX_o2_e:                  -22.1815      -22.1815\n  EX_h_e:                   17.3556       17.3556\n  EX_glc__D_e:              -10.0         -10.0\n  EX_nh4_e:                 -4.8448       -4.8448\n  EX_pi_e:                  -3.2149       -3.2149\n  EX_for_e:                 0.0           0.0\n  ...                       ...           ...\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Gene","page":"Types","title":"COBREXA.Gene","text":"Gene() -> Gene\nGene(id; name, notes, annotations) -> Gene\n\n\nA convenient constructor for a Gene.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Gene-2","page":"Types","title":"COBREXA.Gene","text":"mutable struct Gene\n\nFields\n\nid::String\nname::Union{Nothing, String}\nnotes::Dict{String, Vector{String}}\nannotations::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.HDF5Model","page":"Types","title":"COBREXA.HDF5Model","text":"mutable struct HDF5Model <: MetabolicModel\n\nA model that is stored in HDF5 format. The model data is never really pulled into memory, but instead mmap'ed as directly as possible into the Julia structures.  This makes reading the HDF5Models extremely fast, at the same time the (uncached) HDF5Models can be sent around efficiently among distributed nodes just like Serialized models, provided the nodes share a common storage.\n\nAll HDF5Models must have the backing disk storage. To create one, use save_h5_model or save_model with .h5 file extension. To create a temporary model that behaves like a model \"in memory\", save it to a temporary file. For related reasons, you can not use convert models to HDF5Model format, because the conversion would impliy having the model saved somewhere.\n\nFields\n\nh5::Union{Nothing, HDF5.File}\nfilename::String\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Isozyme","page":"Types","title":"COBREXA.Isozyme","text":"mutable struct Isozyme\n\nInformation about isozyme composition and activity.\n\nFields\n\ngene_product_count::Dict{String, Int64}\nkcat_forward::Float64\nkcat_reverse::Float64\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.JSONModel","page":"Types","title":"COBREXA.JSONModel","text":"struct JSONModel <: MetabolicModel\n\nA struct used to store the contents of a JSON model, i.e. a model read from a file ending with .json. These model files typically store all the model data in arrays of JSON objects (represented in Julia as vectors of dictionaries).\n\nUsually, not all of the fields of the input JSON can be easily represented when converting to other models, care should be taken to avoid losing information.\n\nDirect work with the json structure is not very efficient; the model structure therefore caches some of the internal structure in the extra fields. The single-parameter JSONModel constructor creates these caches correctly from the json. The model structure is designed as read-only, and changes in json invalidate the cache.\n\nExample\n\nmodel = load_json_model(\"some_model.json\")\nmodel.json # see the actual underlying JSON\nreactions(model) # see the list of reactions\n\nFields\n\njson::Dict{String, Any}\nrxn_index::Dict{String, Int64}\nrxns::Vector{Any}\nmet_index::Dict{String, Int64}\nmets::Vector{Any}\ngene_index::Dict{String, Int64}\ngenes::Vector{Any}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{JSONModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"convert(_::Type{JSONModel}, mm::MetabolicModel) -> MetabolicModel\n\n\nConvert any MetabolicModel to JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{JSONModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::JSONModel) -> Tuple{Vector, Vector}\n\n\nGet the bounds for reactions, assuming the information is stored in .lower_bound and .upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(model::JSONModel, gid::String) -> Dict{String, Vector{String}}\n\n\nGene annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(model::JSONModel, gid::String) -> Any\n\n\nReturn the name of gene with ID gid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::JSONModel, gid::String) -> Dict{String, Vector{String}}\n\n\nGene notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{JSONModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::JSONModel) -> Vector\n\n\nExtract gene names from a JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::JSONModel, mid::String) -> Dict{String, Vector{String}}\n\n\nMetabolite annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::JSONModel, mid::String) -> Any\n\n\nReturn the metabolite .charge\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::JSONModel, mid::String) -> Any\n\n\nReturn the metabolite .compartment\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::JSONModel, mid::String) -> Union{Nothing, Dict{String, Int64}}\n\n\nParse and return the metabolite .formula\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(model::JSONModel, mid::String) -> Any\n\n\nReturn the name of metabolite with ID mid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::JSONModel, mid::String) -> Dict{String, Vector{String}}\n\n\nMetabolite notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{JSONModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::JSONModel) -> Vector\n\n\nExtract metabolite names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{JSONModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::JSONModel) -> SparseArrays.SparseVector{_A, Int64} where _A\n\n\nCollect .objective_coefficient keys from model reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::JSONModel, rid::String) -> Dict{String, Vector{String}}\n\n\nReaction annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::JSONModel, rid::String) -> Union{Nothing, Vector{Vector{String}}}\n\n\nParses the .gene_reaction_rule from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(model::JSONModel, rid::String) -> Any\n\n\nReturn the name of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::JSONModel, rid::String) -> Dict{String, Vector{String}}\n\n\nReaction notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::JSONModel, rid::String) -> Dict{String, Float64}\n\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::JSONModel, rid::String) -> Any\n\n\nParses the .subsystem out from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{JSONModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::JSONModel) -> Vector\n\n\nExtract reaction names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{JSONModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::JSONModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nGet the stoichiometry. Assuming the information is stored in reaction object under key .metabolites.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.MATModel","page":"Types","title":"COBREXA.MATModel","text":"struct MATModel <: MetabolicModel\n\nWrapper around the models loaded in dictionaries from the MATLAB representation.\n\nFields\n\nmat::Dict{String, Any}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{MATModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"convert(_::Type{MATModel}, m::MetabolicModel) -> MetabolicModel\n\n\nConvert any metabolic model to MATModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA._mat_has_squashed_coupling-Tuple{Any}","page":"Types","title":"COBREXA._mat_has_squashed_coupling","text":"_mat_has_squashed_coupling(mat) -> Any\n\n\nGuesses whether C in the MAT file is stored in A=[S;C].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{MATModel}","page":"Types","title":"COBREXA.balance","text":"balance(m::MATModel) -> Any\n\n\nExtracts balance from the MAT model, defaulting to zeroes if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{MATModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(m::MATModel) -> Tuple{Any, Any}\n\n\nExtracts bounds from the MAT file, saved under lb and ub.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{MATModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(m::MATModel) -> Any\n\n\nExtract coupling matrix stored, in C key.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{MATModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(m::MATModel) -> Tuple{Any, Any}\n\n\nExtracts the coupling constraints. Currently, there are several accepted ways to store these in MATLAB models; this takes the constraints from vectors cl and cu.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{MATModel}","page":"Types","title":"COBREXA.genes","text":"genes(m::MATModel) -> Any\n\n\nExtracts the possible gene list from genes key.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(m::MATModel, mid::String) -> Any\n\n\nExtract metabolite charge from metCharge or metCharges.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(m::MATModel, mid::String) -> Any\n\n\nExtract metabolite compartment from metCompartment or metCompartments.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(m::MATModel, mid::String) -> Union{Nothing, Dict{String, Int64}}\n\n\nExtract metabolite formula from key metFormula or metFormulas.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(m::MATModel, mid::String) -> Any\n\n\nExtract metabolite name from metNames.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{MATModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(m::MATModel) -> Vector{String}\n\n\nExtracts metabolite names from mets key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{MATModel}","page":"Types","title":"COBREXA.objective","text":"objective(m::MATModel) -> Any\n\n\nExtracts the objective from the MAT model (defaults to zeroes).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{MATModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(m::MATModel, rid::String) -> Union{Nothing, Vector{Vector{String}}}\n\n\nExtracts the associations from grRules key, if present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{MATModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(m::MATModel, rid::String) -> Any\n\n\nExtract reaction name from rxnNames.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{MATModel, Any}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(m::MATModel, ridx) -> Dict{String, Float64}\n\n\nReturn the stoichiometry of reaction at index ridx.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{MATModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(m::MATModel, rid::String) -> Dict{String, Float64}\n\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{MATModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(m::MATModel) -> Vector{String}\n\n\nExtracts reaction names from rxns key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{MATModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(m::MATModel) -> Any\n\n\nExtract the stoichiometry matrix, stored under key S.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.balance","text":"balance(a::MetabolicModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nGet the sparse balance vector of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(a::MetabolicModel) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nGet the lower and upper solution bounds of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(a::MetabolicModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nGet a matrix of coupling constraint definitions of a model. By default, there is no coupling in the models.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::MetabolicModel) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nGet the lower and upper bounds for each coupling bound in a model, as specified by coupling. By default, the model does not have any coupling bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.fluxes-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.fluxes","text":"fluxes(a::MetabolicModel) -> Vector{String}\n\n\nIn some models, the reactions that correspond to the columns of stoichiometry matrix do not fully represent the semantic contents of the model; for example, fluxes may be split into forward and reverse reactions, reactions catalyzed by distinct enzymes, etc. Together with reaction_flux (and n_fluxes) this specifies how the flux is decomposed into individual reactions.\n\nBy default (and in most models), fluxes and reactions perfectly correspond.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(a::MetabolicModel, gene_id::String) -> Any\n\n\nReturn standardized names that identify the corresponding gene or product. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"PDB\" => [\"PROT01\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(model::MetabolicModel, gid::String) -> Any\n\n\nReturn the name of gene with ID gid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::MetabolicModel, gene_id::String) -> Any\n\n\nReturn the notes associated with the gene gene_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.genes","text":"genes(a::MetabolicModel) -> Vector{String}\n\n\nReturn identifiers of all genes contained in the model. By default, there are no genes.\n\nIn SBML, these are usually called \"gene products\" but we write genes for simplicity.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(a::MetabolicModel, metabolite_id::String) -> Any\n\n\nReturn standardized names that may help to reliably identify the metabolite. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"ChEMBL\" => [\"123\"] or \"PubChem\" => [\"CID123\", \"CID654645645\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::MetabolicModel, metabolite_id::String) -> Any\n\n\nReturn the charge associated with metabolite metabolite_id in model. Returns nothing if charge not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::MetabolicModel, metabolite_id::String) -> Any\n\n\nReturn the compartment of metabolite metabolite_id in model if it is assigned. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::MetabolicModel, metabolite_id::String) -> Any\n\n\nReturn the formula of metabolite metabolite_id in model. Return nothing in case the formula is not known or irrelevant.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(model::MetabolicModel, mid::String) -> Any\n\n\nReturn the name of metabolite with ID mid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::MetabolicModel, metabolite_id::String) -> Any\n\n\nReturn the notes associated with metabolite reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(a::MetabolicModel) -> Vector{String}\n\n\nReturn a vector of metabolite identifiers in a model. The vector precisely corresponds to the rows in stoichiometry matrix.\n\nAs with reactionss, some metabolites in models may be virtual, representing purely technical equality constraints.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::MetabolicModel) -> Int64\n\n\nGet the number of coupling constraints in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(a::MetabolicModel) -> Int64\n\n\nReturn the number of genes in the model (as returned by genes). If you just need the number of the genes, this may be much more efficient than calling genes and measuring the array.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(a::MetabolicModel) -> Int64\n\n\nGet the number of metabolites in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(a::MetabolicModel) -> Int64\n\n\nGet the number of reactions in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.objective","text":"objective(a::MetabolicModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nGet the objective vector of the model. Analysis functions, such as flux_balance_analysis, are supposed to maximize dot(objective, x) where x is a feasible solution of the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.precache!-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.precache!","text":"precache!(a::MetabolicModel)\n\n\nDo whatever is feasible to get the model into a state that can be read from as-quickly-as-possible. This may include e.g. generating helper index structures and loading delayed parts of the model from disk. The model should be modified \"transparently\" in-place. Analysis functions call this right before applying modifications or converting the model to the optimization model using make_optimization_model; usually on the same machine where the optimizers (and, generally, the core analysis algorithms) will run. The calls are done in a good hope that the performance will be improved.\n\nBy default, it should be safe to do nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(a::MetabolicModel, reaction_id::String) -> Any\n\n\nReturn standardized names that may help identifying the reaction. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"Reactome\" => [\"reactomeID123\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(a::MetabolicModel) -> Any\n\n\nRetrieve a sparse matrix that describes the correspondence of a solution of the linear system to the fluxes (see fluxes for rationale). Returns a sparse matrix of size (n_reactions(a), n_fluxes(a)). For most models, this is an identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(a::MetabolicModel, reaction_id::String) -> Any\n\n\nReturns the sets of genes that need to be present so that the reaction can work (technically, a DNF on gene availability, with positive atoms only).\n\nFor simplicity, nothing may be returned, meaning that the reaction always takes place. (in DNF, that would be equivalent to returning [[]].)\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(model::MetabolicModel, rid::String) -> Any\n\n\nReturn the name of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::MetabolicModel, reaction_id::String) -> Any\n\n\nReturn the notes associated with reaction reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(m::MetabolicModel, rid::String) -> Any\n\n\nReturn the stoichiometry of reaction with ID rid in the model. The dictionary maps the metabolite IDs to their stoichiometric coefficients.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::MetabolicModel, reaction_id::String) -> Any\n\n\nReturn the subsystem of reaction reaction_id in model if it is assigned. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(a::MetabolicModel) -> Vector{String}\n\n\nReturn a vector of reaction identifiers in a model. The vector precisely corresponds to the columns in stoichiometry matrix.\n\nFor technical reasons, the \"reactions\" may sometimes not be true reactions but various virtual and helper pseudo-reactions that are used in the metabolic modeling, such as metabolite exchanges, separate forward and reverse reactions, supplies of enzymatic and genetic material and virtual cell volume, etc. To simplify the view of the model contents use reaction_flux.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(a::MetabolicModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nGet the sparse stoichiometry matrix of a model. A feasible solution x of a model m is defined as satisfying the equations:\n\nstoichiometry(m) * x .== balance(m)\nx .>= lbs\ny .<= ubs\n`(lbs, ubs) == bounds(m)\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Metabolite","page":"Types","title":"COBREXA.Metabolite","text":"Metabolite() -> Metabolite\nMetabolite(id; name, formula, charge, compartment, notes, annotations) -> Metabolite\n\n\nA constructor for Metabolites.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Metabolite-2","page":"Types","title":"COBREXA.Metabolite","text":"mutable struct Metabolite\n\nFields\n\nid::String\nname::Union{Nothing, String}\nformula::Union{Nothing, String}\ncharge::Union{Nothing, Int64}\ncompartment::Union{Nothing, String}\nnotes::Dict{String, Vector{String}}\nannotations::Dict{String, Vector{String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.balance-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.balance","text":"balance(model::ModelWrapper)\n\nEvaluates balance on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::ModelWrapper)\n\nEvaluates bounds on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.coupling","text":"coupling(model::ModelWrapper)\n\nEvaluates coupling on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(model::ModelWrapper)\n\nEvaluates coupling_bounds on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.fluxes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.fluxes","text":"fluxes(model::ModelWrapper)\n\nEvaluates fluxes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(model::ModelWrapper, gid::String)\n\nEvaluates gene_annotations on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::ModelWrapper, gid::String)\n\nEvaluates gene_notes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.genes","text":"genes(model::ModelWrapper)\n\nEvaluates genes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_annotations on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_charge on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_compartment on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_formula on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_notes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::ModelWrapper)\n\nEvaluates metabolites on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(model::ModelWrapper)\n\nEvaluates n_coupling_constraints on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_fluxes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.n_fluxes","text":"n_fluxes(model::ModelWrapper)\n\nEvaluates n_fluxes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::ModelWrapper)\n\nEvaluates n_genes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.objective","text":"objective(model::ModelWrapper)\n\nEvaluates objective on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.precache!-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.precache!","text":"precache!(model::ModelWrapper)\n\nEvaluates precache! on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::ModelWrapper, rid::String)\n\nEvaluates reaction_annotations on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(model::ModelWrapper)\n\nEvaluates reaction_flux on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::ModelWrapper, rid::String)\n\nEvaluates reaction_gene_association on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::ModelWrapper, rid::String)\n\nEvaluates reaction_notes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::ModelWrapper, rid::String)\n\nEvaluates reaction_stoichiometry on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::ModelWrapper, rid::String)\n\nEvaluates reaction_subsystem on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::ModelWrapper)\n\nEvaluates reactions on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::ModelWrapper)\n\nEvaluates stoichiometry on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.unwrap_model-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.unwrap_model","text":"unwrap_model(a::ModelWrapper) -> Any\n\n\nA simple helper to pick the single w\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Reaction","page":"Types","title":"COBREXA.Reaction","text":"Reaction(id::String, metabolites) -> Reaction\nReaction(id::String, metabolites, dir; default_bound) -> Reaction\n\n\nConvenience constructor for Reaction. The reaction equation is specified using metabolites, which is a dictionary mapping metabolite ids to stoichiometric coefficients. The direcion of the reaction is set through dir which can take :bidirectional, :forward, and :reverse as values. Finally, the default_bound is the value taken to mean infinity in the context of constraint based models, often this is set to a very high flux value like 1000.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Reaction-2","page":"Types","title":"COBREXA.Reaction","text":"Reaction() -> Reaction\nReaction(id; name, metabolites, lb, ub, grr, subsystem, notes, annotations, objective_coefficient) -> Reaction\n\n\nA constructor for Reaction that only takes a reaction id and assigns default/uninformative values to all the fields that are not explicitely assigned.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Reaction-3","page":"Types","title":"COBREXA.Reaction","text":"mutable struct Reaction\n\nA structure for representing a single reaction in a StandardModel.\n\nFields\n\nid::String\nname::Union{Nothing, String}\nmetabolites::Dict{String, Float64}\nlb::Float64\nub::Float64\ngrr::Union{Nothing, Vector{Vector{String}}}\nsubsystem::Union{Nothing, String}\nnotes::Dict{String, Vector{String}}\nannotations::Dict{String, Vector{String}}\nobjective_coefficient::Float64\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.ReactionStatus","page":"Types","title":"COBREXA.ReactionStatus","text":"mutable struct ReactionStatus\n\nUsed for concise reporting of modeling results.\n\nFields\n\nalready_present::Bool\nindex::Int64\ninfo::String\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.SBMLModel","page":"Types","title":"COBREXA.SBMLModel","text":"struct SBMLModel <: MetabolicModel\n\nThin wrapper around the model from SBML.jl library. Allows easy conversion from SBML to any other model format.\n\nFields\n\nsbml::SBML.Model\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{SBMLModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"convert(_::Type{SBMLModel}, mm::MetabolicModel) -> MetabolicModel\n\n\nConvert any metabolic model to SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{SBMLModel}","page":"Types","title":"COBREXA.balance","text":"balance(model::SBMLModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nBalance vector of a SBMLModel. This is always zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{SBMLModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::SBMLModel) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nGet the lower and upper flux bounds of model SBMLModel. Throws DomainError in case if the SBML contains mismatching units.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(model::SBMLModel, gid::String) -> Union{Nothing, String}\n\n\nReturn the name of gene with ID gid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{SBMLModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::SBMLModel) -> Vector{String}\n\n\nGet genes of a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::SBMLModel, mid::String) -> Union{Nothing, Int64}\n\n\nGet charge of a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::SBMLModel, mid::String) -> Union{Nothing, Dict{String, Int64}}\n\n\nGet MetaboliteFormula from a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(model::SBMLModel, mid::String) -> Union{Nothing, String}\n\n\nReturn the name of metabolite with ID mid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{SBMLModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::SBMLModel) -> Vector{String}\n\n\nGet metabolites from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{SBMLModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::SBMLModel) -> Int64\n\n\nGet number of genes in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{SBMLModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(model::SBMLModel) -> Int64\n\n\nEfficient counting of metabolites in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{SBMLModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::SBMLModel) -> Int64\n\n\nEfficient counting of reactions in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{SBMLModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::SBMLModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nObjective of the SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::SBMLModel, rid::String) -> Union{Nothing, Vector{Vector{String}}}\n\n\nRetrieve the GeneAssociation from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(model::SBMLModel, rid::String) -> Union{Nothing, String}\n\n\nReturn the name of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(m::SBMLModel, rid::String) -> Dict{String, Float64}\n\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{SBMLModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::SBMLModel) -> Vector{String}\n\n\nGet reactions from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{SBMLModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::SBMLModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nRecreate the stoichiometry matrix from the SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Serialized","page":"Types","title":"COBREXA.Serialized","text":"mutable struct Serialized{M} <: ModelWrapper\n\nA meta-model that represents a model that is serialized on the disk. The internal model will be loaded on-demand by using any accessor, or by calling precache! directly.\n\nFields\n\nm::Union{Nothing, M} where M\nfilename::String\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.precache!-Tuple{Serialized}","page":"Types","title":"COBREXA.precache!","text":"precache!(model::Serialized)\n\n\nLoad the Serialized model from disk in case it's not alreadly loaded.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.unwrap_model-Tuple{Serialized}","page":"Types","title":"COBREXA.unwrap_model","text":"unwrap_model(m::Serialized) -> Union{Nothing, M} where M\n\n\nUnwrap the serialized model (precaching it transparently).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.StandardModel","page":"Types","title":"COBREXA.StandardModel","text":"mutable struct StandardModel <: MetabolicModel\n\nStandardModel is used to store a constraint based metabolic model with meta-information.  Meta-information is defined as annotation details, which include gene-reaction-rules, formulas, etc.\n\nThis model type seeks to keep as much meta-information as possible, as opposed to CoreModel and CoreModelCoupled, which keep the bare neccessities only. When merging models and keeping meta-information is important, use this as the model type.  If meta-information is not important, use the more efficient core model types.  See CoreModel and CoreModelCoupled for comparison.\n\nIn this model, reactions, metabolites, and genes are stored in ordered dictionaries indexed by each struct's id field.  For example, model.reactions[\"rxn1_id\"] returns a Reaction where the field id equals \"rxn1_id\".  This makes adding and removing reactions efficient.\n\nNote that the stoichiometric matrix (or any other core data, e.g. flux bounds) is not stored directly as in CoreModel.  When this model type is used in analysis functions, these core data structures are built from scratch each time an analysis function is called.  This can cause performance issues if you run many small analysis functions sequentially.  Consider using the core model types if performance is critical.\n\nSee also: Reaction, Metabolite, Gene\n\nExample\n\nmodel = load_model(StandardModel, \"my_model.json\")\nkeys(model.reactions)\n\nFields\n\nid::String\nreactions::OrderedCollections.OrderedDict{String, Reaction}\nmetabolites::OrderedCollections.OrderedDict{String, Metabolite}\ngenes::OrderedCollections.OrderedDict{String, Gene}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{StandardModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"convert(_::Type{StandardModel}, model::MetabolicModel) -> MetabolicModel\n\n\nConvert any MetabolicModel into a StandardModel. Note, some data loss may occur since only the generic interface is used during the conversion process.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{StandardModel}","page":"Types","title":"COBREXA.balance","text":"balance(model::StandardModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nReturn the balance of the linear problem, i.e. b in Sv = 0 where S is the stoichiometric matrix and v is the flux vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{StandardModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::StandardModel) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nReturn the lower and upper bounds, respectively, for reactions in model. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(model::StandardModel, id::String) -> Dict{String, Vector{String}}\n\n\nReturn the annotation associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(m::StandardModel, gid::String) -> Union{Nothing, String}\n\n\nReturn the name of gene with ID id.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::StandardModel, id::String) -> Dict{String, Vector{String}}\n\n\nReturn the notes associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{StandardModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::StandardModel) -> Vector{String}\n\n\nReturn a vector of gene id strings in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.lower_bounds-Tuple{StandardModel}","page":"Types","title":"COBREXA.lower_bounds","text":"lower_bounds(model::StandardModel) -> Vector{Float64}\n\n\nReturn the lower bounds for all reactions in model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::StandardModel, id::String) -> Dict{String, Vector{String}}\n\n\nReturn the annotation associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::StandardModel, id::String) -> Union{Nothing, Int64}\n\n\nReturn the charge associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::StandardModel, id::String) -> Union{Nothing, String}\n\n\nReturn compartment associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::StandardModel, id::String) -> Union{Nothing, Dict{String, Int64}}\n\n\nReturn the formula of reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(m::StandardModel, mid::String) -> Union{Nothing, String}\n\n\nReturn the name of metabolite with ID id.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::StandardModel, id::String) -> Dict{String, Vector{String}}\n\n\nReturn the notes associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{StandardModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::StandardModel) -> Vector{String}\n\n\nReturn a vector of metabolite id strings contained in model. The order of metabolite strings returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{StandardModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::StandardModel) -> Int64\n\n\nReturn the number of genes in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{StandardModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(model::StandardModel) -> Int64\n\n\nReturn the number of metabolites in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{StandardModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::StandardModel) -> Int64\n\n\nReturn the number of reactions contained in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{StandardModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::StandardModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nReturn sparse objective vector for model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::StandardModel, id::String) -> Dict{String, Vector{String}}\n\n\nReturn the annotation associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::StandardModel, id::String) -> Union{Nothing, Vector{Vector{String}}}\n\n\nReturn the gene reaction rule in string format for reaction with id in model. Return nothing if not available.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(m::StandardModel, rid::String) -> Union{Nothing, String}\n\n\nReturn the name of reaction with ID id.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::StandardModel, id::String) -> Dict{String, Vector{String}}\n\n\nReturn the notes associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(m::StandardModel, rid::String) -> Dict{String, Float64}\n\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::StandardModel, id::String) -> Union{Nothing, String}\n\n\nReturn the subsystem associated with reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{StandardModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::StandardModel) -> Vector{String}\n\n\nReturn a vector of reaction id strings contained in model. The order of reaction ids returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{StandardModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::StandardModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nReturn the stoichiometric matrix associated with model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.upper_bounds-Tuple{StandardModel}","page":"Types","title":"COBREXA.upper_bounds","text":"upper_bounds(model::StandardModel) -> Vector{Float64}\n\n\nReturn the upper bounds for all reactions in model in sparse format. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#Model-type-wrappers","page":"Types","title":"Model type wrappers","text":"","category":"section"},{"location":"functions/types/","page":"Types","title":"Types","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", \"wrappers\", file), readdir(\"../src/base/types/wrappers\"))","category":"page"},{"location":"functions/types/#COBREXA.GeckoModel","page":"Types","title":"COBREXA.GeckoModel","text":"struct GeckoModel <: ModelWrapper\n\nA model with complex enzyme concentration and capacity bounds, as described in SÃ¡nchez, BenjamÃ­n J., et al. \"Improving the phenotype predictions of a yeast genome-scale metabolic model by incorporating enzymatic constraints.\" Molecular systems biology 13.8 (2017): 935.\n\nUse make_gecko_model or with_gecko to construct this kind of model.\n\nThe model wraps another \"internal\" model, and adds following modifications:\n\nenzymatic reactions with known enzyme information are split into multiple forward and reverse variants for each isozyme,\nreaction coupling is added to ensure the groups of isozyme reactions obey the global reaction flux bounds from the original model,\ngene concentrations specified by each reaction and its gene product stoichiometry, can constrained by the user to reflect measurements, such as from mass spectrometry,\nadditional coupling is added to simulate total masses of different proteins grouped by type (e.g., membrane-bound and free-floating proteins), which can be again constrained by the user (this is slightly generalized from original GECKO algorithm, which only considers a single group of indiscernible proteins).\n\nThe structure contains fields columns that describe the contents of the stoichiometry matrix columns, coupling_row_reaction, coupling_row_gene_product and coupling_row_mass_group that describe correspondence of the coupling rows to original model and determine the coupling bounds (note: the coupling for gene product is actually added to stoichiometry, not in coupling), and inner, which is the original wrapped model. The objective of the model includes also the extra columns for individual genes, as held by coupling_row_gene_product.\n\nImplementation exposes the split reactions (available as reactions(model)), but retains the original \"simple\" reactions accessible by fluxes. The related constraints are implemented using coupling and coupling_bounds.\n\nFields\n\nobjective::SparseArrays.SparseVector{Float64, Int64}\ncolumns::Vector{COBREXA._gecko_reaction_column}\ncoupling_row_reaction::Vector{Int64}\ncoupling_row_gene_product::Vector{Tuple{Int64, Tuple{Float64, Float64}}}\ncoupling_row_mass_group::Vector{COBREXA._gecko_capacity}\ninner::MetabolicModel\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._gecko_capacity","page":"Types","title":"COBREXA._gecko_capacity","text":"struct _gecko_capacity\n\nA helper struct that contains the gene product capacity terms organized by the grouping type, e.g. metabolic or membrane groups etc.\n\nFields\n\ngroup_id::String\ngene_product_idxs::Vector{Int64}\ngene_product_molar_masses::Vector{Float64}\ngroup_upper_bound::Float64\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._gecko_reaction_column","page":"Types","title":"COBREXA._gecko_reaction_column","text":"struct _gecko_reaction_column\n\nA helper type for describing the contents of GeckoModels.\n\nFields\n\nreaction_idx::Int64\nisozyme_idx::Int64\ndirection::Int64\nreaction_coupling_row::Int64\nlb::Float64\nub::Float64\ngene_product_coupling::Vector{Tuple{Int64, Float64}}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.balance-Tuple{GeckoModel}","page":"Types","title":"COBREXA.balance","text":"balance(model::GeckoModel) -> Any\n\n\nReturn the balance of the reactions in the inner model, concatenated with a vector of zeros representing the enzyme balance of a GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{GeckoModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::GeckoModel) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nReturn variable bounds for GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{GeckoModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(model::GeckoModel) -> Any\n\n\nReturn the coupling of GeckoModel. That combines the coupling of the wrapped model, coupling for split (arm) reactions, and the coupling for the total enzyme capacity.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{GeckoModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(model::GeckoModel) -> Tuple{Any, Any}\n\n\nThe coupling bounds for GeckoModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{GeckoModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::GeckoModel) -> Any\n\n\nReturn the gene ids of genes that have enzymatic constraints associated with them.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{GeckoModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::GeckoModel) -> Any\n\n\nReturn the ids of all metabolites, both real and pseudo, for a GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(model::GeckoModel) -> Any\n\n\nCount the coupling constraints in GeckoModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::GeckoModel) -> Int64\n\n\nReturn the number of genes that have enzymatic constraints associated with them.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(model::GeckoModel) -> Any\n\n\nReturn the number of metabolites, both real and pseudo, for a GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::GeckoModel) -> Int64\n\n\nReturns the number of all irreversible reactions in model as well as the number of gene products that take part in enzymatic reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{GeckoModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::GeckoModel) -> SparseArrays.SparseVector{Float64, Int64}\n\n\nReturn the objective of the GeckoModel. Note, the objective is with respect to the internal variables, i.e. reactions(model), which are the unidirectional reactions and the genes involved in enzymatic reactions that have kinetic data.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{GeckoModel}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(model::GeckoModel) -> Any\n\n\nGet the mapping of the reaction rates in GeckoModel to the original fluxes in the wrapped model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{GeckoModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::GeckoModel) -> Any\n\n\nReturns the internal reactions in a GeckoModel (these may be split to forward- and reverse-only parts with different isozyme indexes; reactions IDs are mangled accordingly with suffixes).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{GeckoModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::GeckoModel) -> Any\n\n\nReturn a stoichiometry of the GeckoModel. The enzymatic reactions are split into unidirectional forward and reverse ones, each of which may have multiple variants per isozyme.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.SMomentModel","page":"Types","title":"COBREXA.SMomentModel","text":"struct SMomentModel <: ModelWrapper\n\nAn enzyme-capacity-constrained model using sMOMENT algorithm, as described by Bekiaris, Pavlos Stephanos, and Steffen Klamt, \"Automatic construction of metabolic models with enzyme constraints\" BMC bioinformatics, 2020.\n\nUse make_smoment_model or with_smoment to construct the models.\n\nThe model is constructed as follows:\n\nstoichiometry of the original model is retained as much as possible, but enzymatic reations are split into forward and reverse parts (marked by a suffix like ...#forward and ...#reverse),\ncoupling is added to simulate a virtual metabolite \"enzyme capacity\", which is consumed by all enzymatic reactions at a rate given by enzyme mass divided by the corresponding kcat,\nthe total consumption of the enzyme capacity is constrained to a fixed maximum.\n\nThe SMomentModel structure contains a worked-out representation of the optimization problem atop a wrapped MetabolicModel, in particular the separation of certain reactions into unidirectional forward and reverse parts, an \"enzyme capacity\" required for each reaction, and the value of the maximum capacity constraint. Original coupling in the inner model is retained.\n\nIn the structure, the field columns describes the correspondence of stoichiometry columns to the stoichiometry and data of the internal wrapped model, and total_enzyme_capacity is the total bound on the enzyme capacity consumption as specified in sMOMENT algorithm.\n\nThis implementation allows easy access to fluxes from the split reactions (available in reactions(model)), while the original \"simple\" reactions from the wrapped model are retained as fluxes. All additional constraints are implemented using coupling and coupling_bounds.\n\nFields\n\ncolumns::Vector{COBREXA._smoment_column}\ntotal_enzyme_capacity::Float64\ninner::MetabolicModel\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._smoment_column","page":"Types","title":"COBREXA._smoment_column","text":"struct _smoment_column\n\nA helper type that describes the contents of SMomentModels.\n\nFields\n\nreaction_idx::Int64\ndirection::Int64\nlb::Float64\nub::Float64\ncapacity_required::Float64\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.bounds-Tuple{SMomentModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::SMomentModel) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nReturn the variable bounds for SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{SMomentModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(model::SMomentModel) -> Any\n\n\nReturn the coupling of SMomentModel. That combines the coupling of the wrapped model, coupling for split reactions, and the coupling for the total enzyme capacity.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{SMomentModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(model::SMomentModel) -> Tuple{Any, Any}\n\n\nThe coupling bounds for SMomentModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{SMomentModel}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(model::SMomentModel) -> Any\n\n\nCount the coupling constraints in SMomentModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{SMomentModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::SMomentModel) -> Int64\n\n\nThe number of reactions (including split ones) in SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{SMomentModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::SMomentModel) -> Any\n\n\nReconstruct an objective of the SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{SMomentModel}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(model::SMomentModel) -> Any\n\n\nGet the mapping of the reaction rates in SMomentModel to the original fluxes in the wrapped model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{SMomentModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::SMomentModel) -> Vector\n\n\nReturns the internal reactions in a SMomentModel (these may be split to forward- and reverse-only parts; reactions IDs are mangled accordingly with suffixes).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{SMomentModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::SMomentModel) -> Any\n\n\nReturn a stoichiometry of the SMomentModel. The enzymatic reactions are split into unidirectional forward and reverse ones.\n\n\n\n\n\n","category":"method"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/16_hit_and_run.jl\"","category":"page"},{"location":"examples/16_hit_and_run/#Hit-and-run-sampling","page":"Hit and run sampling","title":"Hit and run sampling","text":"","category":"section"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"Sampling the feasible space of the model allows you to gain a realistic insight into the distribution of the flow and its probabilistic nature, often better describing the variance and correlations of the possible fluxes better (but more approximately) than e.g. flux variability analysis.","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"COBREXA supports a variant of hit-and-run sampling adjusted to the complexities of metabolic models; in particular, it implements a version where the next sample (and indirectly, the next run direction) is generated as an affine combination of the samples in the current sample set. This gives a result similar to the artificially centered hit-and-run sampling, with a slightly (unsubstantially) different biases in the generation of the next hits.","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"As always, we start by loading everything that is needed:","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"The sampling procedure requires a set of \"seed\" points that will form the basis for the first iteration of runs. This is commonly called a warm-up. You can generate these points manually with any method of choice, or you can use the COBREXA implementation of warmup that uses the extreme edges of the polytope, similarly to the way used by flux variability analysis:","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"warmup_points = warmup_from_variability(model, GLPK.Optimizer)","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"This generates a matrix of fluxes, where each column is one sample point, and rows correspond to the reactions in the model.","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"With this, starting the sampling procedure is straightforward:","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"samples = affine_hit_and_run(model, warmup_points)","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"As seen above, the result again contains 1 sample per column, with reactions in the same order with rows as before. To get a different sample, you can tune the parameters the function. sample_iters allows you to specify the iterations at which you want the current sample to be collected and reported â€“ by default, that is done 5 times on each 100th iteration. In the example below, we catch the samples in 10 iterations right after the 200th iteration passed.  Similarly, to avoid possible degeneracy, you can choose to run more hit-and-run batch chains than 1, using the chains parameters. The total number of points collected is the number of points in warmup times the number of sample-collecting iterations times the number of chains.","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"samples = affine_hit_and_run(model, warmup_points, sample_iters = 201:210, chains = 2)","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"tip: Parallelization\nBoth procedures used for sampling in this example (warmup_from_variability, affine_hit_and_run) can be effectively parallelized by adding workers= parameter, as summarized in the documentation. Due to the nature of the algorithm, parallelization of the sampling requires at least 1 chain per worker.","category":"page"},{"location":"examples/16_hit_and_run/#Visualizing-the-samples","page":"Hit and run sampling","title":"Visualizing the samples","text":"","category":"section"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"Samples can be displayed very efficiently in a scatterplot or a density plot, which naturally show correlations and distributions of the fluxes:","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"using CairoMakie\n\no2, co2 = indexin([\"R_EX_o2_e\", \"R_EX_co2_e\"], reactions(model))\n\nscatter(\n    samples[o2, :],\n    samples[co2, :];\n    axis = (; xlabel = \"Oxygen exchange\", ylabel = \"Carbon dioxide exchange\"),\n)","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"","category":"page"},{"location":"examples/16_hit_and_run/","page":"Hit and run sampling","title":"Hit and run sampling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"concepts/3_custom_models/#Working-with-custom-models","page":"Working with custom models","title":"Working with custom models","text":"","category":"section"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"It may happen that the intuitive representation of your data does not really match what is supported by a given COBRA package. COBREXA.jl attempts to avoid this problem by providing a flexible framework for containing any data structure that can, somehow, represent the constraint-based model.","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"The task of having such a polymorphic model definition can be split into 2 separate concerns:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"How to allow the analysis functions to gather the required information from any user-specified model data structure?\nHow to make the reconstruction functions (i.e., reaction or gene deletions) work properly on any data structure?","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"To solve the first concern, COBREXA.jl specifies a set of generic accessors that work over the abstract type MetabolicModel. To use your data structure in a model, you just make it a subtype of MetabolicModel and overload the required accessors. The accessors are functions that extract some relevant information, such as stoichiometry and bounds, returning a fixed simple data type that can be further used by COBREXA.  You may see a complete list of accessors here.","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"A good solution to the second concern is a slightly more involved, as writing generic data modifiers is notoriously hard. Still, there is support for easily making small changes to the model using the modifications system, with functions such as with_added_reactions and with_changed_bound.","category":"page"},{"location":"concepts/3_custom_models/#Writing-the-generic-accessors","page":"Working with custom models","title":"Writing the generic accessors","text":"","category":"section"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"Let's write a data structure that represents a very small model that contains N metabolites that are converted in a circle through N linear, coupled reactions. (E.g., for N=3, we would have a conversion of metabolites A, B and C ordered as A â†’ B â†’ C â†’ A.) This may be useful for testing purposes; we will use it for a simple demonstration.","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"The whole model can thus be specified with a single integer N that represents the length of the reaction cycle:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"struct CircularModel <: MetabolicModel\n    size::Int\nend","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"First, define the reactions and metabolites:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"COBREXA.n_reactions(m::CircularModel) = m.size\nCOBREXA.n_metabolites(m::CircularModel) = m.size\n\nCOBREXA.reactions(m::CircularModel) = [\"rxn$i\" for i in 1:n_reactions(m)]\nCOBREXA.metabolites(m::CircularModel) = [\"met$i\" for i in 1:n_metabolites(m)]","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"It is useful to re-use the already defined functions, as that improves the code maintainability.","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"We can continue with the actual linear model properties:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"function COBREXA.objective(m::CircularModel)\n    c = spzeros(n_reactions(m))\n    c[1] = 1 #optimize the first reaction\n    return c\nend\n\nCOBREXA.bounds(m::CircularModel) = (\n    zeros(n_reactions(m)), # lower bounds\n    ones(n_reactions(m)), # upper bounds\n)\n\nfunction COBREXA.stoichiometry(m::CircularModel)\n    nr = n_reactions(m)\n    stoi(i,j) =\n        i == j ? 1.0 :\n        (i % nr + 1) == j  ? -1.0 :\n        0.0\n\n    sparse([stoi(i,j) for i in 1:nr, j in 1:nr])\nend","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"You may check that the result now works just as with CoreModel and StandardModel:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"julia> m = CircularModel(5)\nMetabolic model of type CircularModel\n\n  1.0  -1.0    â‹…     â‹…     â‹…\n   â‹…    1.0  -1.0    â‹…     â‹…\n   â‹…     â‹…    1.0  -1.0    â‹…\n   â‹…     â‹…     â‹…    1.0  -1.0\n -1.0    â‹…     â‹…     â‹…    1.0\nNumber of reactions: 5\nNumber of metabolites: 5\n","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"This interface is sufficient to run most of the basic analyses, especially the flux balance finding ones:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"julia> flux_balance_analysis_dict(m, Tulip.Optimizer)\nDict{String, Float64} with 5 entries:\n  \"rxn5\" => 1.0\n  \"rxn2\" => 1.0\n  \"rxn1\" => 1.0\n  \"rxn3\" => 1.0\n  \"rxn4\" => 1.0\n","category":"page"},{"location":"concepts/3_custom_models/#Writing-generic-model-modifications","page":"Working with custom models","title":"Writing generic model modifications","text":"","category":"section"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"The custom model structure can also be made compatible with many of the existing variant-generating functions and analysis modifiers.","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"The functions prepared for use as \"variants\" in screen, usually prefixed by with_, have their generic variants that only call simpler, overloadable functions for each specific model. This choice is based on the overloading dispatch system of Julia. For example,with_removed_metabolites is implemented very generically by reducing the problem to some specific remove_metabolites functions selected by the dispatch, as follows:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"with_removed_metabolites(args...; kwargs...) =\n    m -> remove_metabolites(m, args...; kwargs...)","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"To be able to use with_removed_metabolites in your model, we can just overload the actual inner function. For the simple circular model, the modification might as well look like this:","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"COBREXA.remove_metabolites(m::CircularModel, n::Int) =\n    return CircularModel(m.size - n)","category":"page"},{"location":"concepts/3_custom_models/","page":"Working with custom models","title":"Working with custom models","text":"danger: Functions that generate model variants must be pure\nNotice that the function is \"pure\", i.e., does not make any in-place modifications to the original model structure. That property is required for screen and other functions to properly and predictably apply the modifications to the model. To expose potential in-place modifications to your codebase, you should instead overload the \"bang\" counterpart of remove metabolites, called remove_metabolites!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<br>\n<div align=\"center\">\n    <img class=\"docs-light-only\" src=\"assets/header.svg?maxAge=0\" width=\"80%\">\n    <img class=\"docs-dark-only\" src=\"assets/header-dark.svg?maxAge=0\" width=\"80%\">\n</div>\n<br>","category":"page"},{"location":"#Constraint-Based-Reconstruction-and-EXascale-Analysis","page":"Home","title":"Constraint-Based Reconstruction and EXascale Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository Tests Coverage How to contribute?\n(Image: GitHub) (Image: CI) (Image: codecov) (Image: contrib)","category":"page"},{"location":"","page":"Home","title":"Home","text":"COBREXA is a toolkit for working with large constraint-based metabolic models, and running very large numbers of analysis tasks on these models in parallel. Its main purpose is to make the methods of Constraint-based Reconstruction and Analysis (COBRA) scale to problem sizes that require the use of huge computer clusters and HPC environments, which allows them to be realistically applied to pre-exascale-sized models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package, you will find the usual COBRA-like functions that interface to underlying linear programming solvers. We use JuMP.jl as the unified interface for many solvers; you can plug in whichever compatible solver you want, including the popular Tulip.jl, GLPK.jl, OSQP.jl, and Gurobi.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n<img style=\"width:300px;margin:10px;border-offset:15px;border: 1px solid #eee;border-radius: 50%;padding: 10px;-webkit-border-radius: 50%;-moz-border-radius: 50%;\" src=\"https://gitlab.lcsb.uni.lu/lcsb-biocore/COBREXA.jl/-/jobs/artifacts/master/raw/output.gif?job=gource\" alt=\"history\"><br>\nDevelopment history of COBREXA.jl.\n</div>","category":"page"},{"location":"#Quick-start-guide","page":"Home","title":"Quick start guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A dedicated quick start guide is available for quickly trying out the analysis with COBREXA.jl.","category":"page"},{"location":"#Example-notebooks-and-workflows","page":"Home","title":"Example notebooks and workflows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed example listing is available here. All examples are also avaialble as JuPyteR notebooks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"examples\", join=true))\nDepth = 1","category":"page"},{"location":"#Core-concept-documentation","page":"Home","title":"Core concept documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed concept guide listing is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"concepts\", join=true))\nDepth = 1","category":"page"},{"location":"#Functions-and-types-API-reference","page":"Home","title":"Functions and types API reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed table of contents of the API documentation is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"functions\", join=true))\nDepth = 1","category":"page"},{"location":"#Contribution-guide","page":"Home","title":"Contribution guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you wish to contribute code, patches or improvements to COBREXA.jl, please follow the contribution guidelines and hints.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"COBREXA.jl is developed at the Luxembourg Centre for Systems Biomedicine of the University of Luxembourg (uni.lu/lcsb), cooperating with the Institute for Quantitative and Theoretical Biology at the Heinrich Heine University in DÃ¼sseldorf (qtb.hhu.de).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The development was supported by European Union's Horizon 2020 Programme under PerMedCoE project (permedcoe.eu) agreement no. 951773.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/cobrexa.svg\" alt=\"COBREXA logo\" height=\"64px\" style=\"height:64px; width:auto\">â€‡â€‡â€‡<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/unilu.svg\" alt=\"Uni.lu logo\" height=\"64px\" style=\"height:64px; width:auto\">â€‡â€‡â€‡<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/lcsb.svg\" alt=\"LCSB logo\" height=\"64px\" style=\"height:64px; width:auto\">â€‡â€‡â€‡<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/hhu.svg\" alt=\"HHU logo\" height=\"64px\" style=\"height:64px; width:auto\">â€‡â€‡â€‡<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/qtb.svg\" alt=\"QTB logo\" height=\"64px\" style=\"height:64px; width:auto\">â€‡â€‡â€‡<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/permedcoe.svg\" alt=\"PerMedCoE logo\" height=\"64px\" style=\"height:64px; width:auto\">","category":"page"},{"location":"functions/analysis/#Analysis-functions","page":"Analysis functions","title":"Analysis functions","text":"","category":"section"},{"location":"functions/analysis/#Common-analysis-functions","page":"Analysis functions","title":"Common analysis functions","text":"","category":"section"},{"location":"functions/analysis/","page":"Analysis functions","title":"Analysis functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", file), readdir(\"../src/analysis\"))","category":"page"},{"location":"functions/analysis/#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}","page":"Analysis functions","title":"COBREXA.envelope_lattice","text":"envelope_lattice(model::MetabolicModel, ridxs::Vector{Int64}; samples, ranges, reaction_samples) -> Base.Generator{_A, COBREXA.var\"#441#442\"} where _A\n\n\nCreate a lattice (list of \"tick\" vectors) for reactions at indexes ridxs in a model. Arguments samples, ranges, and reaction_samples may be optionally specified to customize the lattice creation process.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{String}}","page":"Analysis functions","title":"COBREXA.envelope_lattice","text":"envelope_lattice(model::MetabolicModel, rids::Vector{String}; kwargs...) -> Base.Generator{_A, COBREXA.var\"#441#442\"} where _A\n\n\nVersion of envelope_lattice that works on string reaction IDs instead of integer indexes.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Analysis functions","title":"COBREXA.objective_envelope","text":"objective_envelope(model::MetabolicModel, ridxs::Vector{Int64}, optimizer; modifications, lattice_args, lattice, analysis, kwargs...) -> NamedTuple{(:lattice, :values), _A} where _A<:Tuple{Any, Array}\n\n\nCompute an array of objective values for the model for rates of reactions specified ridxs fixed to a regular range of values between their respective lower and upper bounds.\n\nThis can be used to compute a \"production envelope\" of a metabolite; but generalizes to any specifiable objective and to multiple dimensions of the examined space. For example, to retrieve a production envelope of any metabolite, set the objective coefficient vector of the model to a vector that contains a single 1 for the exchange reaction that \"outputs\" this metabolite, and run objective_envelope with the exchange reaction of the \"parameter\" metabolite specified in ridxs.\n\nReturns a named tuple that contains lattice with reference values of the metabolites, and an N-dimensional array values with the computed objective values, where N is the number of specified reactions.  Because of the increasing dimensionality, the computation gets very voluminous with increasing length of ridxs. The lattice for computing the optima can be supplied in the argument; by default it is created by envelope_lattice called on the model and reaction indexes. Additional arguments for the call to envelope_lattice can be optionally specified in lattice_args.\n\nkwargs are internally forwarded to screen_optmodel_modifications. modifications are appended to the list of modifications after the lattice bounds are set. By default, this returns the objective values for all points in the lattice; alternate outputs can be implemented via the analysis argument.\n\nExample\n\njulia> m = load_model(\"e_coli_core.xml\");\n\njulia> envelope = objective_envelope(m, [\"R_EX_gln__L_e\", \"R_EX_fum_e\"],\n                                     Tulip.Optimizer;\n                                     lattice_args=(samples=6,));\n\njulia> envelope.lattice   # the reaction rates for which the optima were computed\n2-element Vector{Vector{Float64}}:\n [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]\n [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]\n\njulia> envelope.values   # the computed flux objective values for each reaction rate combination\n6Ã—6 Matrix{Float64}:\n  0.873922   9.25815  17.4538  19.56   20.4121  20.4121\n 13.0354    17.508    19.9369  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{String}, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.objective_envelope","text":"objective_envelope(model::MetabolicModel, rids::Vector{String}, args...; kwargs...) -> NamedTuple{(:lattice, :values), _A} where _A<:Tuple{Any, Array}\n\n\nVersion of objective_envelope that works on string reaction IDs instead of integer indexes.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M<:MetabolicModel","page":"Analysis functions","title":"COBREXA.flux_balance_analysis","text":"flux_balance_analysis(model::MetabolicModel, optimizer; modifications) -> JuMP.Model\n\n\nRun flux balance analysis (FBA) on the model optionally specifying modifications to the problem.  Basically, FBA solves this optimization problem:\n\nmax cáµ€x\ns.t. S x = b\n     xâ‚— â‰¤ x â‰¤ xáµ¤\n\nSee \"Orth, J., Thiele, I. & Palsson, B. What is flux balance analysis?. Nat Biotechnol 28, 245-248 (2010). https://doi.org/10.1038/nbt.1614\" for more information.\n\nThe optimizer must be set to a JuMP-compatible optimizer, such as GLPK.Optimizer or Tulip.Optimizer\n\nOptionally, you may specify one or more modifications to be applied to the model before the analysis, such as change_optimizer_attribute, change_objective, and change_sense.\n\nReturns an optimized JuMP model.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nsolution = flux_balance_analysis(model, GLPK.optimizer)\nvalue.(solution[:x])  # extract flux steady state from the optimizer\n\nbiomass_reaction_id = findfirst(model.reactions, \"BIOMASS_Ecoli_core_w_GAM\")\n\nmodified_solution = flux_balance_analysis(model, GLPK.optimizer;\n    modifications=[change_objective(biomass_reaction_id)])\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.flux_balance_analysis_dict","text":"flux_balance_analysis_dict(model::MetabolicModel, args...; kwargs...) -> Union{Nothing, Dict{String, Float64}}\n\n\nA variant of FBA that returns a dictionary assigning fluxes to reactions, if the solution is found. Arguments are passed to flux_balance_analysis.\n\nThis function is kept for backwards compatibility, use flux_dict instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.flux_balance_analysis_vec","text":"flux_balance_analysis_vec(model::MetabolicModel, args...; kwargs...) -> Union{Nothing, Vector{Float64}}\n\n\nA variant of FBA that returns a vector of fluxes in the same order as reactions of the model, if the solution is found.\n\nArguments are passed to flux_balance_analysis.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._max_variability_flux-NTuple{4, Any}","page":"Analysis functions","title":"COBREXA._max_variability_flux","text":"_max_variability_flux(opt_model, flux, sense, ret) -> Any\n\n\nInternal helper for maximizing reactions in optimization model.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(model::MetabolicModel, optimizer; kwargs...) -> Array\n\n\nA simpler version of flux_variability_analysis that maximizes and minimizes all declared fluxes in the model. Arguments are forwarded.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, SparseArrays.SparseMatrixCSC{Float64, Int64}, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(model::MetabolicModel, fluxes::SparseArrays.SparseMatrixCSC{Float64, Int64}, optimizer; modifications, workers, optimal_objective_value, bounds, ret) -> Array\n\n\nFlux variability analysis solves a pair of optimization problems in model for each flux f described in fluxes:\n\nmin,max fáµ€xáµ¢\ns.t. S x = b\n    xâ‚— â‰¤ x â‰¤ xáµ¤\n     cáµ€x â‰¥ bounds(Zâ‚€)[1]\n     cáµ€x â‰¤ bounds(Zâ‚€)[2]\n\nwhere Zâ‚€:= cáµ€xâ‚€ is the objective value of an optimal solution of the associated FBA problem (see flux_balance_analysis for a related analysis, also for explanation of the modifications argument).\n\nThe bounds is a user-supplied function that specifies the objective bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in FBA. It can return -Inf and Inf in first and second pair to remove the limit. Use gamma_bounds and objective_bounds for simple bounds.\n\noptimizer must be set to a JuMP-compatible optimizer. The computation of the individual optimization problems is transparently distributed to workers (see Distributed.workers()).  The value of Zâ‚€ can be optionally supplied in argument optimal_objective_value, which prevents this function from calling the non-parallelizable FBA. Separating the single-threaded FBA and multithreaded variability computation can be used to improve resource allocation efficiency in many common use-cases.\n\nret is a function used to extract results from optimized JuMP models of the individual fluxes. By default, it calls and returns the value of JuMP.objective_value. More information can be extracted e.g. by setting it to a function that returns a more elaborate data structure; such as m -> (JuMP.objective_value(m), JuMP.value.(m[:x])).\n\nReturns a matrix of extracted ret values for minima and maxima, of total size (size(fluxes,2),2). The optimizer result status is checked with is_solved; nothing is returned if the optimization failed for any reason.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nflux_variability_analysis(model, [1, 2, 3, 42], GLPK.optimizer)\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(model::MetabolicModel, flux_indexes::Vector{Int64}, optimizer; kwargs...) -> Array\n\n\nAn overload of flux_variability_analysis that explores the fluxes specified by integer indexes\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis_dict-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis_dict","text":"flux_variability_analysis_dict(model::MetabolicModel, optimizer; kwargs...) -> Tuple{Any, Any}\n\n\nA variant of flux_variability_analysis that returns the individual maximized and minimized fluxes as two dictionaries (of dictionaries). All keyword arguments except ret are passed through.\n\nExample\n\nmins, maxs = flux_variability_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.99),\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"EX_glc__D_e\"; lb = -10, ub = -10),\n        change_constraint(\"EX_o2_e\"; lb = 0, ub = 0),\n    ],\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.reaction_variability_analysis","text":"reaction_variability_analysis(model::MetabolicModel, optimizer; kwargs...) -> Array\n\n\nShortcut for reaction_variability_analysis that examines all reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Analysis functions","title":"COBREXA.reaction_variability_analysis","text":"reaction_variability_analysis(model::MetabolicModel, reaction_indexes::Vector{Int64}, optimizer; kwargs...) -> Array\n\n\nA variant for flux_variability_analysis that examines actual reactions (selected by their indexes in reactions argument) instead of whole fluxes. This may be useful for models where the sets of reactions and fluxes differ.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.make_gecko_model-Tuple{MetabolicModel}","page":"Analysis functions","title":"COBREXA.make_gecko_model","text":"make_gecko_model(model::MetabolicModel; reaction_isozymes, gene_product_bounds, gene_product_molar_mass, gene_product_mass_group, gene_product_mass_group_bound)\n\n\nWrap a model into a GeckoModel, following the structure given by GECKO algorithm (see GeckoModel documentation for details).\n\nArguments\n\nreaction_isozymes is a function that returns a vector of Isozymes for each reaction, or empty vector if the reaction is not enzymatic.\ngene_product_bounds is a function that returns lower and upper bound for concentration for a given gene product (specified by the same string gene ID as in reaction_isozymes), as Tuple{Float64,Float64}.\ngene_product_molar_mass is a function that returns a numeric molar mass of a given gene product specified by string gene ID.\ngene_product_mass_group is a function that returns a string group identifier for a given gene product, again specified by string gene ID. By default, all gene products belong to group \"uncategorized\" which is the behavior of original GECKO.\ngene_product_mass_group_bound is a function that returns the maximum mass for a given mass group.\n\nAlternatively, all function arguments may be also supplied as dictionaries that provide the same data lookup.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._mmdf_add_df_bound-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA._mmdf_add_df_bound","text":"_mmdf_add_df_bound(lb, ub) -> COBREXA.var\"#527#528\"\n\n\nHelper function to add a new constraint on the driving force.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._mmdf_concen_objective-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA._mmdf_concen_objective","text":"_mmdf_concen_objective(midx, sense) -> COBREXA.var\"#525#526\"\n\n\nHelper function to change the objective to optimizing some concentration.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._mmdf_dgr_objective-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA._mmdf_dgr_objective","text":"_mmdf_dgr_objective(ridx, sense) -> COBREXA.var\"#523#524\"\n\n\nHelper function to change the objective to optimizing some dG.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.max_min_driving_force-Tuple{MetabolicModel, Dict{String, Float64}, Any}","page":"Analysis functions","title":"COBREXA.max_min_driving_force","text":"max_min_driving_force(model::MetabolicModel, reaction_standard_gibbs_free_energies::Dict{String, Float64}, optimizer; flux_solution, proton_ids, water_ids, constant_concentrations, concentration_ratios, concentration_lb, concentration_ub, T, R, small_flux_tol, modifications, ignore_reaction_ids) -> Union{Nothing, NamedTuple{(:mmdf, :dg_reactions, :concentrations), _A} where _A<:Tuple{Any, Dict, Dict}}\n\n\nPerform a max-min driving force analysis on the model, as defined by Noor, et al., \"Pathway thermodynamics highlights kinetic obstacles in central metabolism.\", PLoS computational biology, 2014.\n\nThe function uses the supplied optimizer and reaction_standard_gibbs_free_energies. Optionally, flux_solution can be used to set the directions of each reaction in model (all reactions are assumed to proceed forward and are active by default). The supplied flux_solution should be free of internal cycles i.e. thermodynamically consistent. This optional input is important if a reaction in model normally runs in reverse (negative flux). Note, reactions in flux_solution that are smaller than small_flux_tol are also ignored in the analysis function (for numerical stability).\n\nThe max-min driving force algorithm returns the Gibbs free energy of the reactions, the concentrations of metabolites and the actual maximum minimum driving force. The optimization problem solved is:\n\nmax min -Î”áµ£G\ns.t. Î”áµ£G = Î”rGâ° + R T S' ln(C)\n     Î”áµ£G â‰¤ 0\n     ln(Câ‚—) â‰¤ ln(C) â‰¤ ln(Cáµ¤)\n\nwhere Î”rG are the Gibbs energies dissipated by the reactions, R is the gas constant, T is the temperature, S is the stoichiometry of the model, and C is the vector of metabolite concentrations (and their respective lower and upper bounds).\n\nIn case no feasible solution exists, nothing is returned.\n\nReactions specified in ignore_reaction_ids are internally ignored when calculating the max-min driving force. This should include water and proton importers.\n\nSince biochemical thermodynamics are assumed, the proton_ids and water_ids need to be specified so that they can be ignored in the calculations. Effectively this assumes an aqueous environment at constant pH is used.\n\nconstant_concentrations is used to fix the concentrations of certain metabolites (such as COâ‚‚). concentration_ratios is used to specify additional constraints on metabolite pair concentrations (typically, this is done with various cofactors such as the ATP/ADP ratio. For example, you can fix the concentration of ATP to be always 5Ã— higher than of ADP by specifying Dict((\"ATP\",\"ADP\") => 5.0)\n\nconcentration_lb and concentration_ub set the Câ‚— and Cáµ¤ in the optimization problems.\n\nT and R can be specified in the corresponding units; defaults are K and kJ/K/mol.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.max_min_driving_force_variability-Tuple{MetabolicModel, Dict{String, Float64}, Any}","page":"Analysis functions","title":"COBREXA.max_min_driving_force_variability","text":"max_min_driving_force_variability(model::MetabolicModel, reaction_standard_gibbs_free_energies::Dict{String, Float64}, optimizer; workers, optimal_objective_value, bounds, modifications, kwargs...) -> Array\n\n\nPerform a variant of flux variability analysis on a max min driving force type problem. Arguments are forwarded to max_min_driving_force. Calls screen internally and possibly distributes computation across workers. If optimal_objective_value = nothing, the function first performs regular max min driving force analysis to find the max min driving force of the model and sets this to optimal_objective_value. Then iteratively maximizes and minimizes the driving force across each reaction, and then the concentrations while staying close to the original max min driving force as specified in bounds.\n\nThe bounds is a user-supplied function that specifies the max min driving force bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in the normal max min driving force analysis. It can return -Inf and Inf in first and second pair to remove the limit. Use gamma_bounds and objective_bounds for simple bounds.\n\nReturns a matrix of solutions to max_min_driving_force additionally constrained as described above, where the rows are in the order of the reactions and then the metabolites of the model. For the reaction rows the first column is the maximum dG of that reaction, and the second column is the minimum dG of that reaction subject to the above constraints. For the metabolite rows, the first column is the maximum concentration, and the second column is the minimum concentration subject to the constraints above.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment-Tuple{Dict{String, Float64}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment","text":"minimize_metabolic_adjustment(flux_ref_dict::Dict{String, Float64}) -> COBREXA.var\"#532#534\"{Dict{String, Float64}}\n\n\nOverload of minimize_metabolic_adjustment that works with a dictionary of fluxes.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment-Tuple{Vector{Float64}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment","text":"minimize_metabolic_adjustment(flux_ref::Vector{Float64}) -> COBREXA.var\"#530#531\"{Vector{Float64}}\n\n\nAn optimization model modification that implements the MOMA in minimize_metabolic_adjustment_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment_analysis-Tuple{MetabolicModel, Union{Dict{String, Float64}, Vector{Float64}}, Any}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment_analysis","text":"minimize_metabolic_adjustment_analysis(model::MetabolicModel, flux_ref::Union{Dict{String, Float64}, Vector{Float64}}, optimizer; modifications, kwargs...) -> JuMP.Model\n\n\nRun minimization of metabolic adjustment (MOMA) on model with respect to flux_ref, which is a vector of fluxes in the order of reactions(model). MOMA finds the shortest Euclidian distance between flux_ref and model with modifications:\n\nmin Î£áµ¢ (xáµ¢ - flux_refáµ¢)Â²\ns.t. S x = b\n     xâ‚— â‰¤ x â‰¤ xáµ¤\n\nBecause the problem has a quadratic objective, a QP solver is required. See \"Daniel, Vitkup & Church, Analysis of Optimality in Natural and Perturbed Metabolic Networks, Proceedings of the National Academy of Sciences, 2002\" for more details.\n\nAdditional arguments are passed to flux_balance_analysis.\n\nReturns an optimized model that contains the resultant nearest flux.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nflux_ref = flux_balance_analysis_vec(model, Gurobi.Optimizer)\noptmodel = minimize_metabolic_adjustment(\n    model,\n    flux_ref,\n    Gurobi.Optimizer;\n    modifications = [change_constraint(\"PFL\"; lb=0, ub=0)], # find flux of mutant that is closest to the wild type (reference) model\n    )\nvalue.(solution[:x])  # extract the flux from the optimizer\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment_analysis_dict","text":"minimize_metabolic_adjustment_analysis_dict(model::MetabolicModel, args...; kwargs...) -> Union{Nothing, Dict{String, Float64}}\n\n\nPerform minimization of metabolic adjustment (MOMA) and return a dictionary mapping the reaction IDs to fluxes. Arguments are forwarded to minimize_metabolic_adjustment internally.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment_analysis_vec","text":"minimize_metabolic_adjustment_analysis_vec(model::MetabolicModel, args...; kwargs...) -> Union{Nothing, Vector{Float64}}\n\n\nPerform minimization of metabolic adjustment (MOMA) and return a vector of fluxes in the same order as the reactions in model. Arguments are forwarded to minimize_metabolic_adjustment internally.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.parsimonious_flux_balance_analysis","text":"parsimonious_flux_balance_analysis(model::MetabolicModel, optimizer; modifications, qp_modifications, relax_bounds) -> JuMP.Model\n\n\nRun parsimonious flux balance analysis (pFBA) on the model. In short, pFBA runs two consecutive optimization problems. The first is traditional FBA:\n\nmax cáµ€x = Î¼\ns.t. S x = b\n     xâ‚— â‰¤ x â‰¤ xáµ¤\n\nAnd the second is a quadratic optimization problem:\n\nmin Î£áµ¢ xáµ¢Â²\ns.t. S x = b\n     xâ‚— â‰¤ x â‰¤ xáµ¤\n     Î¼ = Î¼â°\n\nWhere the optimal solution of the FBA problem, Î¼â°, has been added as an additional constraint. See \"Lewis, Nathan E, Hixson, Kim K, Conrad, Tom M, Lerman, Joshua A, Charusanti, Pep, Polpitiya, Ashoka D, Adkins, Joshua N, Schramm, Gunnar, Purvine, Samuel O, Lopez-Ferrer, Daniel, Weitz, Karl K, Eils, Roland, KÃ¶nig, Rainer, Smith, Richard D, Palsson, Bernhard Ã˜, (2010) Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6. 390. doi: accession:10.1038/msb.2010.47\" for more details.\n\npFBA gets the model optimum by standard FBA (using flux_balance_analysis with optimizer and modifications), then finds a minimal total flux through the model that still satisfies the (slightly relaxed) optimum. This is done using a quadratic problem optimizer. If the original optimizer does not support quadratic optimization, it can be changed using the callback in qp_modifications, which are applied after the FBA. See the documentation of flux_balance_analysis for usage examples of modifications.\n\nThhe optimum relaxation sequence can be specified in relax parameter, it defaults to multiplicative range of [1.0, 0.999999, ..., 0.99] of the original bound.\n\nReturns an optimized model that contains the pFBA solution (or an unsolved model if something went wrong).\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\noptmodel = parsimonious_flux_balance_analysis(model, biomass, Gurobi.Optimizer)\nvalue.(solution[:x])  # extract the flux from the optimizer\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.parsimonious_flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.parsimonious_flux_balance_analysis_dict","text":"parsimonious_flux_balance_analysis_dict(model::MetabolicModel, args...; kwargs...) -> Union{Nothing, Dict{String, Float64}}\n\n\nPerform parsimonious flux balance analysis on model using optimizer. Returns a dictionary mapping the reaction IDs to fluxes. Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\nThis function is kept for backwards compatibility, use flux_dict instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.parsimonious_flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.parsimonious_flux_balance_analysis_vec","text":"parsimonious_flux_balance_analysis_vec(model::MetabolicModel, args...; kwargs...) -> Union{Nothing, Vector{Float64}}\n\n\nPerform parsimonious flux balance analysis on model using optimizer. Returns a vector of fluxes in the same order as the reactions in model. Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_args-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA._screen_args","text":"_screen_args(argtuple, kwargtuple, modsname) -> Union{Tuple{}, NamedTuple}\n\n\nInternal helper to check the presence and shape of modification and argument arrays in screen and pals.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_impl-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{A}, Tuple{V}} where {V<:(AbstractVector), A, N}","page":"Analysis functions","title":"COBREXA._screen_impl","text":"_screen_impl(model::MetabolicModel; variants, analysis, args, workers)\n\n\nThe actual implementation of screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_optmodel_item-Tuple{Any}","page":"Analysis functions","title":"COBREXA._screen_optmodel_item","text":"_screen_optmodel_item() -> Any\n\n\nInternal helper for screen_optmodel_modifications that computes one item of the screening task.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_optmodel_modifications_impl-Union{Tuple{N}, Tuple{A}, Tuple{VF}, Tuple{V}, Tuple{MetabolicModel, Any}} where {V<:(AbstractVector), VF<:(AbstractVector), A, N}","page":"Analysis functions","title":"COBREXA._screen_optmodel_modifications_impl","text":"_screen_optmodel_modifications_impl(model::MetabolicModel, optimizer; common_modifications, modifications, args, analysis, workers)\n\n\nThe actual implementation of screen_optmodel_modifications.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_optmodel_prepare-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA._screen_optmodel_prepare","text":"_screen_optmodel_prepare(model, optimizer, common_modifications) -> Tuple{Any, JuMP.Model}\n\n\nInternal helper for screen_optmodel_modifications that creates the model and applies the modifications.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen-Tuple","page":"Analysis functions","title":"COBREXA.screen","text":"screen(args...; kwargs...)\n\n\nTake an array of model-modifying function vectors in variants, and execute the function analysis on all variants of the model specified by variants. The computation is distributed over worker IDs in workers. If args are supplied (as an array of the same size as the variants), they are forwarded as arguments to the corresponding analysis function calls.\n\nThe array of variants must contain vectors of single-parameter functions, these are applied to model in order. The functions must not modify the model, but rather return a modified copy. The copy should be made as shallow as possible, to increase memory efficiency of the process. Variant generators that modify the argument model in-place will cause unpredictable results. Refer to the definition of screen_variant for details.\n\nThe function analysis will receive a single argument (the modified model), together with arguments from args expanded by .... Supply an array of tuples or vectors to pass in multiple arguments to each function. If the argument values should be left intact (not expanded to multiple arguments), they must be wrapped in single-item tuple or vector.\n\nThe modification and analysis functions are transferred to workers as-is; all packages required to run them (e.g. the optimization solvers) must be loaded there. Typically, you want to use the macro @everywhere using MyFavoriteSolver from Distributed package for loading the solvers.\n\nReturn value\n\nThe results of running analysis are collected in to the resulting array, in a way that preserves the shape of the variants, similarly as with pmap.\n\nThe results of analysis function must be serializable, preferably made only from pure Julia structures, because they may be transferred over the network between the computation nodes. For that reason, functions that return whole JuMP models that contain pointers to allocated C structures (such as flux_balance_analysis used with GLPK or Gurobi otimizers) will generally not work in this context.\n\nNote: this function is a thin argument-handling wrapper around _screen_impl.\n\nExample\n\nfunction reverse_reaction(i::Int)\n    (model::CoreModel) -> begin\n        mod = copy(model)\n        mod.S[:,i] .*= -1   # this is unrealistic but sufficient for demonstration\n        mod\n    end\nend\n\nm = load_model(CoreModel, \"e_coli_core.xml\")\n\nscreen(m,\n    variants = [\n        [reverse_reaction(5)],\n        [reverse_reaction(3), reverse_reaction(6)]\n    ],\n    analysis = mod -> mod.S[:,3])  # observe the changes in S\n\nscreen(m,\n    variants = [\n        [reverse_reaction(5)],\n        [reverse_reaction(3), reverse_reaction(6)]\n    ],\n    analysis = mod -> flux_balance_analysis_vec(mod, GLPK.Optimizer))\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen_optimize_objective-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA.screen_optimize_objective","text":"screen_optimize_objective(_, optmodel) -> Union{Nothing, Float64}\n\n\nA variant of optimize_objective directly usable in screen_optmodel_modifications.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen_optmodel_modifications-Tuple","page":"Analysis functions","title":"COBREXA.screen_optmodel_modifications","text":"screen_optmodel_modifications(args...; kwargs...)\n\n\nScreen multiple modifications of the same optimization model.\n\nThis function is potentially more efficient than screen because it avoids making variants of the model structure and remaking of the optimization model. On the other hand, modification functions need to keep the optimization model in a recoverable state (one that leaves the model usable for the next modification), which limits the possible spectrum of modifications applied.\n\nInternally, model is distributed to workers and transformed into the optimization model using make_optimization_model. common_modifications are applied to the models at that point. Next, vectors of functions in modifications are consecutively applied, and the result of analysis function called on model are collected to an array of the same extent as modifications. Calls of analysis are optionally supplied with extra arguments from args expanded with ..., just like in screen.\n\nBoth the modification functions (in vectors) and the analysis function here have 2 base parameters (as opposed to 1 with screen): first is the model (carried through as-is), second is the prepared JuMP optimization model that may be modified and acted upon. As an example, you can use modification change_constraint and analysis screen_optimize_objective.\n\nNote: This function is a thin argument-handling wrapper around _screen_optmodel_modifications_impl.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen_variant","page":"Analysis functions","title":"COBREXA.screen_variant","text":"screen_variant(model::MetabolicModel, variant::Vector, analysis) -> Any\nscreen_variant(model::MetabolicModel, variant::Vector, analysis, args) -> Any\n\n\nHelper function for screen that applies all single-argument functions in variant to the model (in order from \"first\" to \"last\"), and executes analysis on the result.\n\nCan be used to test model variants locally.\n\n\n\n\n\n","category":"function"},{"location":"functions/analysis/#COBREXA.screen_variants-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA.screen_variants","text":"screen_variants(model, variants, analysis; workers) -> Array\n\n\nA shortcut for screen that only works with model variants.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.make_smoment_model-Tuple{MetabolicModel}","page":"Analysis functions","title":"COBREXA.make_smoment_model","text":"make_smoment_model(model::MetabolicModel; reaction_isozyme, gene_product_molar_mass, total_enzyme_capacity)\n\n\nConstruct a model with a structure given by sMOMENT algorithm; returns a SMomentModel (see the documentation for details).\n\nArguments\n\nreaction_isozyme parameter is a function that returns a single Isozyme for each reaction, or nothing if the reaction is not enzymatic. If the reaction has multiple isozymes, use smoment_isozyme_speed to select the fastest one, as recommended by the sMOMENT paper.\ngene_product_molar_mass parameter is a function that returns a molar mass of each gene product as specified by sMOMENT.\ntotal_enzyme_capacity is the maximum \"enzyme capacity\" in the model.\n\nAlternatively, all function arguments also accept dictionaries that are used to provide the same data lookup.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#Sampling","page":"Analysis functions","title":"Sampling","text":"","category":"section"},{"location":"functions/analysis/","page":"Analysis functions","title":"Analysis functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"sampling\", file), readdir(\"../src/analysis/sampling\"))","category":"page"},{"location":"functions/analysis/#COBREXA._affine_hit_and_run_chain-NTuple{8, Any}","page":"Analysis functions","title":"COBREXA._affine_hit_and_run_chain","text":"_affine_hit_and_run_chain(warmup, lbs, ubs, C, cl, cu, iters, seed) -> Matrix{Float64}\n\n\nInternal helper function for computing a single affine hit-and-run chain.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.affine_hit_and_run-Tuple{MetabolicModel, Matrix{Float64}}","page":"Analysis functions","title":"COBREXA.affine_hit_and_run","text":"affine_hit_and_run(m::MetabolicModel, warmup_points::Matrix{Float64}; sample_iters, workers, chains, seed) -> Any\n\n\nRun a hit-and-run style sampling that starts from warmup_points and uses their affine combinations for generating the run directions to sample the space delimited by lbs and ubs.  The reaction rate vectors in warmup_points should be organized in columns, i.e. warmup_points[:,1] is the first set of reaction rates.\n\nThere are total chains of hit-and-run runs, each on a batch of size(warmup_points, 2) points. The runs are scheduled on workers, for good load balancing chains should be ideally much greater than length(workers).\n\nEach run continues for maximum(sample_iters) iterations; the numbers in sample_iters represent the iterations at which the whole \"current\" batch of points is collected for output. For example, sample_iters=[1,4,5] causes the process run for 5 iterations, returning the sample batch that was produced by 1st, 4th and last (5th) iteration.\n\nReturns a matrix of sampled reaction rates (in columns), with all collected samples horizontally concatenated. The total number of samples (columns) will be size(warmup_points,2) * chains * length(sample_iters).\n\nExample\n\nwarmup_points = warmup_from_variability(model, GLPK.Optimizer)\nsamples = affine_hit_and_run(model, warmup_points, sample_iters = 101:105)\n\n# convert the result to flux (for models where the distinction matters):\nfluxes = reaction_flux(model)' * samples\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._maximize_warmup_reaction-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA._maximize_warmup_reaction","text":"_maximize_warmup_reaction(opt_model, rid, ret) -> Any\n\n\nA helper function for finding warmup points from reaction variability.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.warmup_from_variability","page":"Analysis functions","title":"COBREXA.warmup_from_variability","text":"warmup_from_variability(model::MetabolicModel, optimizer) -> Matrix{Float64}\nwarmup_from_variability(model::MetabolicModel, optimizer, min_reactions::AbstractVector{Int64}) -> Matrix{Float64}\nwarmup_from_variability(model::MetabolicModel, optimizer, min_reactions::AbstractVector{Int64}, max_reactions::AbstractVector{Int64}; modifications, workers) -> Matrix{Float64}\n\n\nGenerate FVA-like warmup points for samplers, by minimizing and maximizing the specified reactions. The result is returned as a matrix, each point occupies as single column in the result.\n\n!!! warning Limited effect of modifications in warmup_from_variability     Modifications of the optimization model applied in modifications     parameter that change the semantics of the model have an effect on the     warmup points, but do not automatically carry to the subsequent sampling.     Users are expected to manually transplant any semantic changes to the     actual sampling functions, such as affine_hit_and_run.\n\n\n\n\n\n","category":"function"},{"location":"functions/analysis/#COBREXA.warmup_from_variability-2","page":"Analysis functions","title":"COBREXA.warmup_from_variability","text":"warmup_from_variability(model::MetabolicModel, optimizer, n_points::Int64) -> Matrix{Float64}\nwarmup_from_variability(model::MetabolicModel, optimizer, n_points::Int64, seed; kwargs...) -> Matrix{Float64}\n\n\nGenerates FVA-like warmup points for samplers, by selecting random points by minimizing and maximizing reactions. Can not return more than 2 times the number of reactions in the model.\n\n\n\n\n\n","category":"function"},{"location":"functions/analysis/#Analysis-modifiers","page":"Analysis functions","title":"Analysis modifiers","text":"","category":"section"},{"location":"functions/analysis/","page":"Analysis functions","title":"Analysis functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"modifications\", file), readdir(\"../src/analysis/modifications\"))","category":"page"},{"location":"functions/analysis/#COBREXA.add_crowding_constraints-Tuple{Dict{Int64, Float64}}","page":"Analysis functions","title":"COBREXA.add_crowding_constraints","text":"add_crowding_constraints(weights::Dict{Int64, Float64}) -> COBREXA.var\"#559#561\"{Dict{Int64, Float64}}\n\n\nAdds a molecular crowding constraint to the optimization problem: âˆ‘ wáµ¢ Ã— váµ¢ â‰¤ 1 where wáµ¢ is a weight and váµ¢ is a flux index in the model's reactions specified in weights as váµ¢ => wáµ¢ pairs.\n\nSee Beg, Qasim K., et al. \"Intracellular crowding defines the mode and sequence of substrate uptake by Escherichia coli and constrains its metabolic activity.\" Proceedings of the National Academy of Sciences 104.31 (2007) for more details.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.add_crowding_constraints-Tuple{Dict{String, Float64}}","page":"Analysis functions","title":"COBREXA.add_crowding_constraints","text":"add_crowding_constraints(weights::Dict{String, Float64}) -> COBREXA.var\"#563#564\"{Dict{String, Float64}}\n\n\nVariant of add_crowding_constraints that takes a dictinary of reactions ids instead of reaction indices mapped to weights.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_constraint-Tuple{String}","page":"Analysis functions","title":"COBREXA.change_constraint","text":"change_constraint(id::String; lb, ub) -> COBREXA.var\"#568#569\"{Nothing, Nothing, String}\n\n\nChange the lower and upper bounds (lb and ub respectively) of reaction id if supplied.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_objective-Tuple{Union{String, Vector{String}}}","page":"Analysis functions","title":"COBREXA.change_objective","text":"change_objective(new_objective::Union{String, Vector{String}}; weights, sense) -> Union{COBREXA.var\"#571#573\"{MathOptInterface.OptimizationSense, Vector{String}}, COBREXA.var\"#571#573\"{MathOptInterface.OptimizationSense, String}}\n\n\nModification that changes the objective function used in a constraint based analysis function.  new_objective can be a single reaction identifier, or an array of reactions identifiers.\n\nOptionally, the objective can be weighted by a vector of weights, and a optimization sense can be set to either MAX_SENSE or MIN_SENSE.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.constrain_objective_value-Tuple{Any}","page":"Analysis functions","title":"COBREXA.constrain_objective_value","text":"constrain_objective_value(tolerance) -> COBREXA.var\"#565#566\"\n\n\nLimit the objective value to tolerance-times the current objective value, as with objective_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._do_knockout-Tuple{MetabolicModel, Any, Vector{String}}","page":"Analysis functions","title":"COBREXA._do_knockout","text":"_do_knockout(model::MetabolicModel, opt_model, gene_ids::Vector{String})\n\n\nInternal helper for knockouts on generic MetabolicModels. This can be overloaded so that the knockouts may work differently (more efficiently) with other models.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.knockout-Tuple{String}","page":"Analysis functions","title":"COBREXA.knockout","text":"knockout(gene_id::String) -> COBREXA.var\"#575#576\"{Vector{String}}\n\n\nA helper variant of knockout for a single gene.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.knockout-Tuple{Vector{String}}","page":"Analysis functions","title":"COBREXA.knockout","text":"knockout(gene_ids::Vector{String}) -> COBREXA.var\"#575#576\"{Vector{String}}\n\n\nA modification that zeroes the bounds of all reactions that would be knocked out by the combination of specified genes (effectively disabling the reactions).\n\nA slightly counter-intuitive behavior may occur if knocking out multiple genes: Because this only changes the reaction bounds, multiple gene knockouts must be specified in a single call to knockout, because the modifications have no way to remember which genes are already knocked out and which not.\n\nIn turn, having a reaction that can be catalyzed either by Gene1 or by Gene2, specifying modifications = [knockout([\"Gene1\", \"Gene2\"])] does indeed disable the reaction, but modifications = [knockout(\"Gene1\"), knockout(\"Gene2\")] does not disable the reaction (although reactions that depend either only on Gene1 or only on Gene2 are disabled).\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.add_loopless_constraints-Tuple{}","page":"Analysis functions","title":"COBREXA.add_loopless_constraints","text":"add_loopless_constraints(; max_flux_bound, strict_inequality_tolerance) -> COBREXA.var\"#580#585\"{Float64, Int64}\n\n\nAdd quasi-thermodynamic constraints to the model to ensure that no thermodynamically infeasible internal cycles can occur. Adds the following constraints to the problem:\n\n-max_flux_bound Ã— (1 - yáµ¢) â‰¤ xáµ¢ â‰¤ max_flux_bound Ã— yáµ¢\n-max_flux_bound Ã— yáµ¢ + strict_inequality_tolerance Ã— (1 - yáµ¢) â‰¤ Gáµ¢\nGáµ¢ â‰¤ -strict_inequality_tolerance Ã— yáµ¢ + max_flux_bound Ã— (1 - yáµ¢)\nNáµ¢â‚™â‚œ' Ã— G = 0\nyáµ¢ âˆˆ {0, 1}\nGáµ¢ âˆˆ â„\ni âˆˆ internal reactions\nNáµ¢â‚™â‚œ is the nullspace of the internal stoichiometric matrix\n\nNote, this modification introduces binary variables, so an optimization solver capable of handing mixed integer problems needs to be used. The arguments max_flux_bound and strict_inequality_tolerance implement the \"big-M\" method of indicator constraints.\n\nFor more details about the algorithm, see Schellenberger, Lewis, and, Palsson. \"Elimination of thermodynamically infeasible loops in steady-state metabolic models.\", Biophysical journal, 2011.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.add_moment_constraints-Tuple{Dict{String, Float64}, Float64}","page":"Analysis functions","title":"COBREXA.add_moment_constraints","text":"add_moment_constraints(kcats::Dict{String, Float64}, protein_mass_fraction::Float64) -> COBREXA.var\"#590#596\"{Dict{String, Float64}, Float64}\n\n\nA modification that adds enzyme capacity constraints to the problem using a modified version of the MOMENT algorithm. Requires specific activities, ksas [mmol product/g enzyme/h], for each reaction. Proteins are identified by their associated gene IDs. Adds a variable vector y to the problem corresponding to the protein concentration [g enzyme/gDW cell] of each gene product in the order of genes(model). The total protein concentration [g protein/gDW cell] is constrained to be less than or equal to the protein_mass_fraction. Reaction flux constraints are changed to the MOMENT constraints (see below) for all reactions that have a gene reaction rule, otherwise the flux bounds are left unaltered.\n\nSee Adadi, Roi, et al. \"Prediction of microbial growth rate versus biomass yield by a metabolic network with kinetic parameters.\" PLoS computational biology (2012) for more details of the original algorithm.\n\nHere, a streamlined version of the algorithm is implemented to ensure that the correct units are used. Specifically, this implementation uses specific activities instead of kcats. Thus, for a reaction that can only proceed forward and is catalyzed by protein a, the flux x[i] is bounded by x[i] <= ksas[i] * y[a]. If isozymes a or b catalyse the reaction, then x[i] <= ksas[i] * (y[a] + y[b]). If a reaction is catalyzed by subunits a and b then x[i] <= ksas[i] * min(y[a], y[b]). These rules are applied recursively in the model like in the original algorithm. The enzyme capacity constraint is then implemented by sum(y) â‰¤ protein_mass_fraction. The major benefit of using ksas instead of kcats is that active site number and unit issues are prevented.\n\nExample\n\nflux_balance_analysis(\n    ...,\n    modifications = [ add_moment_constraints(my_kcats, 0.6) ],\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_optimizer-Tuple{Any}","page":"Analysis functions","title":"COBREXA.change_optimizer","text":"change_optimizer(optimizer) -> COBREXA.var\"#604#605\"\n\n\nChange the JuMP optimizer used to run the optimization.\n\nThis may be used to try different approaches for reaching the optimum, and in problems that may require different optimizers for different parts, such as the parsimonious_flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_optimizer_attribute-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA.change_optimizer_attribute","text":"change_optimizer_attribute(attribute_key, value) -> COBREXA.var\"#606#607\"\n\n\nChange a JuMP optimizer attribute. The attributes are optimizer-specific, refer to the JuMP documentation and the documentation of the specific optimizer for usable keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_sense-Tuple{Any}","page":"Analysis functions","title":"COBREXA.change_sense","text":"change_sense(objective_sense) -> COBREXA.var\"#602#603\"\n\n\nChange the objective sense of optimization. Possible arguments are MOI.MAX_SENSE and MOI.MIN_SENSE.\n\nIf you want to change the objective and sense at the same time, use change_objective instead to do both at once.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.silence","page":"Analysis functions","title":"COBREXA.silence","text":"silence\n\nModification that disable all output from the JuMP optimizer (shortcut for set_silent from JuMP).\n\n\n\n\n\n","category":"function"},{"location":"concepts/1_screen/#Screening-many-model-variants","page":"Screening many model variants","title":"Screening many model variants","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"A major goal of COBREXA.jl is to make exploring of many model variants easy and fast.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"One main concept that can be utilized for doing that is implemented in the function screen, which takes your model, a list of model variants that you want to explore by some specified analysis, and schedules the analysis of the model variants parallelly on the available distributed workers.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"In its most basic form, the \"screening\" may use the slightly simplified variant of screen that is called screen_variants, which works as follows:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"m = load_model(StandardModel, \"e_coli_core.json\")\n\nscreen_variants(\n    m,    # the model for screening\n    [\n        [],    # a variant with no modifications\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0)],  # disable CO2 transport\n        [with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable O2 transport\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0), with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable both transports\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The call specifies a model (the m that we have loaded) that is being tested, then a vector of model variants to be created and tested, and then the analysis that is being run on each variant â€“ in this case, we find an optimal steady state of each of the variants, and check out the biomass production rate at that state. In this particular case, we are checking what will be the effect of disabling combinations of CO2 transport and O2 transport in the cells. For that, we get the following result:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"4-element Vector{Float64}:\n 0.8739215022678488\n 0.46166961413944896\n 0.21166294973372135\n 0.21114065173865518","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The numbers are the biomass production rates for the specified variants. We can see that disabling O2 transport really does not help the organism much.","category":"page"},{"location":"concepts/1_screen/#Variant-specification","page":"Screening many model variants","title":"Variant specification","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"In the above example, we have specified 4 variants, thus the analysis returned 4 different results that correspond with the specifications. Let us have a look at the precise format of the specification and result.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Importantly, the variants argument is of type Array{Vector{Any}}, meaning that it can be an array of any dimensionality that contains vectors. Each of the vectors specifies precisely one variant, possibly with more modifications applied to the model in sequence.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"For example:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"[] specifies no modifications at all\n[with_changed_bound(\"CO2t\", lb=0, ub=10)] limits the CO2 transport\n[with_changed_bound(\"CO2t\", lb=0, ub=2), with_changed_bound(\"O2t\", lb=0, ub=100)] severely limits the CO2 transport and slightly restricts the transport of O2","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"note: Variants are single-parameter model-transforming functions\nBecause the variants are just generators of single parameter functions that take the model and return its modified version, you can also use identity to specify a variant that does nothing â€“ [identity] is perfectly same as []","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The shape of the variants array is important too, because it is precisely retained in the result (just as with pmap). If you pass in a matrix of variants, you will receive a matrix of analysis results of the same size. That can be exploited for easily exploring many combinations of possible model properties. Let's try exploring a \"cube\" of possible restricted reactions:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"using IterTools # for cartesian products\n\nres = screen_variants(m,\n    [\n        # for each variant we restricts 2 reactions\n        [with_changed_bound(r1, lb=-3, ub=3), with_changed_bound(r2, lb=-1, ub=1)]\n\n        # the reaction pair will be chosen from a cartesian product\n        for (r1,r2) in product(\n            [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"], # of this set of transport reactions\n            [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"], # and this set of exchanges\n        )\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"As a result, we will receive a full matrix of the biomass productions:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"4Ã—4 Matrix{Float64}:\n 0.407666  0.454097  0.240106  0.183392\n 0.407666  0.485204  0.24766   0.183392\n 0.314923  0.319654  0.24766   0.183392\n 0.407666  0.485204  0.24766   0.183392","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Notably, this shows that O2 transport and NH4 exchange may be serious bottlenecks for biomass production.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"For clarity, you may always annotate the result by zipping it with the specification structure you have used and collecting the data:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"collect(zip(\n    product(\n        [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"],\n        [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"],\n    ),\n    res,\n))","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"...which gives the following annotated result:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"4Ã—4 Matrix{Tuple{Tuple{String, String}, Float64}}:\n ((\"H2Ot\", \"EX_h2o_e\"), 0.407666)  ((\"H2Ot\", \"EX_co2_e\"), 0.454097)  ((\"H2Ot\", \"EX_o2_e\"), 0.240106)  ((\"H2Ot\", \"EX_nh4_e\"), 0.183392)\n ((\"CO2t\", \"EX_h2o_e\"), 0.407666)  ((\"CO2t\", \"EX_co2_e\"), 0.485204)  ((\"CO2t\", \"EX_o2_e\"), 0.24766)   ((\"CO2t\", \"EX_nh4_e\"), 0.183392)\n ((\"O2t\", \"EX_h2o_e\"), 0.314923)   ((\"O2t\", \"EX_co2_e\"), 0.319654)   ((\"O2t\", \"EX_o2_e\"), 0.24766)    ((\"O2t\", \"EX_nh4_e\"), 0.183392)\n ((\"NH4t\", \"EX_h2o_e\"), 0.407666)  ((\"NH4t\", \"EX_co2_e\"), 0.485204)  ((\"NH4t\", \"EX_o2_e\"), 0.24766)   ((\"NH4t\", \"EX_nh4_e\"), 0.183392)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"This may be easily used for e.g. scrutinizing all possible reaction pairs, to find the ones that are redundant and not.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"There are many other variant \"specifications\" to choose from. You may use with_added_reactions, with_removed_reactions, with_removed_metabolites, and others. Function reference contains a complete list; as a convention, names of the specifications all start with with_.","category":"page"},{"location":"concepts/1_screen/#Writing-custom-variant-functions","page":"Screening many model variants","title":"Writing custom variant functions","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"It is actually very easy to create custom specifications that do any modification that you can implement, to be later used with screen_variants and screen.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Generally, the \"specifications\" are supposed to return a function that creates a modified copy of the model. The copy of the model may be shallow, but the functions should always prevent modifying the original model structure â€“ screen is keeping a single copy of the original model at each worker to prevent unnecessary bulk data transport, and if that is changed in-place, all following analyses of the model will work on inconsistent data, usually returning wrong results (even randomly changing ones, because of the asynchronous nature of screen execution).","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Despite of that, writing a modification is easy. The simplest modification that \"does nothing\" (isomorphic to standard identity) can be formatted as follows:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"with_no_change = model -> model","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The modifications may change the model, provided it is copied properly. The following modification will remove a reaction called \"O2t\", effectively removing the possibility to transport oxygen. We require a specific type of model where this change is easy to perform (generally, not all variants may be feasible on all model types).","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"with_disabled_oxygen_transport = (model::StandardModel) -> begin\n\n    # make \"as shallow as possible\" copy of the `model`.\n    # Utilizing `deepcopy` is also possible, but inefficient.\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n\n    # remove the O2 transport from the model copy\n    delete!(new_model.reactions, \"O2t\")\n\n    return new_model #return the newly created variant\nend","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Finally, the whole definition may be parameterized as a normal function. The following variant removes any user-selected reaction:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"with_disabled_reaction(reaction_id) = (model::StandardModel) -> begin\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n    delete!(new_model.reactions, reaction_id) # use the parameter from the specification\n    return new_model\nend","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"In turn, these variants can be used in screen_variants just as we used with_changed_bound above:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"screen_variants(\n    m,    # the model for screening\n    [\n        [with_no_change],\n        [with_disabled_oxygen_transport],\n        [with_disabled_reaction(\"NH4t\")],\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"That should get you the results for all new variants of the model:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"3-element Vector{Float64}:\n 0.8739215022674809\n 0.21166294865468896\n 1.2907224478973395e-15","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"warning: Custom variants with distributed processing\nIf using distributed evaluation, remember the variant-generating functions need to be defined on all used workers (generating the variants in parallel on the workers allows COBREXA to run the screening process very efficiently, without unnecessary sending of bulk model data). Prefixing the definition with @everywhere is usually sufficient for that purpose.","category":"page"},{"location":"concepts/1_screen/#Passing-extra-arguments-to-the-analysis-function","page":"Screening many model variants","title":"Passing extra arguments to the analysis function","text":"","category":"section"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Some analysis functions may take additional arguments, which you might want to vary for the analysis. modifications argument of flux_balance_analysis_dict is one example of such argument, allowing you to specify details of the optimization procedure.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"screen function allows you to do precisely that â€“ apart from variants, you may also specify an array of args of the same shape as variants, the entries of which will get passed together with the generated model variants to your specified analysis function. If either of the arguments is missing (or set to nothing), it is defaulted to \"no modifications\" or \"no arguments\".","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"The arguments must be tuples; you may need to make 1-tuples from your data (e.g. using (value,)) if you want to pass just a single argument.","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"Let's try to use that functionality for trying to find a sufficient amount of iterations needed for Tulip solver to find a feasible solution:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"screen(m,\n    args = [(i,) for i in 5:15],  # the iteration counts, packed in 1-tuples\n    analysis = (m,a) -> # `args` elements get passed as the extra parameter here\n        flux_balance_analysis_vec(m,\n            Tulip.Optimizer;\n            modifications=[change_optimizer_attribute(\"IPM_IterationsLimit\", a)],\n        ),\n)","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"From the result, we can see that Tulip would need at least 14 iterations to find a feasible region:","category":"page"},{"location":"concepts/1_screen/","page":"Screening many model variants","title":"Screening many model variants","text":"11-element Vector{Union{Nothing, Vector{Float64}}}:\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, â€¦ ]\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, â€¦ ]","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/03_exploring.jl\"","category":"page"},{"location":"examples/03_exploring/#Exploring-model-contents","page":"Exploring model contents","title":"Exploring model contents","text":"","category":"section"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"For practical reasons, COBREXA.jl supports many different model types. These comprise ones that reflect the storage formats (such as JSONModel and SBMLModel), and ones that are more easily accessible for users and mimic the usual workflows in COBRA methodology:","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"StandardModel, which contains and object-oriented representation of model internals, built out of Reaction, Metabolite and Gene structures, in a way similar to e.g. COBRApy\nCoreModel, which contains array-oriented representation of the model structures, such as stoichiometry matrix and the bounds vector, in a way similar to e.g. COBRA toolbox","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"The fields in StandardModel structure can be discovered using fieldnames as follows:","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"using COBREXA\n\nfieldnames(StandardModel)\n\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n\nsm = load_model(StandardModel, \"e_coli_core.json\")\ntypeof(sm.reactions)\n\nfieldnames(Reaction)","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"This process (along with e.g. Tab completion in REPL) allows you to pick various information about many objects, for example about a specific reaction:","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"sm.reactions[\"TALA\"].name","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"sm.reactions[\"TALA\"].grr #gene-reaction relationship","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"sm.reactions[\"TALA\"].subsystem","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"sm.reactions[\"TALA\"].ub #upper rate bound","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"The same applies to CoreModel:","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"fieldnames(CoreModel)","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"cm = load_model(CoreModel, \"e_coli_core.json\")","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"cm.S","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"cm.rxns[1:10]","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"","category":"page"},{"location":"examples/03_exploring/","page":"Exploring model contents","title":"Exploring model contents","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/#API-reference","page":"Contents","title":"API reference","text":"","category":"section"},{"location":"functions/","page":"Contents","title":"Contents","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"functions\", join=true))\nDepth = 2","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/06_fva.jl\"","category":"page"},{"location":"examples/06_fva/#Flux-variability-analysis-(FVA)","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"","category":"section"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"Here we will use flux_variability_analysis to analyze the E. coli core model.","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"As usual, if not already present, download the model and load the required packages. We picked the GLPK solver, but others may work as well:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"The FVA implementation in flux_variability_analysis returns maximized and minimized reaction fluxes in a 2-column matrix. The bounds parameter function here (constructed with objective_bounds) sets that the objective value is allowed to vary by 1% from the optimum found by FBA on the same model:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"flux_variability_analysis(model, GLPK.Optimizer; bounds = objective_bounds(0.99))","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"(You may also use gamma_bounds.)","category":"page"},{"location":"examples/06_fva/#Detailed-variability-analysis-with-modifications","page":"Flux variability analysis (FVA)","title":"Detailed variability analysis with modifications","text":"","category":"section"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"A dictionary-returning variant in flux_variability_analysis_dict, returns the result in a slightly more structured way. At the same time, we can specify additional modifications to be applied to the model:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"min_fluxes, max_fluxes = flux_variability_analysis_dict(\n    model,\n    GLPK.Optimizer;\n    bounds = objective_bounds(0.99),\n    modifications = [\n        change_constraint(\"R_EX_glc__D_e\"; lb = -10, ub = -10),\n        change_constraint(\"R_EX_o2_e\"; lb = 0.0, ub = 0.0),\n    ],\n)","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"The dictionaries can be easily used to explore the whole state of the model when certain reactions are maximized or minimized. For example, we can take the maximal acetate exchange flux when the acetate exchange is maximized:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"max_fluxes[\"R_EX_ac_e\"][\"R_EX_ac_e\"]","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"We can also check that the modifications really had the desired effect on oxygen consumption:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"max_fluxes[\"R_EX_ac_e\"][\"R_O2t\"]","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"...and see how much carbon dioxide would produced under at the given metabolic extreme:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"max_fluxes[\"R_EX_ac_e\"][\"R_EX_co2_e\"]","category":"page"},{"location":"examples/06_fva/#Summarizing-the-flux-variability","page":"Flux variability analysis (FVA)","title":"Summarizing the flux variability","text":"","category":"section"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"A convenience function flux_variability_summary is able to display this information in a nice overview:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"flux_variability_summary((min_fluxes, max_fluxes))","category":"page"},{"location":"examples/06_fva/#Retrieving-details-about-FVA-output","page":"Flux variability analysis (FVA)","title":"Retrieving details about FVA output","text":"","category":"section"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"Parameter ret of flux_variability_analysis can be used to extract specific pieces of information from the individual solved (minimized and maximized) optimization problems. Here we show how to extract the value of biomass \"growth\" along with the minimized/maximized reaction flux.","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"First, find the index of biomass reaction in all reactions","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"biomass_idx = first(indexin([\"R_BIOMASS_Ecoli_core_w_GAM\"], reactions(model)))","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"Now run the FVA:","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"vs = flux_variability_analysis(\n    model,\n    GLPK.Optimizer;\n    bounds = objective_bounds(0.50), # objective can vary by up to 50% of the optimum\n    modifications = [\n        change_constraint(\"R_EX_glc__D_e\"; lb = -10, ub = -10),\n        change_constraint(\"R_EX_o2_e\"; lb = 0.0, ub = 0.0),\n    ],\n    ret = optimized_model -> (\n        COBREXA.JuMP.objective_value(optimized_model),\n        COBREXA.JuMP.value(optimized_model[:x][biomass_idx]),\n    ),\n)","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"","category":"page"},{"location":"examples/06_fva/","page":"Flux variability analysis (FVA)","title":"Flux variability analysis (FVA)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/04b_standardmodel_construction.jl\"","category":"page"},{"location":"examples/04b_standardmodel_construction/#Model-construction-and-modification","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"section"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"COBREXA can load models stored in .mat, .json, and .xml formats; and convert these into StandardModels. However, it is also possible to construct models from scratch, and modify existing models. This will be demonstrated here.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"using COBREXA","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"In COBREXA, model construction is primarily supported through StandardModels. To begin, create an empty StandardModel.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"model = StandardModel(\"FirstModel\") # assign model id = \"FirstModel\"","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"Next, genes, metabolites and reactions need to be added to the model.","category":"page"},{"location":"examples/04b_standardmodel_construction/#Add-genes-to-the-model","page":"Model construction and modification","title":"Add genes to the model","text":"","category":"section"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"gene_list = [Gene(string(\"g\", num)) for num = 1:8]","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"warning: Warning: Don't accidentally overwrite the generic accessors\nIt may be tempting to call a variable genes, metabolites, or   reactions. However, these names conflict with generic accessors   functions and will create problems downstream.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"add_genes!(model, gene_list)","category":"page"},{"location":"examples/04b_standardmodel_construction/#Add-metabolites-to-the-model","page":"Model construction and modification","title":"Add metabolites to the model","text":"","category":"section"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"metabolite_list = [Metabolite(string(\"m\", num)) for num = 1:4]\n\nmetabolite_list[1].formula = \"C6H12O6\" # can edit metabolites, etc. directly\n\nadd_metabolites!(model, metabolite_list)","category":"page"},{"location":"examples/04b_standardmodel_construction/#Add-reactions-to-the-model","page":"Model construction and modification","title":"Add reactions to the model","text":"","category":"section"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"There are two ways to create and add reactions to a model. These are using functions, or macros.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"r_m1 = Reaction(\"EX_m1\", Dict(\"m1\" => -1.0), :bidirectional) # exchange reaction: m1 <-> (is the same as m1 â†” nothing)\nr1 = Reaction(\"r1\", Dict(\"m1\" => -1.0, \"m2\" => 1.0), :forward)\nr1.grr = [[\"g1\", \"g2\"], [\"g3\"]] # add some gene reaction rules\nr2 = Reaction(\"r2\", Dict(\"m2\" => -1.0, \"m1\" => 1.0), :reverse)\nr3 = Reaction(\"r3\", Dict(\"m2\" => -1.0, \"m3\" => 1.0), :bidirectional)\n\nadd_reactions!(model, [r1, r2, r3, r_m1]) # function approach\n\nm1 = metabolite_list[1]\nm2 = metabolite_list[2]\nm3 = metabolite_list[3]\nm4 = metabolite_list[4]\n\n@add_reactions! model begin # macro approach\n    \"r4\", m2 â†’ m4, 0, 1000\n    \"r_m3\", m3 â†” nothing, -1000, 1000\n    \"r_m4\", m4 â†’ nothing\n    \"r5\", m4 â†’ m2\nend\n\nmodel.reactions[\"r4\"].grr = [[\"g5\"], [\"g6\", \"g7\"], [\"g8\"]]","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"note: Note: Writing unicode arrows\nThe reaction arrows can be easily written by using the LaTeX completions built into Julia shell (and many Julia-compatible editors). You can type:â†’ as \\rightarrow (press Tab to complete)\nâ† as \\leftarrow\nâ†” as \\leftrightarrow","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"The constructed model can now be inspected.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"model","category":"page"},{"location":"examples/04b_standardmodel_construction/#Modifying-existing-models","page":"Model construction and modification","title":"Modifying existing models","text":"","category":"section"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"It is also possible to modify a model by deleting certain genes. This is simply achieved by calling remove_genes!.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"remove_genes!(model, [\"g1\", \"g2\"]; knockout_reactions = false)\nmodel","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"Likewise, reactions and metabolites can also be deleted.","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"remove_metabolite!(model, \"m1\")\nmodel","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"page"},{"location":"examples/04b_standardmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/io/#Input-and-output","page":"Input and output","title":"Input and output","text":"","category":"section"},{"location":"functions/io/#File-I/O-and-serialization","page":"Input and output","title":"File I/O and serialization","text":"","category":"section"},{"location":"functions/io/","page":"Input and output","title":"Input and output","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", file), readdir(\"../src/io\"))","category":"page"},{"location":"functions/io/#Base.close-Tuple{HDF5Model}","page":"Input and output","title":"Base.close","text":"close(model::HDF5Model)\n\n\nClose (and un-cache) the HDF5Model data. This allows the associated file to be opened for writing again.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_h5_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_h5_model","text":"load_h5_model(file_name::String) -> HDF5Model\n\n\nReturn a HDF5Model associated with the given file. Does not actually load anything (for efficiency) â€“ use precache! to start pulling data into the memory.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_h5_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_h5_model","text":"save_h5_model(model::MetabolicModel, file_name::String) -> HDF5Model\n\n\nConverts and writes a metabolic model to disk in the HDF5 format.\n\nAdditionally returns an (uncached) HDF5Model that represents the contents of the saved file. Because all HDF5-based models need to be backed by disk storage, writing the data to disk (using this function) is the only way to make new HDF5 models.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_model","text":"load_model(file_name::String) -> Any\n\n\nGeneric function for loading models that chooses a specific loader function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nSBML models (*.xml, loaded with load_sbml_model)\nJSON models (*.json, loaded with load_json_model)\nMATLAB models (*.mat, loaded with load_mat_model)\nHDF5 models (*.h5, loaded with load_h5_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_model-Union{Tuple{T}, Tuple{Type{T}, String}} where T<:MetabolicModel","page":"Input and output","title":"COBREXA.load_model","text":"load_model(type::Type{T<:MetabolicModel}, file_name::String) -> MetabolicModel\n\n\nHelper function tht loads the model using load_model and return it converted to type.\n\nExample:\n\nload_model(CoreModel, \"mySBMLModel.xml\")\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_model","text":"save_model(model::MetabolicModel, file_name::String) -> Maybe{HDF5Model}\n\n\nGeneric function for saving models that chooses a specific writer function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nSBML models (*.xml, saved with save_sbml_model)\nJSON models (*.json, saved with save_json_model)\nMATLAB models (*.mat, saved with save_mat_model)\nHDF5 models (*.h5, saved with save_h5_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_json_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_json_model","text":"load_json_model(filename::String) -> JSONModel\n\n\nLoad and return a JSON-formatted model that is stored in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_json_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_json_model","text":"save_json_model(model::MetabolicModel, file_name::String)\n\n\nSave a JSONModel in model to a JSON file file_name.\n\nIn case the model is not JSONModel, it will be converted automatically.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_mat_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_mat_model","text":"load_mat_model(file_name::String) -> MATModel\n\n\nLoad and return a MATLAB file file_name that contains a COBRA-compatible model.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_mat_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_mat_model","text":"save_mat_model(model::MetabolicModel, file_path::String; model_name)\n\n\nSave a MATModel in model to a MATLAB file file_name in a format compatible with other MATLAB-based COBRA software.\n\nIn case the model is not MATModel, it will be converted automatically.\n\nmodel_name is the identifier name for the whole model written to the MATLAB file; defaults to just \"model\".\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_sbml_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_sbml_model","text":"load_sbml_model(file_name::String) -> SBMLModel\n\n\nLoad and return a SBML XML model in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_sbml_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_sbml_model","text":"save_sbml_model(model::MetabolicModel, file_name::String)\n\n\nWrite a given SBML model to file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#Pretty-printing","page":"Input and output","title":"Pretty printing","text":"","category":"section"},{"location":"functions/io/","page":"Input and output","title":"Input and output","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", \"show\", file), readdir(\"../src/io/show\"))","category":"page"},{"location":"functions/io/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, MetabolicModel}","page":"Input and output","title":"Base.show","text":"show(io::IO, _::MIME{Symbol(\"text/plain\")}, m::MetabolicModel)\n\n\nPretty printing of everything metabolic-modelish.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_substances-Tuple{Vector{String}}","page":"Input and output","title":"COBREXA._pretty_substances","text":"_pretty_substances(ss::Vector{String}) -> String\n\n\nNicely format a substance list.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#Base.show-Union{Tuple{M}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Serialized{M}}} where M","page":"Input and output","title":"Base.show","text":"show(io::IO, _::MIME{Symbol(\"text/plain\")}, m::Serialized{M})\n\n\nShow the Serialized model without unnecessarily loading it.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Any}","page":"Input and output","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(io, def::String, payload; kwargs...)\n\n\nNicely prints keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Dict}","page":"Input and output","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(io, def::String, payload::Dict)\n\n\nSpecialization of _pretty_print_keyvals for dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_print_keyvals-Tuple{Any, String, String}","page":"Input and output","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(io, def::String, payload::String)\n\n\nSpecialization of _pretty_print_keyvals for plain strings.\n\n\n\n\n\n","category":"method"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/01_loading.jl\"","category":"page"},{"location":"examples/01_loading/#Loading-models","page":"Loading models","title":"Loading models","text":"","category":"section"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"COBREXA can load models stored in .mat, .json, and .xml formats (with the latter denoting SBML formatted models).","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"We will primarily use the E. coli  \"core\" model to demonstrate the utilities found in COBREXA. First, let's download the model in several formats.","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"# Downloads the model files if they don't already exist\n!isfile(\"e_coli_core.mat\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.mat\", \"e_coli_core.mat\");\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\");\nnothing #hide","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"tip: Save bandwidth!\nThe published models usually do not change very often. It is therefore pretty useful to save them to a central location and load them from there. That saves your time, and does not unnecessarily consume the connectivity resources of the model repository.","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"Load the models using the load_model function. Models are able to \"pretty-print\" themselves, hiding the inner complexity:","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"using COBREXA\n\nmat_model = load_model(\"e_coli_core.mat\")","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"json_model = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"sbml_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"note: Note: `load_model` infers the input type from the file extension\nNotice how each model was read into memory as a model type corresponding   to its file type, i.e. the file ending with .json loaded as a   JSONModel, the file ending with .mat loaded as MATModel, and the   file ending with .xml loaded as an SBMLModel.","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"The loaded models contain the data in a format that is preferably as compatible as possible with the original representation. In particular, the JSON model contains the representation of the JSON tree:","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"json_model.json","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"SBML models contain a complicated structure from SBML.jl package:","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"typeof(sbml_model.sbml)","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"MAT models contain MATLAB data:","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"mat_model.mat","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"In all cases, you can access the data in the model in the same way, e.g., using reactions to get a list of the reactions in the models:","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"reactions(mat_model)[1:5]","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"reactions(json_model)[1:5]","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"You can use the generic accessors to gather more information about the model contents, convert the models into formats more suitable for hands-on processing, and export them back to disk after the modification.","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"All model types can be directly used in analysis functions, such as flux_balance_analysis.","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"","category":"page"},{"location":"examples/01_loading/","page":"Loading models","title":"Loading models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"functions/utils/#Helper-functions","page":"Utilities","title":"Helper functions","text":"","category":"section"},{"location":"functions/utils/","page":"Utilities","title":"Utilities","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"utils\", file), readdir(\"../src/base/utils\"))","category":"page"},{"location":"functions/utils/#COBREXA.ambiguously_identified_items-Tuple{Dict{String, Dict{String, Set{String}}}}","page":"Utilities","title":"COBREXA.ambiguously_identified_items","text":"ambiguously_identified_items(index::Dict{String, Dict{String, Set{String}}}) -> Set{String}\n\n\nFind items (genes, metabolites, ...) from the annotation index that are identified non-uniquely by at least one of their annotations.\n\nThis often indicates that the items are duplicate or miscategorized.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.annotation_index-Tuple{AbstractDict{String}}","page":"Utilities","title":"COBREXA.annotation_index","text":"annotation_index(xs::AbstractDict{String}; annotations) -> Dict{String, Dict{String, Set{String}}}\n\n\nExtract annotations from a dictionary of items xs and build an index that maps annotation \"kinds\" (e.g. \"PubChem\") to the mapping from the annotations (e.g.  \"COMPOUND_12345\") to item IDs that carry the annotations.\n\nFunction annotations is used to access the Annotations object in the dictionary values.\n\nThis is extremely useful for finding items by annotation data.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.check_duplicate_reaction-Tuple{Reaction, OrderedCollections.OrderedDict{String, Reaction}}","page":"Utilities","title":"COBREXA.check_duplicate_reaction","text":"check_duplicate_reaction(crxn::Reaction, rxns::OrderedCollections.OrderedDict{String, Reaction}; only_metabolites) -> Union{Nothing, String}\n\n\nCheck if rxn already exists in rxns but has another id. If only_metabolites is true then only the metabolite ids are checked. Otherwise, compares metabolite ids and the absolute value of their stoichiometric coefficients to those of rxn. If rxn has the same reaction equation as another reaction in rxns, the return the id. Otherwise return nothing.\n\nSee also: reaction_mass_balanced\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.is_boundary-Tuple{Dict{String, Float64}}","page":"Utilities","title":"COBREXA.is_boundary","text":"is_boundary(rxn_dict::Dict{String, Float64}) -> Bool\n\n\nReturn true if the reaction denoted by rxn_dict is a boundary reaction, otherwise return false. Checks if on boundary by inspecting the number of metabolites in rxn_dict. Boundary reactions have only one metabolite, e.g. an exchange reaction, or a sink/demand reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.reaction_atom_balance-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Utilities","title":"COBREXA.reaction_atom_balance","text":"reaction_atom_balance(model::MetabolicModel, reaction_dict::Dict{String, Float64}) -> Dict{String, Float64}\n\n\nReturns a dictionary mapping the stoichiometry of atoms through a single reaction. Uses the metabolite information in model to determine the mass balance. Accepts a reaction dictionary, a reaction string id or a Reaction as an argument for rxn.\n\nSee also: reaction_mass_balanced\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.reaction_mass_balanced-Tuple{StandardModel, String}","page":"Utilities","title":"COBREXA.reaction_mass_balanced","text":"reaction_mass_balanced(model::StandardModel, rxn_id::String) -> Bool\n\n\nChecks if rxn is atom balanced. Returns a boolean for whether the reaction is balanced, and the associated balance of atoms for convenience (useful if not balanced). Calls reaction_atom_balance internally.\n\nSee also: check_duplicate_reaction, reaction_atom_balance\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.stoichiometry_string-Tuple{Any}","page":"Utilities","title":"COBREXA.stoichiometry_string","text":"stoichiometry_string(req; format_id) -> String\n\n\nReturn the reaction equation as a string. The metabolite strings can be manipulated by setting format_id.\n\nExample\n\njulia> req = Dict(\"coa_c\" => -1, \"for_c\" => 1, \"accoa_c\" => 1, \"pyr_c\" => -1)\njulia> stoichiometry_string(req)\n\"coa_c + pyr_c = for_c + accoa_c\"\n\njulia> stoichiometry_string(req; format_id = x -> x[1:end-2])\n\"coa + pyr = for + accoa\"\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.stoichiometry_string-Tuple{Reaction}","page":"Utilities","title":"COBREXA.stoichiometry_string","text":"stoichiometry_string(rxn::Reaction; kwargs...) -> String\n\n\nAlternative of stoichiometry_string take takes a Reaction as an argument.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.serialize_model-Tuple{Serialized, String}","page":"Utilities","title":"COBREXA.serialize_model","text":"serialize_model(model::Serialized, filename::String) -> Serialized\n\n\nSpecialization of serialize_model that prevents nested serialization of already-serialized models.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.serialize_model-Union{Tuple{MM}, Tuple{MM, String}} where MM<:MetabolicModel","page":"Utilities","title":"COBREXA.serialize_model","text":"serialize_model(model::MetabolicModel, filename::String) -> Serialized\n\n\nSerialize the model to file filename, returning a Serialized model that can be loaded back transparently by precache!. The result does not contain the actual model data that are deferred to the disk; it may thus be used to save memory, or send the model efficiently to remote workers within distributed shared-storage environments.\n\nThe benefit of using this over \"raw\" Serialization.serialize is that the resulting Serialized model will reload itself automatically with precache! at first usage, which needs to be done manually when using the Serialization package directly.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{Gene}","page":"Utilities","title":"Base.copy","text":"copy(g::Gene) -> Gene\n\n\nShallow copy of a Gene\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{Metabolite}","page":"Utilities","title":"Base.copy","text":"copy(m::Metabolite) -> Metabolite\n\n\nShallow copy of a Metabolite\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{Reaction}","page":"Utilities","title":"Base.copy","text":"copy(r::Reaction) -> Reaction\n\n\nShallow copy of a Reaction\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{StandardModel}","page":"Utilities","title":"Base.copy","text":"copy(m::StandardModel) -> StandardModel\n\n\nShallow copy of a StandardModel\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gamma_bounds-Tuple{Any}","page":"Utilities","title":"COBREXA.gamma_bounds","text":"gamma_bounds(gamma) -> COBREXA.var\"#641#642\"\n\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to be at least gamma*Zâ‚€, as usual in COBRA packages. Use as the bounds argument:\n\nflux_variability_analysis(model, some_optimizer; bounds = gamma_bounds(0.9))\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.objective_bounds-Tuple{Any}","page":"Utilities","title":"COBREXA.objective_bounds","text":"objective_bounds(tolerance) -> COBREXA.var\"#643#644\"\n\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to a small multiple of Zâ‚€. Use as bounds argument, similarly to gamma_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_formula-Tuple{String}","page":"Utilities","title":"COBREXA._parse_formula","text":"_parse_formula(f::String) -> Dict{String, Int64}\n\n\nParse a formula in format C2H6O into a MetaboliteFormula, which is basically a dictionary of atom counts in the molecule.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._unparse_formula-Tuple{Dict{String, Int64}}","page":"Utilities","title":"COBREXA._unparse_formula","text":"_unparse_formula(f::Dict{String, Int64}) -> String\n\n\nFormat MetaboliteFormula to String.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_dict-Tuple{GeckoModel, Any}","page":"Utilities","title":"COBREXA.gene_product_dict","text":"gene_product_dict(model::GeckoModel, opt_model) -> Any\n\n\nReturn a dictionary mapping protein molar concentrations to their ids. The argument opt_model is a solved optimization problem, typically returned by flux_balance_analysis. See flux_dict for the corresponding function that returns a dictionary of solved fluxes.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_dict-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA.gene_product_dict","text":"gene_product_dict(model::GeckoModel) -> COBREXA.var\"#647#648\"{GeckoModel}\n\n\nA pipe-able variant of gene_product_dict.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass-Tuple{SMomentModel, Any}","page":"Utilities","title":"COBREXA.gene_product_mass","text":"gene_product_mass(model::SMomentModel, opt_model) -> Any\n\n\nExtract the total mass utilization in a solved SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass-Tuple{SMomentModel}","page":"Utilities","title":"COBREXA.gene_product_mass","text":"gene_product_mass(model::SMomentModel) -> COBREXA.var\"#655#656\"{SMomentModel}\n\n\nA pipe-able variant of gene_product_mass.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass_group_dict-Tuple{GeckoModel, Any}","page":"Utilities","title":"COBREXA.gene_product_mass_group_dict","text":"gene_product_mass_group_dict(model::GeckoModel, opt_model) -> Union{Nothing, Dict}\n\n\nExtract the mass utilization in mass groups from a solved GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass_group_dict-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA.gene_product_mass_group_dict","text":"gene_product_mass_group_dict(model::GeckoModel) -> COBREXA.var\"#651#652\"{GeckoModel}\n\n\nA pipe-able variant of gene_product_mass_group_dict.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.atom_fluxes-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Utilities","title":"COBREXA.atom_fluxes","text":"atom_fluxes(model::MetabolicModel, reaction_fluxes::Dict{String, Float64}) -> Dict{String, Float64}\n\n\nReturn a dictionary mapping the flux of atoms across a flux solution given by reaction_fluxes using the reactions in model to determine the appropriate stoichiometry.\n\nNote, this function ignores metabolites with no formula assigned to them, no error message will be displayed.\n\nNote, if a model is mass balanced there should be not net flux of any atom. By removing reactions from the flux_solution you can investigate how that impacts the mass balances.\n\nExample\n\n# Find flux of Carbon through all metabolic reactions except the biomass reaction\ndelete!(fluxes, \"BIOMASS_Ecoli_core_w_GAM\")\natom_fluxes(model, fluxes)[\"C\"]\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.metabolite_fluxes-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Utilities","title":"COBREXA.metabolite_fluxes","text":"metabolite_fluxes(model::MetabolicModel, flux_dict::Dict{String, Float64}) -> Tuple{Dict{String, Dict{String, Float64}}, Dict{String, Dict{String, Float64}}}\n\n\nReturn two dictionaries of metabolite ids mapped to reactions that consume or produce them, given the flux distribution supplied in flux_dict.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_gene_product_coupling-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_gene_product_coupling","text":"_gecko_gene_product_coupling(model::GeckoModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nCompute the part of the coupling for GeckoModel that limits the amount of each kind of protein available.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_mass_group_coupling-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_mass_group_coupling","text":"_gecko_mass_group_coupling(model::GeckoModel) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nCompute the part of the coupling for GeckoModel that limits the total mass of each group of gene products.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_column_reactions-Tuple{Any, Any}","page":"Utilities","title":"COBREXA._gecko_reaction_column_reactions","text":"_gecko_reaction_column_reactions(columns, inner) -> SparseArrays.SparseMatrixCSC\n\n\nHelper method that doesn't require the whole GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_column_reactions-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_reaction_column_reactions","text":"_gecko_reaction_column_reactions(model::GeckoModel) -> SparseArrays.SparseMatrixCSC{Int64, Int64}\n\n\nRetrieve a utility mapping between reactions and split reactions; rows correspond to \"original\" reactions, columns correspond to \"split\" reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_coupling-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_reaction_coupling","text":"_gecko_reaction_coupling(model::GeckoModel) -> SparseArrays.SparseMatrixCSC{Int64, Int64}\n\n\nCompute the part of the coupling for GeckoModel that limits the \"arm\" reactions (which group the individual split unidirectional reactions).\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_name-Tuple{String, Int64, Int64}","page":"Utilities","title":"COBREXA._gecko_reaction_name","text":"_gecko_reaction_name(original_name::String, direction::Int64, isozyme_idx::Int64) -> String\n\n\nInternal helper for systematically naming reactions in GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_grr-Tuple{SBML.GeneProductAssociation}","page":"Utilities","title":"COBREXA._parse_grr","text":"_parse_grr(gpa::SBML.GeneProductAssociation) -> Vector{Vector{String}}\n\n\nParse SBML.GeneProductAssociation structure to the simpler GeneAssociation. The input must be (implicitly) in a positive DNF.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_grr-Tuple{String}","page":"Utilities","title":"COBREXA._parse_grr","text":"_parse_grr(s::String) -> Union{Nothing, Vector{Vector{String}}}\n\n\nParse a DNF gene association rule in format (YIL010W and YLR043C) or (YIL010W and YGR209C) to GeneAssociation. Also acceptsOR,|,||,AND,&, and&&`.\n\nExample\n\njulia> _parse_grr(\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\")\n2-element Array{Array{String,1},1}:\n [\"YIL010W\", \"YLR043C\"]\n [\"YIL010W\", \"YGR209C\"]\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_grr_to_sbml-Tuple{String}","page":"Utilities","title":"COBREXA._parse_grr_to_sbml","text":"_parse_grr_to_sbml(str::String) -> Union{Nothing, SBML.GeneProductAssociation}\n\n\nInternal helper for parsing the string GRRs into SBML data structures. More general than _parse_grr.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._unparse_grr-Tuple{Type{SBML.GeneProductAssociation}, Vector{Vector{String}}}","page":"Utilities","title":"COBREXA._unparse_grr","text":"_unparse_grr(_::Type{SBML.GeneProductAssociation}, x::Vector{Vector{String}}) -> SBML.GPAOr\n\n\nConvert a GeneAssociation to the corresponding SBML.jl structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._unparse_grr-Tuple{Type{String}, Vector{Vector{String}}}","page":"Utilities","title":"COBREXA._unparse_grr","text":"_unparse_grr(_::Type{String}, grr::Vector{Vector{String}}) -> String\n\n\nConverts a nested string gene reaction array  back into a gene reaction rule string.\n\nExample\n\njulia> _unparse_grr(String, [[\"YIL010W\", \"YLR043C\"], [\"YIL010W\", \"YGR209C\"]])\n\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\"\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._guesskey-Tuple{Any, Any}","page":"Utilities","title":"COBREXA._guesskey","text":"_guesskey(avail, possibilities) -> Any\n\n\nUnfortunately, many model types that contain dictionares do not have standardized field names, so we need to try a few possibilities and guess the best one. The keys used to look for valid field names should be ideally specified as constants in src/base/constants.jl.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gets-Tuple{Any, Any, Any}","page":"Utilities","title":"COBREXA.gets","text":"gets(collection, fail, keys) -> Any\n\n\nReturn fail if key in keys is not in collection, otherwise return collection[key]. Useful if may different keys need to be tried due to non-standardized model formats.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_biomass_reaction_ids-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_biomass_reaction_ids","text":"find_biomass_reaction_ids(m::MetabolicModel; kwargs...) -> Any\n\n\nShortcut for finding biomass reaction identifiers in a model; arguments are forwarded to looks_like_biomass_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_biomass_reactions-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_biomass_reactions","text":"find_biomass_reactions(m::MetabolicModel; kwargs...) -> Any\n\n\nShortcut for finding biomass reaction indexes in a model; arguments are forwarded to looks_like_biomass_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_exchange_reaction_ids-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_exchange_reaction_ids","text":"find_exchange_reaction_ids(m::MetabolicModel; kwargs...) -> Any\n\n\nShortcut for finding exchange reaction identifiers in a model; arguments are forwarded to looks_like_exchange_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_exchange_reactions-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_exchange_reactions","text":"find_exchange_reactions(m::MetabolicModel; kwargs...) -> Any\n\n\nShortcut for finding exchange reaction indexes in a model; arguments are forwarded to looks_like_exchange_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_extracellular_metabolite_ids-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_extracellular_metabolite_ids","text":"find_extracellular_metabolite_ids(m::MetabolicModel; kwargs...) -> Any\n\n\nShortcut for finding extracellular metabolite identifiers in a model; arguments are forwarded to looks_like_extracellular_metabolite.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_extracellular_metabolites-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_extracellular_metabolites","text":"find_extracellular_metabolites(m::MetabolicModel; kwargs...) -> Any\n\n\nShortcut for finding extracellular metabolite indexes in a model; arguments are forwarded to looks_like_extracellular_metabolite.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.looks_like_biomass_reaction-Tuple{String}","page":"Utilities","title":"COBREXA.looks_like_biomass_reaction","text":"looks_like_biomass_reaction(rxn_id::String; exclude_exchanges, exchange_prefixes, biomass_strings) -> Bool\n\n\nA predicate that matches reaction identifiers that look like biomass reactions. Biomass reactions are identified by looking for occurences of biomass_strings in the reaction id. If exclude_exchanges is set, the strings that look like exchanges (from looks_like_exchange_reaction) will not match.\n\nExample\n\nfilter(looks_like_biomass_reaction, reactions(model)) # returns strings\nfindall(looks_like_biomass_reaction, reactions(model)) # returns indices\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.looks_like_exchange_reaction-Tuple{String}","page":"Utilities","title":"COBREXA.looks_like_exchange_reaction","text":"looks_like_exchange_reaction(rxn_id::String; exclude_biomass, biomass_strings, exchange_prefixes) -> Bool\n\n\nA predicate that matches reaction identifiers that look like exchange or biomass reactions, given the usual naming schemes in common model repositories. Exchange reactions are identified based on matching prefixes in the set exchange_prefixes and biomass reactions are identified by looking for occurences of biomass_strings in the reaction id.\n\nAlso see find_exchange_reactions.\n\nExample\n\nfindall(looks_like_exchange_reaction, reactions(model)) # returns indices\nfilter(looks_like_exchange_reaction, reactions(model)) # returns Strings\n\n# to use the optional arguments you need to expand the function's arguments\n# using an anonymous function\nfindall(x -> looks_like_exchange_reaction(x; exclude_biomass=true), reactions(model)) # returns indices\nfilter(x -> looks_like_exchange_reaction(x; exclude_biomass=true), reactions(model)) # returns Strings\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.looks_like_extracellular_metabolite-Tuple{String}","page":"Utilities","title":"COBREXA.looks_like_extracellular_metabolite","text":"looks_like_extracellular_metabolite(met_id::String; extracellular_suffixes) -> Bool\n\n\nA predicate that matches metabolite identifiers that look like they are extracellular metabolites. Extracellular metabolites are identified by extracellular_suffixes at the end of the metabolite id.\n\nExample\n\nfilter(looks_like_extracellular_metabolite, metabolites(model)) # returns strings\nfindall(looks_like_extracellular_metabolite, metabolites(model)) # returns indices\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._smoment_column_reactions-Tuple{SMomentModel}","page":"Utilities","title":"COBREXA._smoment_column_reactions","text":"_smoment_column_reactions(model::SMomentModel) -> SparseArrays.SparseMatrixCSC{Int64, Int64}\n\n\nRetrieve a utility mapping between reactions and split reactions; rows correspond to \"original\" reactions, columns correspond to \"split\" reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._smoment_reaction_name-Tuple{String, Int64}","page":"Utilities","title":"COBREXA._smoment_reaction_name","text":"_smoment_reaction_name(original_name::String, direction::Int64) -> String\n\n\nInternal helper for systematically naming reactions in SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.smoment_isozyme_speed-Tuple{Function}","page":"Utilities","title":"COBREXA.smoment_isozyme_speed","text":"smoment_isozyme_speed(gene_product_molar_mass::Function) -> COBREXA.var\"#741#742\"\n\n\nA piping- and argmax-friendly overload of smoment_isozyme_speed.\n\nExample\n\ngene_mass_function = gid -> 1.234\n\nbest_isozyme_for_smoment = argmax(\n    smoment_isozyme_speed(gene_mass_function),\n    my_isozyme_vector,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.smoment_isozyme_speed-Tuple{Isozyme, Any}","page":"Utilities","title":"COBREXA.smoment_isozyme_speed","text":"smoment_isozyme_speed(isozyme::Isozyme, gene_product_molar_mass) -> Any\n\n\nCompute a \"score\" for picking the most viable isozyme for make_smoment_model, based on maximum kcat divided by relative mass of the isozyme. This is used because sMOMENT algorithm can not handle multiple isozymes for one reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Macro-generated-functions-and-internal-helpers","page":"Utilities","title":"Macro-generated functions and internal helpers","text":"","category":"section"},{"location":"functions/utils/","page":"Utilities","title":"Utilities","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"macros\", file), readdir(\"../src/base/macros\"))","category":"page"},{"location":"functions/utils/#COBREXA.@_change_bounds_fn-Tuple{Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_change_bounds_fn","text":"@_change_bounds_fn ModelType IdxType [plural] [inplace] begin ... end\n\nA helper for creating simple bounds-changing function similar to change_bounds.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA._inherit_model_methods_impl-Tuple{Any, Symbol, Any, Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA._inherit_model_methods_impl","text":"_inherit_model_methods_impl(source, mtype::Symbol, arglist, access, fwdlist, fns...) -> Expr\n\n\nA helper backend for @_inherit_model_methods and @_inherit_model_methods_fn.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.@_inherit_model_methods-Tuple{Symbol, Any, Symbol, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_inherit_model_methods","text":"Generates trivial accessor functions listed in fns for a model that is wrapped in type mtype as field member.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA.@_inherit_model_methods_fn-Tuple{Symbol, Any, Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_inherit_model_methods_fn","text":"A more generic version of @_inherit_model_methods that accesses the \"inner\" model using an accessor function name.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA.@_remove_fn-Tuple{Any, Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_remove_fn","text":"@ _remove_fn objname ModelType IndexType [plural] [inplace] begin ... end\n\nA helper for creating functions that follow the remove_objname template, such as remove_metabolites and remove_reaction.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA.@_serialized_change_unwrap-Tuple{Symbol}","page":"Utilities","title":"COBREXA.@_serialized_change_unwrap","text":"@_serialized_change_unwrap function\n\nCreates a simple wrapper structure that calls the function transparently on the internal precached model. The internal type is returned (otherwise this would break the consistency of serialization).\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#Logging-and-debugging-helpers","page":"Utilities","title":"Logging and debugging helpers","text":"","category":"section"},{"location":"functions/utils/","page":"Utilities","title":"Utilities","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"logging\", file), readdir(\"../src/base/logging\"))","category":"page"},{"location":"functions/utils/#COBREXA.log_io","page":"Utilities","title":"COBREXA.log_io","text":"log_io(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of messages and warnings from model input/output.\n\n\n\n\n\n","category":"function"},{"location":"functions/utils/#COBREXA.log_models","page":"Utilities","title":"COBREXA.log_models","text":"log_models(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of model-related messages.\n\n\n\n\n\n","category":"function"},{"location":"functions/utils/#COBREXA.log_perf","page":"Utilities","title":"COBREXA.log_perf","text":"log_perf(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of performance-related tracing information.\n\n\n\n\n\n","category":"function"},{"location":"functions/utils/#COBREXA.@_make_logging_tag-Tuple{Symbol, String}","page":"Utilities","title":"COBREXA.@_make_logging_tag","text":"This creates a group of functions that allow masking out topic-related logging actions. A call that goes as follows:\n\n@_make_logging_tag XYZ\n\ncreates the following tools:\n\nglobal variable _XYZ_log_enabled defaulted to false\nfunction log_XYZ that can be called to turn the logging on/off\na masking macro @_XYZ_log that can be prepended to commands that should only happen if the logging of tag XYZ is enabled.\n\nThe masking macro is then used as follows:\n\n@_XYZ_log @info \"This is the extra verbose information you wanted!\" a b c\n\nThe user can direct logging with these:\n\nlog_XYZ()\nlog_XYZ(false)\n\ndoc should be a name of the stuff that is being printed if the corresponding log_XYZ() is enabled â€“ it is used to create a friendly documentation for the logging switch. In this case it could say \"X, Y and Z-related messages\".\n\n\n\n\n\n","category":"macro"},{"location":"functions/base/#Base-functions","page":"Base functions","title":"Base functions","text":"","category":"section"},{"location":"functions/base/","page":"Base functions","title":"Base functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", file), readdir(\"../src/base\"))","category":"page"},{"location":"functions/base/#COBREXA._constants","page":"Base functions","title":"COBREXA._constants","text":"A named tuple that contains the magic values that are used globally for whatever purposes.\n\n\n\n\n\n","category":"constant"},{"location":"functions/base/#COBREXA.flux_dict-Tuple{MetabolicModel, Any}","page":"Base functions","title":"COBREXA.flux_dict","text":"flux_dict(model::MetabolicModel, opt_model) -> Union{Nothing, Dict{String, Float64}}\n\n\nReturns the fluxes of the model as a reaction-keyed dictionary, if solved.\n\nExample\n\nflux_dict(model, flux_balance_analysis(model, ...))\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.flux_dict-Tuple{MetabolicModel}","page":"Base functions","title":"COBREXA.flux_dict","text":"flux_dict(model::MetabolicModel) -> COBREXA.var\"#173#174\"\n\n\nA pipeable variant of flux_dict.\n\nExample\n\nflux_balance_analysis(model, ...) |> flux_dict(model)\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.flux_vector-Tuple{MetabolicModel, Any}","page":"Base functions","title":"COBREXA.flux_vector","text":"flux_vector(model::MetabolicModel, opt_model) -> Union{Nothing, Vector{Float64}}\n\n\nReturns a vector of fluxes of the model, if solved.\n\nExample\n\nflux_vector(flux_balance_analysis(model, ...))\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.get_optmodel_bounds-Tuple{Any}","page":"Base functions","title":"COBREXA.get_optmodel_bounds","text":"get_optmodel_bounds(opt_model) -> Tuple{Any, Any}\n\n\nReturns vectors of the lower and upper bounds of opt_model constraints, where opt_model is a JuMP model constructed by e.g. make_optimization_model or flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.is_solved-Tuple{Any}","page":"Base functions","title":"COBREXA.is_solved","text":"is_solved(opt_model) -> Bool\n\n\nReturn true if opt_model solved successfully (solution is optimal or locally optimal).  Return false if any other termination status is reached. Termination status is defined in the documentation of JuMP.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.make_optimization_model-Tuple{MetabolicModel, Any}","page":"Base functions","title":"COBREXA.make_optimization_model","text":"make_optimization_model(model::MetabolicModel, optimizer; sense) -> JuMP.Model\n\n\nConvert MetabolicModels to a JuMP model, place objectives and the equality constraint.\n\nHere coupling means inequality constraints coupling multiple variables together.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.optimize_objective-Tuple{Any}","page":"Base functions","title":"COBREXA.optimize_objective","text":"optimize_objective(opt_model) -> Union{Nothing, Float64}\n\n\nShortcut for running JuMP optimize! on a model and returning the objective value, if solved.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.set_optmodel_bound!-Tuple{Any, Any}","page":"Base functions","title":"COBREXA.set_optmodel_bound!","text":"set_optmodel_bound!(vidx, opt_model; lb, ub) -> Bool\n\n\nHelper function to set the bounds of a variable in the model. Internally calls set_normalized_rhs from JuMP. If the bounds are set to nothing, they will not be changed.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.solved_objective_value-Tuple{Any}","page":"Base functions","title":"COBREXA.solved_objective_value","text":"solved_objective_value(opt_model) -> Union{Nothing, Float64}\n\n\nReturns the current objective value of a model, if solved.\n\nExample\n\nsolved_objective_value(flux_balance_analysis(model, ...))\n\n\n\n\n\n","category":"method"},{"location":"distributed/4_serialized/#Faster-model-distribution","page":"Faster model distribution","title":"Faster model distribution","text":"","category":"section"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"When working with a large model, it may happen that the time required to send the model to the worker nodes takes a significant portion of the total computation time.","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"You can use Julia serialization to prevent this. Because the shared filesystem is a common feature of most HPC installations around, you can very easily utilize it to broadcast a serialized version of the model to all worker nodes. In COBREXA, that functionality is wrapped in a Serialized model type, which provides a tiny abstraction around this functionality:","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"you call serialize_model before you start your analysis to place the model to the shared storage (and, possibly, free the RAM required to hold the model)\nthe freshly created Serialized model type is tiny â€“ it only stores the file name where the model data can be found\nall analysis functions automatically call precache! on the model to get the actual model data loaded before the model is used, which transparently causes the loading from the shared media, and thus the fast distribution","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"The use is pretty straightforward. After you have your model loaded, you simply convert it to the small serialized form:","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"model = load_model(...)\n# ... prepare the model ...\n\ncachefile = tempname(\".\")\nsm = serialize_model(model, cachefile)","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"Then, the analysis functions is run as it would be with a \"normal\" model:","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"screen(sm, ...)","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"After the analysis is done, it is useful to remove the temporary file:","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"rm(cachefile)","category":"page"},{"location":"distributed/4_serialized/","page":"Faster model distribution","title":"Faster model distribution","text":"warn: Caveats of working with temporary files\nAlways ensure that the temporary filenames are unique â€“ if there are two jobs running in parallel and both use the same filename to cache and distribute a model, both are likely going to crash, and almost surely produce wrong results.  At the same time, avoid creating the temporary files in the default location of /tmp/*, as the temporary folder is local, thus seldom shared between HPC nodes.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/12_mmdf.jl\"","category":"page"},{"location":"examples/12_mmdf/#Maximum-minimum-driving-force-analysis","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"","category":"section"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"Here, we use the max-min driving force analysis (MMDF) to find optimal concentrations for the metabolites in glycolysis to ensure that the smallest driving force across all the reactions in the model is as large as possible. The method is described in more detail by Flamholz, et al., \"Glycolytic strategy as a tradeoff between energy yield and protein cost.\", Proceedings of the National Academy of Sciences, 2013.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"We start as usual, with loading models and packages:","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"using COBREXA, GLPK\n\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"For MMDF to work, we need thermodynamic data about the involved reactions.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"In particular, we will use reaction Gibbs free energies (Î”Gâ°) that can be obtained e.g. from eQuilibrator (possibly using the existing Julia wrapper that allows you to automate this step in Julia).","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"Here, we have gathered a dictionary that maps the reaction IDs to calculated Gibbs free energy of reaction for each metabolic reaction (including the transporters). The units of the measurements are not crucial for the computation, but we use the usual kJ/mol for consistency.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"reaction_standard_gibbs_free_energies = Dict(\n    \"ACALD\" => -21.26,\n    \"PTAr\" => 8.65,\n    \"ALCD2x\" => 17.47,\n    \"PDH\" => -34.24,\n    \"PYK\" => -24.48,\n    \"CO2t\" => 0.00,\n    \"MALt2_2\" => -6.83,\n    \"CS\" => -39.33,\n    \"PGM\" => -4.47,\n    \"TKT1\" => -1.49,\n    \"ACONTa\" => 8.46,\n    \"GLNS\" => -15.77,\n    \"ICL\" => 9.53,\n    \"FBA\" => 23.37,\n    \"SUCCt3\" => -43.97,\n    \"FORt2\" => -3.42,\n    \"G6PDH2r\" => -7.39,\n    \"AKGDH\" => -28.23,\n    \"TKT2\" => -10.31,\n    \"FRD7\" => 73.61,\n    \"SUCOAS\" => -1.15,\n    \"FBP\" => -11.60,\n    \"ICDHyr\" => 5.39,\n    \"AKGt2r\" => 10.08,\n    \"GLUSy\" => -47.21,\n    \"TPI\" => 5.62,\n    \"FORt\" => 13.50,\n    \"ACONTb\" => -1.62,\n    \"GLNabc\" => -30.19,\n    \"RPE\" => -3.38,\n    \"ACKr\" => 14.02,\n    \"THD2\" => -33.84,\n    \"PFL\" => -19.81,\n    \"RPI\" => 4.47,\n    \"D_LACt2\" => -3.42,\n    \"TALA\" => -0.94,\n    \"PPCK\" => 10.65,\n    \"ACt2r\" => -3.41,\n    \"NH4t\" => -13.60,\n    \"PGL\" => -25.94,\n    \"NADTRHD\" => -0.01,\n    \"PGK\" => 19.57,\n    \"LDH_D\" => 20.04,\n    \"ME1\" => 12.08,\n    \"PIt2r\" => 10.41,\n    \"ATPS4r\" => -37.57,\n    \"PYRt2\" => -3.42,\n    \"GLCpts\" => -45.42,\n    \"GLUDy\" => 32.83,\n    \"CYTBD\" => -59.70,\n    \"FUMt2_2\" => -6.84,\n    \"FRUpts2\" => -42.67,\n    \"GAPD\" => 0.53,\n    \"H2Ot\" => 0.00,\n    \"PPC\" => -40.81,\n    \"NADH16\" => -80.37,\n    \"PFK\" => -18.54,\n    \"MDH\" => 25.91,\n    \"PGI\" => 2.63,\n    \"O2t\" => 0.00,\n    \"ME2\" => 12.09,\n    \"GND\" => 10.31,\n    \"SUCCt2_2\" => -6.82,\n    \"GLUN\" => -14.38,\n    \"ETOHt2r\" => -16.93,\n    \"ADK1\" => 0.38,\n    \"ACALDt\" => 0.00,\n    \"SUCDi\" => -73.61,\n    \"ENO\" => -3.81,\n    \"MALS\" => -39.22,\n    \"GLUt2r\" => -3.49,\n    \"PPS\" => -6.05,\n    \"FUM\" => -3.42,\n);\nnothing #hide","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"COBREXA implementation of MMDF enforces that Î”áµ£G .* v â‰¤ 0 (where v is the flux solution).  This is slightly less restrictive than the original formulation of MMDF, where all fluxes are enforced to be positive; instead, the COBREXA solution needs a pre-existing thermodynamically consistent solution that is used as a reference.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"We can generate a well-suited reference solution using e.g. the loopless FBA:","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"flux_solution = flux_balance_analysis_dict(\n    model,\n    GLPK.Optimizer;\n    modifications = [add_loopless_constraints()],\n)","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"We can now run the MMDF.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"In the call, we specify the metabolite IDs of protons and water so that they are omitted from concentration calculations. Also, the water transport reaction should typically also be ignored. Additionally, we can fix the concentration ratios of certain metabolites directly.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"The reason for removing the protons and water from the concentration calculations is because the Gibbs free energies of biochemical reactions are measured at constant pH in aqueous environments. Allowing the model to change the pH would break the assumptions about validity of the thermodynamic measurements.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"sol = max_min_driving_force(\n    model,\n    reaction_standard_gibbs_free_energies,\n    GLPK.Optimizer;\n    flux_solution = flux_solution,\n    proton_ids = [\"h_c\", \"h_e\"],\n    water_ids = [\"h2o_c\", \"h2o_e\"],\n    concentration_ratios = Dict(\n        (\"atp_c\", \"adp_c\") => 10.0,\n        (\"nadh_c\", \"nad_c\") => 0.13,\n        (\"nadph_c\", \"nadp_c\") => 1.3,\n    ),\n    concentration_lb = 1e-6, # 1 uM\n    concentration_ub = 0.1, # 100 mM\n    ignore_reaction_ids = [\n        \"H2Ot\", # ignore water transport\n    ],\n)\n\nsol.mmdf","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"note: Note: transporters\nTransporters can be included in MMDF analysis, however water and proton   transporters must be excluded explicitly in ignore_reaction_ids.   In turn, the Î”áµ£G for these transport reactions   will always be 0. If you do not exclude the transport of the metabolites,   the MMDF will likely only have a zero solution.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"Finally, we show how the concentrations are optimized to ensure that each reaction proceeds \"down the hill\" (Î”áµ£G < 0). We can explore the glycolysis pathway reactions:","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"glycolysis_pathway =\n    [\"GLCpts\", \"PGI\", \"PFK\", \"FBA\", \"TPI\", \"GAPD\", \"PGK\", \"PGM\", \"ENO\", \"PYK\"]","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"We additionally scale the fluxes according to their stoichiometry in the pathway. From the output, we can clearly see that metabolite concentrations play a large role in ensuring the thermodynamic consistency of in vivo reactions.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"using CairoMakie\n\nstandard_dg = cumsum([\n    reaction_standard_gibbs_free_energies[rid] * flux_solution[rid] for\n    rid in glycolysis_pathway\n]);\noptimal_dg =\n    cumsum([sol.dg_reactions[rid] * flux_solution[rid] for rid in glycolysis_pathway]);\n\nf = Figure();\nax = Axis(f[1, 1], ylabel = \"Cumulative Î”G\", xticks = (1:10, glycolysis_pathway));\nlines!(ax, 1:10, standard_dg .- first(standard_dg), color = :blue, label = \"Î”Gâ°\");\nlines!(ax, 1:10, optimal_dg .- first(optimal_dg), color = :red, label = \"MMDF solution\");\naxislegend(ax)\nf","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"tip: Thermodynamic variability\nAs with normal flux variability, thermodynamic constraints in a model also allow a certain amount of parameter selection freedom. Specialized max_min_driving_force_variability can be used to explore the thermodynamic solution space more easily.","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"","category":"page"},{"location":"examples/12_mmdf/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/10_crowding.jl\"","category":"page"},{"location":"examples/10_crowding/#FBA-with-crowding","page":"FBA with crowding","title":"FBA with crowding","text":"","category":"section"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"Here we will use flux_balance_analysis to explore the metabolism of the toy E. coli model that additionally respects common protein crowding constraints. In particular, the model is limited by the amount of protein required to run certain reactions. If that data is available, the predictions are accordingly more realistic. See Beg, et al., \"Intracellular crowding defines the mode and sequence of substrate uptake by Escherichia coli and constrains its metabolic activity.\", Proceedings of the National Academy of Sciences,2007 for more details.","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"As usual, the same model modification can be transparently used with many other analysis functions, including flux_variability_analysis and parsimonious_flux_balance_analysis.","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"Let's starting with loading the models and packages.","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, Tulip\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"To describe the protein crowding, each of the enzymes that catalyze the reactions gets an associated weight per unit of reaction conversion rate. The total sum of all weights multiplied by the flux in the model must be lower than 1.","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"The weights are prepared in a dictionary; for simplicity we assume that the relative weight of all enzymes is random between 0.002 and 0.005. enzymes are of the same size. Reactions that are not present in the dictionary (typically exchanges) are ignored.","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"import Random\nRandom.seed!(1) # for repeatability of random numbers below\n\nrid_crowding_weight = Dict(\n    rid => 0.002 + 0.003 * rand() for rid in reactions(model) if\n    !looks_like_biomass_reaction(rid) && !looks_like_exchange_reaction(rid)\n)","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"With this, the crowding constraints are added with modification add_crowding_constraints:","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"loopless_crowding_fluxes = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [add_crowding_constraints(rid_crowding_weight)],\n)","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"flux_summary(loopless_crowding_fluxes)","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"","category":"page"},{"location":"examples/10_crowding/","page":"FBA with crowding","title":"FBA with crowding","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/07_restricting_reactions.jl\"","category":"page"},{"location":"examples/07_restricting_reactions/#Restricting-and-disabling-individual-reactions","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"","category":"section"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"Here, we show several methods how to explore the effect of disabling or choking the reactions in the models.","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"First, download the demonstration data and load the packages as usual:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, GLPK\n\nmodel = load_model(StandardModel, \"e_coli_core.json\")","category":"page"},{"location":"examples/07_restricting_reactions/#Disabling-a-reaction","page":"Restricting and disabling individual reactions","title":"Disabling a reaction","text":"","category":"section"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"There are several possible ways to disable a certain reaction in the model. The easiest way is to use change_bound or change_bounds to create a variant of the model that has the corresponding bounds modified (or, alternatively, a pipeable \"variant\" version with_changed_bound).","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"Alternatively, you could utilize change_constraint as a modification that acts directly on the JuMP optimization model. That may be useful if you first apply some kind of complicated constraint scheme modification, such as add_loopless_constraints.","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"In turn, in the simple case, the following 2 ways of disabling the FBA reaction are equivalent. The first, making a variant of the model structure, might be slightly preferred because it better composes with other changes; the second does not compose as well but may be more efficient (and thus faster) in certain situations:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"flux1 = flux_balance_analysis_vec(\n    model |> with_changed_bound(\"FBA\", lower = 0.0, upper = 0.0),\n    GLPK.Optimizer,\n);\n\nflux2 = flux_balance_analysis_vec(\n    model,\n    GLPK.Optimizer,\n    modifications = [change_constraint(\"FBA\", lb = 0.0, ub = 0.0)],\n);\nnothing #hide","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"The solutions should not differ a lot:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"sum((flux1 .- flux2) .^ 2)","category":"page"},{"location":"examples/07_restricting_reactions/#Restricting-a-reaction","page":"Restricting and disabling individual reactions","title":"Restricting a reaction","text":"","category":"section"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"Quite naturally, you can restruct the reaction to a limited flow, simulating e.g. nutrient deficiency:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"original_flux = flux_balance_analysis_dict(model, GLPK.Optimizer);\n\nrestricted_flux = flux_balance_analysis_dict(\n    model,\n    GLPK.Optimizer,\n    modifications = [change_constraint(\"EX_o2_e\", lb = -0.1, ub = 0.0)],\n);\nnothing #hide","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"The growth in the restricted case is, expectably, lower than the original one:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"original_flux[\"BIOMASS_Ecoli_core_w_GAM\"], restricted_flux[\"BIOMASS_Ecoli_core_w_GAM\"]","category":"page"},{"location":"examples/07_restricting_reactions/#Screening-for-sensitive-and-critical-reactions","page":"Restricting and disabling individual reactions","title":"Screening for sensitive and critical reactions","text":"","category":"section"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"Using higher-order analysis scheduling functions (in particular screen), you can easily determine which reactions play a crucial role for the model viability and which are not very important.","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"We can take all reactions where the flux is not zero:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"running_reactions = [(rid, x) for (rid, x) in original_flux if abs(x) > 1e-3]","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"...and choke these reactions to half that flux, computing the relative loss of the biomass production::","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"screen(\n    model,\n    variants = [\n        [with_changed_bound(rid, lower = -0.5 * abs(x), upper = 0.5 * abs(x))] for\n        (rid, x) in running_reactions\n    ],\n    args = running_reactions,\n    analysis = (m, rid, _) ->\n        rid =>\n            flux_balance_analysis_dict(m, GLPK.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"] /\n            original_flux[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"(You may notice that restricting the ATP maintenance pseudo-reaction (ATPM) had a mildly surprising effect of actually increasing the biomass production by a few percent.  That is because the cells are not required to produce ATP to survive and may invest the nutrients and energy elsewhere.)","category":"page"},{"location":"examples/07_restricting_reactions/#Screening-with-reaction-combinations","page":"Restricting and disabling individual reactions","title":"Screening with reaction combinations","text":"","category":"section"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"The same analysis can be scaled up to screen for combinations of critical reactions, giving possibly more insight into the redundancies in the model:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"running_reaction_combinations = [\n    (rid1, rid2, x1, x2) for (rid1, x1) in running_reactions,\n    (rid2, x2) in running_reactions\n]\n\nbiomass_mtx = screen(\n    model,\n    variants = [\n        [\n            with_changed_bound(rid1, lower = -0.5 * abs(x1), upper = 0.5 * abs(x1)),\n            with_changed_bound(rid2, lower = -0.5 * abs(x2), upper = 0.5 * abs(x2)),\n        ] for (rid1, rid2, x1, x2) in running_reaction_combinations\n    ],\n    analysis = m ->\n        flux_balance_analysis_dict(m, GLPK.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"] /\n        original_flux[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"Finally, let's plot the result:","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"using CairoMakie, Clustering\n\norder =\n    hclust([\n        sum((i .- j) .^ 2) for i in eachcol(biomass_mtx), j in eachcol(biomass_mtx)\n    ]).order\n\nlabels = first.(running_reactions)[order];\npositions = collect(eachindex(labels))\n\nf = Figure(fontsize = 8)\nax = Axis(f[1, 1], xticks = (positions, labels), yticks = (positions, labels))\nheatmap!(ax, positions, positions, biomass_mtx[order, order])\nax.xticklabelrotation = Ï€ / 3\nax.xticklabelalign = (:right, :center)\nax.yticklabelrotation = Ï€ / 6\nax.yticklabelalign = (:right, :center)\nf","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"Remember that screen can be parallelized just by supplying worker IDs. Use that to gain significant speedup with analyses of larger models.","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"","category":"page"},{"location":"examples/07_restricting_reactions/","page":"Restricting and disabling individual reactions","title":"Restricting and disabling individual reactions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/04_core_model.jl\"","category":"page"},{"location":"examples/04_core_model/#CoreModel-usage","page":"CoreModel usage","title":"CoreModel usage","text":"","category":"section"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"In this tutorial we will introduce COBREXA's CoreModel and CoreModelCoupled. We will use E. coli's toy model to start with.","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA","category":"page"},{"location":"examples/04_core_model/#Loading-a-CoreModel","page":"CoreModel usage","title":"Loading a CoreModel","text":"","category":"section"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"model = load_model(CoreModel, \"e_coli_core.xml\") # we specifically want to load a CoreModel from the model file","category":"page"},{"location":"examples/04_core_model/#Basic-analysis-on-CoreModel","page":"CoreModel usage","title":"Basic analysis on CoreModel","text":"","category":"section"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"As before, for optimization based analysis we need to load an optimizer. Here we will use Tulip.jl to optimize the linear programs of this tutorial. Refer to the examples of analysis and analysis modifications for details and explanations.","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"using Tulip\n\ndict_sol = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"),\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12),\n        change_constraint(\"R_EX_o2_e\"; lb = 0, ub = 0),\n    ],\n)","category":"page"},{"location":"examples/04_core_model/#Structure-of-CoreModel","page":"CoreModel usage","title":"Structure of CoreModel","text":"","category":"section"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"CoreModel is optimized for analysis of models that utilizes the matrix, linearly-algebraic \"view\" of the models. It stores data in a sparse format wherever possible.","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"The structure contains fields that contain the expectable model elements:","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"fieldnames(CoreModel)","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"model.S","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"Contrary to the usual implementations, the model representation does not contain reaction coupling boudns; these can be added to any model by wrapping it with CoreCoupling. You may also use the prepared CoreModelCoupled to get a version of CoreModel with this coupling.","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"","category":"page"},{"location":"examples/04_core_model/","page":"CoreModel usage","title":"CoreModel usage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"concepts/#Core-concepts-and-extension-guide","page":"Contents","title":"Core concepts and extension guide","text":"","category":"section"},{"location":"concepts/","page":"Contents","title":"Contents","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"concepts\", join=true))\nDepth = 2","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/08_pfba.jl\"","category":"page"},{"location":"examples/08_pfba/#Parsimonious-flux-balance-analysis-(pFBA)","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"","category":"section"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"Parsimonious flux balance analysis attempts to find a realistic flux of a model, by trying to minimize squared sum of all fluxes while maintaining the reached optimum. COBREXA.jl implements it in function parsimonious_flux_balance_analysis (accompanied by vector- and dictionary-returning variants parsimonious_flux_balance_analysis_vec and parsimonious_flux_balance_analysis_dict).","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"As usual, we demonstrate the functionality on the E. coli model:","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, Tulip, OSQP\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"Because the parsimonious objective is quadratic, we need a an optimizer capable of solving quadratic programs.","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"As the simplest choice, we can use OSQP.jl, but any any JuMP.jl-supported optimizer that supports quadratic programming will work.","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"note: Note: OSQP can be sensitive\nWe recommend reading the documentation of OSQP before using it, since   it may give inconsistent results depending on what settings   you use. Commercial solvers like Gurobi, Mosek, CPLEX, etc.   require less user engagement.","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"Running of basic pFBA is perfectly analogous to running of FBA and other analyses. We add several modifications that improve the solution (using functions silence, and change_optimizer_attribute), and fix the glucose exchange (using change_constraint) in order to get a more reasonable result:","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"fluxes = parsimonious_flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [\n        silence, # optionally silence the optimizer (OSQP is very verbose by default)\n        change_optimizer_attribute(\"polish\", true), # tell OSQP to invest time into improving the precision of the solution\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12), # fix glucose consumption rate\n    ],\n)","category":"page"},{"location":"examples/08_pfba/#Using-different-optimizers-for-linear-and-quadratic-problems","page":"Parsimonious flux balance analysis (pFBA)","title":"Using different optimizers for linear and quadratic problems","text":"","category":"section"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"It is quite useful to use specialized optimizers for specialized tasks in pFBA. In particular, one would usually require to get a precise solution from the linear programming part (where the precision is achievable), and trade off a little precision for vast improvements in computation time in the quadratic programming part.","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"In pFBA, we can use the modifications and qp_modifications parameters to switch and parametrize the solvers in the middle of the process, which allows us to implement precisely that improvement. We demonstrate the switching on a vector-returning variant of pFBA:","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"flux_vector = parsimonious_flux_balance_analysis_vec(\n    model,\n    Tulip.Optimizer; # start with Tulip\n    modifications = [\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12),\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500), # we may change Tulip-specific attributes here\n    ],\n    qp_modifications = [\n        change_optimizer(OSQP.Optimizer), # now switch to OSQP (Tulip wouldn't be able to finish the computation)\n        change_optimizer_attribute(\"polish\", true), # get an accurate solution, see OSQP's documentation\n        silence, # and make it quiet.\n    ],\n)","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"","category":"page"},{"location":"examples/08_pfba/","page":"Parsimonious flux balance analysis (pFBA)","title":"Parsimonious flux balance analysis (pFBA)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/03b_accessors.jl\"","category":"page"},{"location":"examples/03b_accessors/#Generic-accessors","page":"Generic accessors","title":"Generic accessors","text":"","category":"section"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"To prevent the complexities of object representation, COBREXA.jl uses a set of generic interface functions that can extract various important information from any supported model type. This approach ensures that the analysis functions can work on any data.","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"For example, you can check the reactions and metabolites contained in any model type (SBMLModel, JSONModel, CoreModel, StandardModel, and any other) using the same accessor:","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"using COBREXA\n\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n\njs = load_model(\"e_coli_core.json\")\nreactions(js)","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"std = convert(CoreModel, js)\nreactions(std)","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"All accessors allow systematic access to information about reactions, stoichiometry, metabolite properties and chemistry, genes, and various model annotations.","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"The most notable ones include:","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"reactions, metabolites and genes return respective vectors of identifiers of reactions, metabolites and genes present in the model,\nstoichiometry returns the S matrix\nbalance returns the right-hand vector of the linear model in form Ax=b\nbounds return lower and upper bounds of reaction rates\nmetabolite_charge and metabolite_formula return details about metabolites\nobjective returns the objective of the model (usually labeled as c)\nreaction_gene_association describes the dependency of a reaction on gene products","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"A complete, up-to-date list of accessors can be always generated using methodswith:","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"using InteractiveUtils\n\naccessors = [\n    x.name for x in methodswith(MetabolicModel, COBREXA) if\n    endswith(String(x.file), \"MetabolicModel.jl\")\n]\n\nprintln.(accessors);\nnothing #hide","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"note: Note: Not all accessors may be implemented for all the models\nIt is possible that not all the accessors are implemented for all the model   types. If this is the case, usually nothing or an empty data structure is   returned. If you need a specific accessor, just overload the function you require!","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"","category":"page"},{"location":"examples/03b_accessors/","page":"Generic accessors","title":"Generic accessors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/examples/05b_fba_mods.jl\"","category":"page"},{"location":"examples/05b_fba_mods/#Extending-FBA-with-modifications","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"","category":"section"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"It is often desirable to add a slight modification to the problem before performing the analysis, to see e.g. differences of the model behavior caused by the change introduced.","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"First, let us load everything that will be required:","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA, GLPK, Tulip\n\nmodel = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"COBREXA.jl supports many modifications, which include changing objective sense, optimizer attributes, flux constraints, optimization objective, reaction and gene knockouts, and others. These modifications are applied to the optimization built within the supplied optimizer (in this case GLPK) in order as they are specified. User needs to manually ensure that the modification ordering is sensible.","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"The following example applies multiple different modifications to the E. coli core model:","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"fluxes = flux_balance_analysis_dict(\n    model,\n    GLPK.Optimizer;\n    modifications = [ # modifications are applied in order\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"), # maximize production\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12), # fix an exchange rate\n        knockout([\"b0978\", \"b0734\"]), # knock out two genes\n        change_optimizer(Tulip.Optimizer), # ignore the above optimizer and switch to Tulip\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 1000), # customize Tulip\n        change_sense(MAX_SENSE), # explicitly tell Tulip to maximize the objective\n    ],\n)","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"","category":"page"},{"location":"examples/05b_fba_mods/","page":"Extending FBA with modifications","title":"Extending FBA with modifications","text":"This page was generated using Literate.jl.","category":"page"},{"location":"concepts/2_modifications/#Writing-custom-optimizer-modifications","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"","category":"section"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"Functions such as flux_balance_analysis internally create a JuMP model out of the MetabolicModel, and run the optimizer on that. To be able to make some modifications on the JuMP model before the optimizer is started, most of the functions accept a modifications argument, where one can list callbacks that do the changes to the prepared optimization model.","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"The callbacks available in COBREXA.jl include functions that may help with tuning the optimizer, or change the raw values in the linear model, such as:","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"change_constraint and change_objective\nchange_sense, change_optimizer, change_optimizer_attribute\nsilence\nknockout, add_crowding_constraints\nadd_loopless_constraints","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"Compared to the variant system and the model wrappers, optimizer modifications are slightly more powerful (they can do anything they want with the optimizer!), but do not compose well â€“ it is very easy to break the semantics of the model or erase the previous changes by carelessly adding the modifications.","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"Here, we show how to construct the modifications. Their semantics is similar to the variant-generating functions, which receive a model (of type MetabolicModel), and are expected to create another (modified) model. Contrary to that, modifications receive both the MetabolicModel and a JuMP model structure, and are expected to cause a side effect on the latter.","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"A trivial modification that does not do anything can thus be written as:","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"change_nothing() = (model, opt_model) -> println(\"Not touching anything.\")","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"and applied as:","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"flux_balance_analysis(model, GLPK.Optimizer, modifications=[change_nothing()])\nflux_variability_analysis(model, GLPK.Optimizer, modifications=[change_nothing()])","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"At the call time of the modifier function, opt_model is usually the model that was returned from make_optimization_model â€“ refer to the function for actual model layout. The function can freely change anything in that model.","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"For demonstration, we show how to implement an impractical but illustrative modification that adds an extra constraint that makes sure that all fluxes sum to a certain value:","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"using JuMP\n\nadd_sum_constraint(total::Float64) =\n    (model, opt_model) -> begin\n        v = opt_model[:x]  # retrieve the variable vector\n        @constraint(opt_model, total, sum(v) == total)  # create the constraint using JuMP macro\n    end","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"The modification can be used at the expectable position:","category":"page"},{"location":"concepts/2_modifications/","page":"Writing custom optimizer modifications","title":"Writing custom optimizer modifications","text":"v = flux_balance_analysis_vec(\n    load_model(\"e_coli_core.xml\"),\n    GLPK.Optimizer,\n    modifications = [add_sum_constraint(100.0)])\n\nsum(v)   # should print ~100.0","category":"page"},{"location":"distributed/2_parallel/#Local-parallel-processing","page":"Local parallel processing","title":"Local parallel processing","text":"","category":"section"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"To run an analysis in parallel, you first need to load the Distributed package and add a few worker processes. For example, you may start 5 local processes (that may utilize 5 CPUs) like this:","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"using Distributed\naddprocs(5)","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"note: `Distributed.jl` installation\nDistributed.jl usually comes pre-installed with Julia distribution, but you may still need to \"enable\" it by typing ] add Distributed.","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"You may check that the workers are really there, using workers(). In this case, it should give you a vector of worker IDs, very likely equal to [2,3,4,5,6].","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"Each of the processes contains a self-sufficient image of Julia that can act independently; in turn the additional processes also consume some memory. Each process with loaded COBREXA.jl and a simple solver such as GLPK may consume around 500MB of RAM, which should be taken into account when planning the analysis scale.","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"Packages (COBREXA and your selected solver) must be loaded at all processes, which you can ensure using the \"everywhere\" macro:","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"@everywhere using COBREXA, GLPK","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"Utilizing the prepared worker processes is then straightforward: You pass the list of workers to the selected analysis function using the workers keyword argument, and the parallel processing is automatically orchestrated for you.","category":"page"},{"location":"distributed/2_parallel/","page":"Local parallel processing","title":"Local parallel processing","text":"model = load_model(\"e_coli_core.xml\")\nresult = flux_variability_analysis(model, GLPK.Optimizer; workers=workers())","category":"page"},{"location":"distributed/#Parallel,-distributed-and-HPC-processing","page":"Contents","title":"Parallel, distributed and HPC processing","text":"","category":"section"},{"location":"distributed/","page":"Contents","title":"Contents","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"distributed\", join=true))\nDepth = 2","category":"page"},{"location":"distributed/1_functions/#Parallel-processing-overview","page":"Parallel processing overview","title":"Parallel processing overview","text":"","category":"section"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Distributed processing in Julia is represented mainly by the package Distributed.jl.","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"COBREXA.jl is able to utilize this existing system to almost transparently run the large parallelizable analyses on multiple CPU cores and multiple computers connected through the network. Ultimately, the approach scales to thousands of computing nodes in large HPC facilities.","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"You may run your analyses in parallel to gain speed-ups. The usual workflow in COBREXA.jl is quite straightforward:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Import the Distributed package and add worker processes, e.g. using addprocs.\nPick an analysis function that can be parallelized (such as screen or flux_variability_analysis) and prepare it to work on your data.\nPass the desired set of worker IDs to the function using workers= argument, in the simplest form using e.g. screen(...,  workers=workers()).\nWorker communication will be managed automatically, and you will get results \"as usual\".","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Specific documentation is available about running parallel analysis locally and running distributed analysis in HPC clusters.","category":"page"},{"location":"distributed/1_functions/#Functions-that-support-parallelization","page":"Parallel processing overview","title":"Functions that support parallelization","text":"","category":"section"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"As of COBREXA 1.3, the list of functions that accept the worker argument is as follows:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"affine_hit_and_run sampling, together with warmup_from_variability\nflux_variability_analysis\nmax_min_driving_force\nobjective_envelope\nscreen\nscreen_optmodel_modifications","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Notably, the screening functions are reused to run many other kinds of analyses which, in turn, inherit the parallelizability. This includes a wide range of functionality, including analyses such as:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"single and multiple gene deletions (and other genetic modifications),\nmodifications of the reaction spectrum (e.g., disabling reactions)\nadvanced envelope-scanning analyses,\ngrowth media exploration (e.g., metabolite depletion)","category":"page"},{"location":"distributed/1_functions/#Mitigating-parallel-inefficiencies","page":"Parallel processing overview","title":"Mitigating parallel inefficiencies","text":"","category":"section"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Ideally, the speedup gained by parallel processing should be proportional to the amount of hardware you add as the workers. You should be aware of factors that reduce the parallel efficiency, which can be summarized as follows:","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"Parallelization within single runs of the linear solver is typically not supported (and if it is, it may be inefficient for usual problem sizes). You usually want to parallelize the analyzes that comprise multiple independent runs of the solvers.\nSome analysis function, such as flux_variability_analysis, have serial parts that can not be parallelized by default. Usually, you may avoid the inefficiency by precomputing the serial analysis parts without involving the cluster of the workers.\nRequirements for frequent worker communication may vastly reduce the efficiency of parallel processing; typically this happens if the time required for individual analysis steps is smaller than the network round-trip-time to the worker processes. Do not use unnecessary parallelization for small tasks.\nTransferring large amounts of data among workers may hamper parallel efficiency. Use the system of model variants to avoid transferring many similar models to the workers, and model serialization functionality to quickly distribute share large models to the workers.","category":"page"},{"location":"distributed/1_functions/","page":"Parallel processing overview","title":"Parallel processing overview","text":"note: Cost of the distribution and parallelization overhead\nBefore allocating extra resources into the distributed execution, always check that your tasks are properly parallelizable and sufficiently large to saturate your computation resources, so that the invested energy is not wasted. Amdahl's and Gustafson's laws can give you a better overview of the sources and consequences of the parallelization inefficiencies and the costs of the resulting overhead.","category":"page"},{"location":"quickstart/#Quick-start-guide","page":"COBREXA.jl in 10 minutes","title":"Quick start guide","text":"","category":"section"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"You can install COBREXA from Julia repositories. Start julia, press ] to switch to the Packaging environment, and type:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"add COBREXA","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"You also need to install your favorite solver supported by JuMP.jl (such as Gurobi, Mosek, CPLEX, GLPK, OSQP, etc., see a list here).  For example, you can install Tulip.jl solver by typing:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"add Tulip","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"Alternatively, you may use prebuilt Docker and Apptainer images.","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"If you are running COBREXA.jl for the first time, it is very likely that upon installing and importing the packages, your Julia installation will need to precompile their source code from the scratch. In fresh installations, the precompilation process should take less than 5 minutes.","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"When the packages are installed, switch back to the \"normal\" julia shell by pressing Backspace (the prompt should change color back to green). After that, you can download a SBML model from the internet and perform a flux balance analysis as follows:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"using COBREXA   # loads the package\nusing Tulip     # loads the optimization solver\n\n# download the model\ndownload(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\n# open the SBML file and load the contents\nmodel = load_model(\"e_coli_core.xml\")\n\n# run a FBA\nfluxes = flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"The variable fluxes will now contain a dictionary of the computed optimal flux of each reaction in the model:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"Dict{String,Float64} with 95 entries:\n  \"R_EX_fum_e\"    => 0.0\n  \"R_ACONTb\"      => 6.00725\n  \"R_TPI\"         => 7.47738\n  \"R_SUCOAS\"      => -5.06438\n  \"R_GLNS\"        => 0.223462\n  \"R_EX_pi_e\"     => -3.2149\n  \"R_PPC\"         => 2.50431\n  \"R_O2t\"         => 21.7995\n  \"R_G6PDH2r\"     => 4.95999\n  \"R_TALA\"        => 1.49698\n  â‹®               => â‹®","category":"page"},{"location":"quickstart/#Model-variant-processing","page":"COBREXA.jl in 10 minutes","title":"Model variant processing","text":"","category":"section"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"The main feature of COBREXA.jl is the ability to easily specify and process many analyses in parallel. To demonstrate, let's see how the organism would perform if some reactions were disabled independently:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"# convert to a model type that is efficient to modify\nm = convert(StandardModel, model)\n\n# find the model objective value if oxygen or carbon dioxide transports are disabled\nscreen(m, # the base model\n    variants=[ # this specifies how to generate the desired model variants\n        [], # one with no modifications, i.e. the base case\n        [with_changed_bound(\"R_O2t\", lower=0.0, upper=0.0)], # disable oxygen\n        [with_changed_bound(\"R_CO2t\", lower=0.0, upper=0.0)], # disable CO2\n        [with_changed_bound(\"R_O2t\", lower=0.0, upper=0.0),\n\t        with_changed_bound(\"R_CO2t\", lower=0.0, upper=0.0)], # disable both\n    ],\n    # this specifies what to do with the model variants (received as the argument `x`)\n    analysis = x ->\n        flux_balance_analysis_dict(x, Tulip.Optimizer)[\"R_BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"You should receive a result showing that missing oxygen transport makes the biomass production much harder:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"4-element Vector{Float64}:\n 0.8739215022674809\n 0.21166294973372796\n 0.46166961413944896\n 0.21114065173865457","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"Most importantly, such analyses can be easily specified by automatically generating long lists of modifications to be applied to the model, and parallelized.","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"Knocking out each reaction in the model is efficiently accomplished:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"# load the task distribution package, add several worker nodes, and load\n# COBREXA and the solver on the nodes\nusing Distributed\naddprocs(4)\n@everywhere using COBREXA, Tulip\n\n# get a list of the workers\nworker_list = workers()\n\n# run the processing in parallel for many model variants\nres = screen(m,\n    variants=[\n\t# create one variant for each reaction in the model, with that reaction knocked out\n        [with_changed_bound(reaction_id, lower=0.0, upper=0.0)]\n\tfor reaction_id in reactions(m)\n    ],\n    analysis = model -> begin\n\t# we need to check if the optimizer even found a feasible solution,\n\t# which may not be the case if we knock out important reactions\n    \tsol = flux_balance_analysis_dict(model, Tulip.Optimizer)\n\tisnothing(sol) ? nothing : sol[\"R_BIOMASS_Ecoli_core_w_GAM\"]\n    end,\n    # run the screening in parallel on all workers in the list\n    workers = worker_list,\n)","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"In result, you should get a long list of the biomass production for each reaction knockout. Let's decorate it with reaction names:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"Dict(reactions(m) .=> res)","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"...which should output an easily accessible dictionary with all the objective values named, giving a quick overview of which reactions are critical for the model organism to create biomass:","category":"page"},{"location":"quickstart/","page":"COBREXA.jl in 10 minutes","title":"COBREXA.jl in 10 minutes","text":"Dict{String, Union{Nothing, Float64}} with 95 entries:\n  \"R_ACALD\"       => 0.873922\n  \"R_PTAr\"        => 0.873922\n  \"R_ALCD2x\"      => 0.873922\n  \"R_PDH\"         => 0.796696\n  \"R_PYK\"         => 0.864926\n  \"R_CO2t\"        => 0.46167\n  \"R_EX_nh4_e\"    => 1.44677e-15\n  \"R_MALt2_2\"     => 0.873922\n  \"R_CS\"          => 2.44779e-14\n  \"R_PGM\"         => 1.04221e-15\n  \"R_TKT1\"        => 0.864759\n  â‹®             => â‹®","category":"page"},{"location":"examples/#Examples","page":"Contents","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Contents","title":"Contents","text":"Pages = filter(x -> endswith(x, \".md\"), readdir(\"examples\", join=true))\nDepth = 2","category":"page"}]
}
