var documenterSearchIndex = {"docs":
[{"location":"advanced/1_modifications/#Screening-with-modifications","page":"Screening with modifications","title":"Screening with modifications","text":"","category":"section"},{"location":"tutorials/#COBREXA-Tutorials","page":"Tutorials","title":"COBREXA Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = joinpath.(\"tutorials\", filter(x -> endswith(x, \".md\"), readdir(\"tutorials\")))\nDepth = 2","category":"page"},{"location":"advanced/2_custom_model/#Custom-models","page":"Custom models","title":"Custom models","text":"","category":"section"},{"location":"tutorials/2_analysis/#Basic-analysis-of-constraint-based-models","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"COBREXA.jl supports several common analysis methods that are often used for exploring the biological models. The currently supported methods include","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Flux balance analysis (FBA), in function flux_balance_analysis\nFlux variability analysis (FVA), in flux_variability_analysis\nFlux sampling by hit-and-run algorithm, in hit_and_run\nParsimonious flux balance analysis (pFBA), in parsimonious_flux_balance_analysis","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Other analysis methods are either in development and testing, or may be specified or customized by the user. Implementing new analyses is generally feasible; you may want to watch the COBREXA.jl repository for newly incoming analysis methods.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"COBREXA.jl additionally exports several helper functions that may help you in running custom analysis methods:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"you can convert all types of MetabolicModels to JuMP.jl models using make_optimization_model, then you may explore and analyze the models independently of COBREXA.jl using the tools provided by JuMP.jl\nthere is a system of analysis modifications that allows you to easily specify various adjustments to the existing analysis methods","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"tip: Notebook available!\nExamples of running the analysis functions are available here.","category":"page"},{"location":"tutorials/2_analysis/#Optimization-problem-solvers","page":"Basic analysis of constraint-based models","title":"Optimization problem solvers","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For solving most analysis tasks, you need an optimization problem solver that is compatible with JuMP.jl. You may refer to the official list of supported solvers, but we generally recommend to use either of these:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Tulip (pure Julia implementation) for linear problems\nGLPK (based on a C library) for linear and mixed-integer problems\nGurobi (based on an external library, but requires a license that is free for academic use) for linear, mixed-integer and quadratic problems","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"All solvers can be installed using the Julia package manger.","category":"page"},{"location":"tutorials/2_analysis/#Flux-balance-analysis","page":"Basic analysis of constraint-based models","title":"Flux balance analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"The above methods generally accept 2 arguments: the model, and the optimizer.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"In particular, having installed e.g. GLPK from the above optimizers, you can run FBA on your favorite E. Coli core model as follows:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"using COBREXA\nm = load_model(CoreModel, \"e_coli_core.xml\")\n\nusing GLPK\nopt_model = flux_balance_analysis(m, GLPK.Optimizer)","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"After a short while (the solver machinery usually needs to get precompiled before the first use), you should get opt_model, which is now an optimized JuMP.jl model. It may print out information like this:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"A JuMP Model\nMaximization problem with:\nVariables: 95\nObjective function type: JuMP.GenericAffExpr{Float64,JuMP.VariableRef}\n`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 73 constraints\n`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 192 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: GLPK\nNames registered in the model: lbs, mb, ubs, x","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"From that, you can extract the required information with the JuMP interface, loaded with using JuMP. With that,","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"objective_value(opt_model) prints roughly 0.87,\nvalue.(opt_model[:x]) prints the vector of individual reaction fluxes.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For convenience, you can get the results nicely formatted without manually getting them out of the optimized models:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"flux_balance_analysis_vec works like flux_balance_analysis, but returns the vector of fluxes directly (in the same order as in reactions(m))\nflux_balance_analysis_dict returns a dictionary with the fluxes, keyed by reaction identifier","category":"page"},{"location":"tutorials/2_analysis/#Flux-variability-analysis","page":"Basic analysis of constraint-based models","title":"Flux variability analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"FVA is implemented in flux_variability_analysis, which returns the usual matrix of minimal and maximal feasible fluxes for each reaction in the model.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"The result of calling flux_variability_analysis(m, GLPK.Optimizer) may look like this (possibly showing minor numeric errors in the GLPK optimizer):","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×2 Array{Float64,2}:\n   0.0            0.0\n   6.00725        6.00725\n   ⋮            \n   3.64414e-13    3.17348e-13\n   3.2149         3.2149","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You can relax the optimality requirement of the reactions by specifying a wider objective bound, getting a wider range of reaction fluxes, e.g. using gamma_bounds (for COBRA-like γ-bound) and objective_bounds (for a multiplicative bound around the original optimal objective).","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"As a result, flux_variability_analysis(m, GLPK.Optimizer; bounds=gamma_bounds(0.8)) will return a much less constrained system:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×2 Array{Float64,2}:\n   0.0            0.0\n   0.754299      10.1285\n   ⋮            \n  -4.42865        0.0\n   2.57192        3.2149","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You may additionally restrict the analysis to a list of reactions (passing the list as the second argument, see documentation of flux_variability_analysis), or retrieve a dictionary of the resulting fluxes with flux_variability_analysis_dict.","category":"page"},{"location":"tutorials/2_analysis/#Parsimonious-flux-balance-analysis","page":"Basic analysis of constraint-based models","title":"Parsimonious flux balance analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Parsimonious flux balance analysis (pFBA) requires a solver that can handle quadratic problems. Some examples include, e.g. OSQP, Gurobi, Mosek, etc.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Otherwise, the function behaves just like flux_balance_analysis:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"parsimonious_flux_balance_analysis(m, OSQP.Optimizer) will return a JuMP.jl model optimized to a slightly more realistic (parsimonious) optimum than plain FBA,\nparsimonious_flux_balance_analysis_vec will return the fluxes in a vector,\nparsimonious_flux_balance_analysis_dict will return a reaction-keyed dictionary.","category":"page"},{"location":"tutorials/2_analysis/#Flux-sampling","page":"Basic analysis of constraint-based models","title":"Flux sampling","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For the hit_and_run, you need a previously optimized and constrained model from another analysis function, such as flux_balance_analysis, or created by make_optimization_model. You may need to carefully choose the number of iterations and sample sizes to match your model; see the documentation of hit_and_run for details.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"As an example, you can run the sampling for 100 thousand iterations with:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"hit_and_run(100_000, make_optimization_model(m, GLPK.Optimizer))","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You should receive a matching flux sample with the (default) 1000 samples in a matrix that may look like this one:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×1000 Array{Float64,2}:\n   0.0           0.0         …   0.0\n   7.82669       9.38895         3.30653\n   7.13016       4.36813         9.64434\n  -0.290925     -9.3037         -0.0908829\n  24.1294       17.4794          0.0511032\n   ⋮                         ⋱  \n -16.243       -37.4763         -5.57301\n   0.0           0.0             0.0\n  -0.310819     -1.20057e-7     -2.13126\n   5.71597e-5    0.00990677      0.692399","category":"page"},{"location":"notebooks/#Notebooks-and-example-workflows","page":"Examples and notebooks","title":"Notebooks and example workflows","text":"","category":"section"},{"location":"notebooks/","page":"Examples and notebooks","title":"Examples and notebooks","text":"Pages = joinpath.(\"notebooks\", filter(x -> endswith(x, \".md\"), readdir(\"notebooks\")))\nDepth = 2","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/5_basic_stdmodel_construction.jl\"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Model-construction-and-modification","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"COBREXA can load models stored in .mat, .json, and .xml formats; and convert these into StandardModels. However, it is also possible to construct models from scratch, and modify existing models. This will be demonstrated here.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Model-construction","page":"Model construction and modification","title":"Model construction","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"In COBREXA, model construction is primarily supported through StandardModels. To begin, create an empty StandardModel.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"using COBREXA\n\nmodel = StandardModel(\"FirstModel\") # assign model id = \"FirstModel\"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"Next, genes, metabolites and reactions need to be added to the model.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-genes-to-the-model","page":"Model construction and modification","title":"Add genes to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"gene_list = [Gene(string(\"g\", num)) for num = 1:8]","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"warning: Warning: Don't accidentally overwrite the generic accessors\nIt may be tempting to call a variable genes, metabolites, or   reactions. However, these names conflict with generic accessors   functions and will create problems downstream.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"add_genes!(model, gene_list)","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-metabolites-to-the-model","page":"Model construction and modification","title":"Add metabolites to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"metabolite_list = [Metabolite(string(\"m\", num)) for num = 1:4]\n\nmetabolite_list[1].formula = \"C6H12O6\" # can edit metabolites, etc. directly\n\nadd_metabolites!(model, metabolite_list)","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-reactions-to-the-model","page":"Model construction and modification","title":"Add reactions to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"There are two ways to create and add reactions to a model. These are using functions, or macros.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"r_m1 = Reaction(\"EX_m1\", Dict(\"m1\" => -1.0), :bidirectional) # exchange reaction: m1 <-> (is the same as m1 ⟷ nothing)\nr1 = Reaction(\"r1\", Dict(\"m1\" => -1.0, \"m2\" => 1.0), :forward)\nr1.grr = [[\"g1\", \"g2\"], [\"g3\"]] # add some gene reaction rules\nr2 = Reaction(\"r2\", Dict(\"m2\" => -1.0, \"m1\" => 1.0), :backward)\nr3 = Reaction(\"r3\", Dict(\"m2\" => -1.0, \"m3\" => 1.0), :bidirectional)\n\nadd_reactions!(model, [r1, r2, r3, r_m1]) # function approach\n\nm1 = metabolite_list[1]\nm2 = metabolite_list[2]\nm3 = metabolite_list[3]\nm4 = metabolite_list[4]\n\n@add_reactions! model begin # macro approach\n    \"r4\", m2 ⟶ m4, 0, 1000\n    \"r_m3\", m3 ⟷ nothing, -1000, 1000\n    \"r_m4\", m4 ⟶ nothing\n    \"r5\", m4 ⟶ m2\nend\n\nmodel.reactions[\"r4\"].grr = [[\"g5\"], [\"g6\", \"g7\"], [\"g8\"]]","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"note: Note: Using reaction arrows\nCOBREXA exports arrows that can be used to construct reactions.   Both the long and short arrows (⟶ == →) mean the same thing if they   point in the same direction.These arrows are accessible by using the LaTeX completions built into   Julia. For example:→ is \\rightarrow<tab>\n⟶ is \\longrightarrow<tab>\n← is \\leftarrow<tab>\n⟵ is \\longleftarrow<tab>\n↔ is \\leftrightarrow<tab>\n⟷ is \\longleftrightarrow<tab>","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"The constructed model can now be inspected.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"model","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Modifying-existing-models","page":"Model construction and modification","title":"Modifying existing models","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"It is also possible to modify a model by deleting certain genes. This is simply achieved by calling remove_genes!.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"remove_genes!(model, [\"g1\", \"g2\"]; knockout_reactions = false)\nmodel","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/3_hpc/#Distributed-processing-and-HPC-environments","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Distributed processing in Julia is represented mainly by the package Distributed.jl.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"COBREXA.jl is able to utilize this existing system to almost transparently run the large parallelizable analyses on multiple CPU cores and multiple computers connected through the network. Ultimately, the approach scales to thousands of computing nodes in large HPC facilities.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Here, we give a short overview of how to work in the distributed environment and utilize the resources for COBREXA.jl analyses.","category":"page"},{"location":"tutorials/3_hpc/#Starting-the-distributed-workers","page":"Distributed processing and HPC environments","title":"Starting the distributed workers","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"COBREXA.jl follows the structure imposed by the Distributed package: You operate a main (usually called \"master\") computation node, connect to multiple other computers and start worker Julia processes there, and distribute the workload across this cluster.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To start, you need to load the package and add a few processes. This starts 5 processes locally:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using Distributed\naddprocs(5)","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"note: `Distributed.jl` installation\nDistributed.jl usually comes pre-installed with Julia distribution, but you may still need to \"enable\" it by typing ] add Distributed.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"You may check that the workers are really there, using workers(). In this case, it should give you a vector of worker IDs, very likely equal to [2,3,4,5,6].","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"If you have compute resources available via a network, you may connect these as well, provided you have a secure shell (ssh) access to them. You will likely want to establish a key-based authentication (refer to ssh documentation) to make the connection easier.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With shell, check that you can ssh to a remote node and run Julia there:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"user@pc> ssh server\n...\nuser@server> julia\n...\njulia> _","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"top: Running shell commands from Julia\nIf you don't want to quit your Julia session to try out the ssh connection from the shell, press ; in the Julia prompt on the beginning of the line. The interpreter will execute your next line as a shell command.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"If this works for you, you can add some workers that run on the server from your Julia shell running on your pc. For example, the following starts 20 workers on the remote server and 10 workers on your friend's computer called joe_pc:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"addprocs([('server', 20), ('joe_pc', 10)])","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With this, you can schedule various computation on the workers; see the Julia manual of Distributed for basic details. You may try various convenience packages, such as DistributedArrays.jl and DistributedData.jl, to process any data in a distributed fashion.","category":"page"},{"location":"tutorials/3_hpc/#Running-a-distributed-analysis","page":"Distributed processing and HPC environments","title":"Running a distributed analysis","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"While not all COBREXA functions may be parallelized naturally, these that do will accept a special workers argument that specifies a list of worker IDs where the computation should be distributed. For the value, you can specify your desired worker IDs manually (e.g. [2,3,4]), or simply use workers().","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"For example, flux_variability_analysis can naturally parallelize the computation of all reactions's minima and maxima to finish the computation faster. To enable the parallelization, you first need to make sure that all workers have loaded both the COBREXA package and the optimizer:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using COBREXA, GLPK, Distributed\naddprocs(10)                       # add any kind and number of processes here\n@everywhere using COBREXA, GLPK    # loads the necessary packages on all workers","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"When the package is loaded and precompiled everywhere, you may load your model and run the FVA with the workers parameter:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"model = load_model(\"e_coli_core.xml\")\nresult = flux_variability_analysis(model, GLPK.Optimizer; workers=workers())","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With the extra computing capacity from N workers available, the FVA should be computed roughly N-times faster.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"note: Distribution and parallelization overhead\nCommunication of the workers with your Julia shell is not free. If the task that you are parallelizing is small and the model structure is very large, the distributed computation will actually spend most computation time just distributing the large model to the workers, and almost no time in executing the small parallel task. In such case, the performance will not improve by adding additional resources. You may want to check that the computation task is sufficiently large before investing the extra resources into the distributed execution. Amdahl's and Gustafson's laws can give you a better overview of the consequences of this overhead.","category":"page"},{"location":"tutorials/3_hpc/#Interacting-with-HPC-schedulers","page":"Distributed processing and HPC environments","title":"Interacting with HPC schedulers","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Many researchers have access to institutional HPC facilities that allow time-sharing of the capacity of a large computer cluster between many researchers. Julia and COBREXA.jl work well within this environment; but your programs require some additional customization to be able to find and utilize the resources available from the HPC.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"In our case, this reduces to a relatively complex task: You need to find out how many resources were allocated for your task, and you need to add the remote workers precisely at places that were allocated for your. Fortunately, the package ClusterManagers.jl can do precisely that.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"For simplicily, we will assume that your HPC is scheduled by Slurm.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Adding of the workers from Slurm is done as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"you import the ClusterManagers package\nyou find how many processes to spawn from the environment from SLURM_NTASKS environment variable\nyou use the function addprocs_slurm to precisely connect to your allocated computational resources","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"The Julia script that does a parallel analysis may then start as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using COBREXA, Distributed, ClusterManagers\n\navailable_workers = parse(Int, ENV[\"SLURM_NTASKS\"])\n\naddprocs_slurm(available_workers)\n\n...\nresult = flux_variability_analysis(...; workers=workers())\n...","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"After adding the Slurm workers, you may continue as if the workers were added using normal addprocs, and (for example) run the flux_variability_analysis as shown above.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"tip: What about the other HPC schedulers?\nClusterManagers.jl supports many other common HPC scheduling systems, including LFS, Sun Grid, SGE, PBS, and Scyld, in a way almost identical to Slurm. See the package documentation for details.","category":"page"},{"location":"tutorials/3_hpc/#Wrapping-your-script-in-a-Slurm-job","page":"Distributed processing and HPC environments","title":"Wrapping your script in a Slurm job","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To be able to submit your script for later processing using the sbatch Slurm command, you need to wrap it in a small \"batch\" script that tells Slurm how many resources the process needs.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Assuming you have a Julia computation script written down in myJob.jl and saved on your HPC cluster's access node, the corresponding Slurm batch script (let's call it myJob.sbatch) may look as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"#!/bin/bash -l\n#SBATCH -n 100           # the job will require 100 individual workers\n#SBATCH -c 1             # each worker will sit on a single CPU\n#SBATCH -t 30            # the whole job will take less than 30 minutes\n#SBATCH -J myJob         # the name of the job\n\nmodule load lang/Julia   # this is usually required to make Julia available to your job\n\njulia myJob.jl","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To run the computation, simply run sbatch myJob.sbatch on the access node. The job will be scheduled and eventually executed. You may watch sacct and squeue in the meantime, to see the progress.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Remember that you need to explicitly save the result of your Julia script computation to files, to be able to retrieve them later. Standard outputs of the jobs are often mangled and discarded. If you still want to collect the standard output, you may change the last line of the batch script to","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"julia myJob.jl > myJob.log","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"and collect the output from the log later. This is convenient especially if logging various computation details using the @info and similar macros.","category":"page"},{"location":"functions/#Functions","page":"Function reference","title":"Functions","text":"","category":"section"},{"location":"functions/#Base-Types","page":"Function reference","title":"Base Types","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", \"abstract\", file), readdir(\"../src/base/types/abstract\"))","category":"page"},{"location":"functions/#COBREXA.Maybe","page":"Function reference","title":"COBREXA.Maybe","text":"Maybe{T} = Union{Nothing, T}\n\nA nice name for \"nullable\" type.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA._default-Union{Tuple{T}, Tuple{T, Union{Nothing, T}}} where T","page":"Function reference","title":"COBREXA._default","text":"_default(d::T, x::Maybe{T})::T where {T}\n\nFold the Maybe{T} down to T by defaulting.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._maybemap-Tuple{Any, Union{Nothing, T} where T}","page":"Function reference","title":"COBREXA._maybemap","text":"_maybemap(f, x::Maybe)::Maybe\n\nApply a function to x only if it is not nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Annotations","page":"Function reference","title":"COBREXA.Annotations","text":"Annotations = Dict{String,Vector{String}}\n\nDictionary used to store (possible multiple) standardized annotations of something, such as a Metabolite and a Reaction.\n\nExample\n\nAnnotations(\"PubChem\" => [\"CID12345\", \"CID54321\"])\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.GeneAssociation","page":"Function reference","title":"COBREXA.GeneAssociation","text":"GeneAssociation = Vector{Vector{String}}\n\nAn association to genes, represented as a logical formula in a positive disjunctive normal form (DNF). (The 2nd-level vectors of strings are connected by \"and\" to form conjunctions, and the 1st-level vectors of these conjunctions are connected by \"or\" to form the DNF.)\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.MetabolicModel","page":"Function reference","title":"COBREXA.MetabolicModel","text":"abstract type MetabolicModel end\n\nA helper supertype that wraps everything usable as a linear-like model for COBREXA functions.\n\nIf you want your model type to work with COBREXA, add the MetabolicModel as its supertype, and implement the accessor functions. Accessors reactions, metabolites, stoichiometry, bounds and objective must be implemented; others are not mandatory and default to safe \"empty\" values.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.MetaboliteFormula","page":"Function reference","title":"COBREXA.MetaboliteFormula","text":"MetaboliteFormula = Dict{String,Int}\n\nDictionary of atoms and their abundances in a molecule.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.Notes","page":"Function reference","title":"COBREXA.Notes","text":"Notes = Dict{String,Vector{String}}\n\nFree-form notes about something (e.g. a Gene), categorized by \"topic\".\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.balance-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(a::MetabolicModel)::SparseVec\n\nGet the sparse balance vector of a model (ie. the b from S x = b).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(a::MetabolicModel)::Tuple{SparseVec,SparseVec}\n\nGet the lower and upper flux bounds of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.coupling","text":"coupling(a::MetabolicModel)::SparseMat\n\nGet a matrix of coupling constraint definitions of a model. By default, there is no coupling in the models.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling_bounds-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::MetabolicModel)::Tuple{SparseVec,SparseVec}\n\nGet the lower and upper bounds for each coupling bound in a model, as specified by coupling. By default, the model does not have any coupling bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_annotations-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.gene_annotations","text":"gene_annotations(a::MetabolicModel, gene_id::String)::Annotations\n\nReturn standardized names that identify the corresponding gene or product. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"PDB\" => [\"PROT01\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_notes-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.gene_notes","text":"gene_notes(model::MetabolicModel, gene_id::String)::Notes\n\nReturn the notes associated with the gene gene_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(a::MetabolicModel)::Vector{String}\n\nReturn identifiers of all genes contained in the model. By default, there are no genes.\n\nIn SBML, these are usually called \"gene products\" but we write genes for simplicity.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_annotations-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(a::MetabolicModel, metabolite_id::String)::Annotations\n\nReturn standardized names that may help to reliably identify the metabolite. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"ChEMBL\" => [\"123\"] or \"PubChem\" => [\"CID123\", \"CID654645645\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolitecharge(model::MetabolicModel, metaboliteid::String)::Maybe{Int}\n\nReturn the charge associated with metabolite metabolite_id in model.  Returns nothing if charge not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::MetabolicModel, metabolite_id::String)::Maybe{String}\n\nReturn the compartment of metabolite metabolite_id in model if it is assigned. If not,  return nothing. \n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(\n    a::MetabolicModel,\n    metabolite_id::String,\n)::Maybe{MetaboliteFormula}\n\nReturn the formula of metabolite metabolite_id in model.  Return nothing in case the formula is not known or irrelevant.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_notes-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::MetabolicModel, metabolite_id::String)::Notes\n\nReturn the notes associated with metabolite reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(a::MetabolicModel)::Vector{String}\n\nReturn a vector of metabolite identifiers in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_coupling_constraints-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::MetabolicModel)::Int\n\nGet the number of coupling constraints in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_genes-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_genes","text":"n_genes(a::MetabolicModel)::Int\n\nReturn the number of genes in the model (as returned by genes). If you just need the number of the genes, this may be much more efficient than calling genes and measuring the array.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_metabolites-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_metabolites","text":"n_metabolites(a::MetabolicModel)::Int\n\nGet the number of metabolites in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_reactions-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_reactions","text":"n_reactions(a::MetabolicModel)::Int\n\nGet the number of reactions in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(a::MetabolicModel)::SparseVec\n\nGet the objective vector of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.precache!-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.precache!","text":"precache!(a::MetabolicModel)::Nothing\n\nDo whatever is feasible to get the model into a state that can be read from as-quickly-as-possible. This may include e.g. generating helper index structures and loading delayed parts of the model from disk. The model should be modified \"transparently\" in-place. Analysis functions call this right before applying modifications or converting the model to the optimization model using make_optimization_model; usually on the same machine where the optimizers (and, generally, the core analysis algorithms) will run. The calls are done in a good hope that the performance will be improved.\n\nBy default, it should be safe to do nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_annotations-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_annotations","text":"reaction_annotations(a::MetabolicModel, reaction_id::String)::Annotations\n\nReturn standardized names that may help identifying the reaction. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"Reactome\" => [\"reactomeID123\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(a::MetabolicModel, gene_id::String)::Maybe{GeneAssociation}\n\nReturns the sets of genes that need to be present so that the reaction can work (technically, a DNF on gene availability, with positive atoms only).\n\nFor simplicity, nothing may be returned, meaning that the reaction always takes place. (in DNF, that would be equivalent to returning [[]].)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_notes-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_notes","text":"reaction_notes(model::MetabolicModel, reaction_id::String)::Notes\n\nReturn the notes associated with reaction reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_subsystem-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::MetabolicModel, reaction_id::String)::Maybe{String}\n\nReturn the subsystem of reaction reaction_id in model if it is assigned. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(a::MetabolicModel)::Vector{String}\n\nReturn a vector of reaction identifiers in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(a::MetabolicModel)::SparseMat\n\nGet the sparse stoichiometry matrix of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Model-types-and-contents","page":"Function reference","title":"Model types and contents","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", file), readdir(\"../src/base/types\"))","category":"page"},{"location":"functions/#COBREXA.CoreModel","page":"Function reference","title":"COBREXA.CoreModel","text":"struct CoreModel <: MetabolicModel\n\nA \"bare bones\" core linear optimization problem of the form, with reaction and metabolite names.\n\nmin c^T x\ns.t. S x = b\n      xₗ ≤ x ≤ xᵤ\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Union{Tuple{M}, Tuple{Type{CoreModel}, M}} where M<:MetabolicModel","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{CoreModel}, m::M) where {M <: MetabolicModel}\n\nMake a CoreModel out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(a::CoreModel)::SparseVec\n\nCoreModel target flux balance.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(a::CoreModel)::Tuple{SparseVec,SparseVec}\n\nCoreModel flux bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(a::CoreModel)::Vector{String}\n\nMetabolites in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(a::CoreModel)::SparseVec\n\nCoreModel objective vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(a::CoreModel)::Vector{String}\n\nGet the reactions in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(a::CoreModel)::SparseMat\n\nCoreModel stoichiometry matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.CoreModelCoupled","page":"Function reference","title":"COBREXA.CoreModelCoupled","text":"struct CoreModelCoupled <: MetabolicModel\n\nThe linear model with additional coupling constraints in the form\n\n    cₗ ≤ C x ≤ cᵤ\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{CoreModelCoupled}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{CoreModelCoupled}, mm::MetabolicModel)\n\nMake a CoreModelCoupled out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.balance","text":"balance(a::CoreModelCoupled)\n\nExtract balance from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(a::CoreModelCoupled)\n\nExtract bounds from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.coupling","text":"coupling(a::CoreModelCoupled)::SparseMat\n\nCoupling constraint matrix for a CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling_bounds-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::CoreModelCoupled)::Tuple{SparseVec,SparseVec}\n\nCoupling bounds for a CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(a::CoreModelCoupled)\n\nExtract metabolites from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_coupling_constraints-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::CoreModelCoupled)::Int\n\nThe number of coupling constraints in a CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.objective","text":"objective(a::CoreModelCoupled)\n\nExtract objective from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(a::CoreModelCoupled)\n\nExtract reactions from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(a::CoreModelCoupled)\n\nExtract stoichiometry from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Gene","page":"Function reference","title":"COBREXA.Gene","text":"Gene struct.\n\nFields\n\nid :: String\nname :: Union{String, Nothing}\nnotes :: Dict{String, Vector{String}}\nannotation :: Dict{String, Union{Vector{String}, String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.JSONModel","page":"Function reference","title":"COBREXA.JSONModel","text":"struct JSONModel <: MetabolicModel\n    json::Dict{String,Any}\nend\n\nA struct used to store the contents of a JSON model, i.e. a model read from a file ending with .json. These model files typically store all the model parameters in arrays of JSON objects (i.e. Julia dictionaries).\n\nUsually, not all of the fields of the input JSON can be easily represented when converting to other models, care should be taken to avoid losing information.\n\nDirect work on this precise model type is not very efficient, as the accessor functions need to repeatedly find the information in the JSON tree. This gets very slow especially if calling many accessor functions sequentially. To avoid that, convert to e.g. StandardModel as soon as possible.\n\nExample\n\nmodel = load_json_model(\"some_model.json\")\nmodel.json # see the actual underlying JSON\nreactions(model) # see the list of reactions\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{JSONModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{JSONModel}, mm::MetabolicModel)\n\nConvert any MetabolicModel to JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(model::JSONModel)\n\nGet the bounds for reactions, assuming the information is stored in .lower_bound and .upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_annotations-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.gene_annotations","text":"gene_annotations(model::JSONModel, gid::String)::Annotations\n\nGene annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_notes-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.gene_notes","text":"gene_notes(model::JSONModel, gid::String)::Notes\n\nGene notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(model::JSONModel)\n\nExtract gene names from a JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_annotations-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::JSONModel, mid::String)::Annotations\n\nMetabolite annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::JSONModel, mid::String)\n\nReturn the metabolite .charge\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::JSONModel, mid::String)\n\nReturn the metabolite .compartment\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::JSONModel, mid::String)\n\nParse and return the metabolite .formula\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_notes-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::JSONModel, mid::String)::Notes\n\nMetabolite notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(model::JSONModel)\n\nExtract metabolite names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(model::JSONModel)\n\nCollect .objective_coefficient keys from model reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_annotations-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::JSONModel, rid::String)::Annotations\n\nReaction annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_associaton(model::JSONModel, rid::String)\n\nParses the .gene_reaction_rule from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_notes-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_notes","text":"reaction_notes(model::JSONModel, rid::String)::Notes\n\nReaction notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_subsystem-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::JSONModel, rid::String)\n\nParses the .subsystem out from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(model::JSONModel)\n\nExtract reaction names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(model::JSONModel)\n\nGet the stoichiometry. Assuming the information is stored in reaction object under key .metabolites.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.MATModel","page":"Function reference","title":"COBREXA.MATModel","text":"struct MATModel\n\nWrapper around the models loaded in dictionaries from the MATLAB representation.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{MATModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{MATModel}, m::MetabolicModel)\n\nConvert any metabolic model to MATModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._mat_has_squashed_coupling-Tuple{Any}","page":"Function reference","title":"COBREXA._mat_has_squashed_coupling","text":"_mat_has_squashed_coupling(mat)\n\nGuesses whether C in the MAT file is stored in A=[S;C].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{MATModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(m::MATModel)\n\nExtracts balance from the MAT model, defaulting to zeroes if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{MATModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(m::MATModel)\n\nExtracts bounds from the MAT file, saved under lb and ub.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling-Tuple{MATModel}","page":"Function reference","title":"COBREXA.coupling","text":"coupling(m::MATModel)\n\nExtract coupling matrix stored, in C key.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling_bounds-Tuple{MATModel}","page":"Function reference","title":"COBREXA.coupling_bounds","text":"coupling_bounds(m::MATModel)\n\nExtracts the coupling constraints. Currently, there are several accepted ways to store these in MATLAB models; this takes the constraints from vectors cl and cu.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{MATModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(m::MATModel)\n\nExtracts the possible gene list from genes key.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(m::MATModel, mid::String)\n\nExtract metabolite charge from metCharge or metCharges.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(m::MATModel, mid::String)\n\nExtract metabolite compartment from metCompartment or metCompartments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(m::MATModel, mid::String)\n\nExtract metabolite formula from key metFormula or metFormulas.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{MATModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(m::MATModel)::Vector{String}\n\nExtracts metabolite names from mets key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{MATModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(m::MATModel)\n\nExtracts the objective from the MAT model (defaults to zeroes).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(m::MATModel, rid::String)\n\nExtracts the associations from grRules key, if present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{MATModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(m::MATModel)::Vector{String}\n\nExtracts reaction names from rxns key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{MATModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(m::MATModel)\n\nExtract the stoichiometry matrix, stored under key S.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Metabolite","page":"Function reference","title":"COBREXA.Metabolite","text":"Metabolite structure.\n\nFields\n\nid :: String\nname :: String\nformula :: String\ncharge :: Int\ncompartment :: String\nnotes :: Dict{String, Vector{String}}\nannotation :: Dict{String, Union{Vector{String}, String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.Reaction","page":"Function reference","title":"COBREXA.Reaction","text":"Reaction struct.\n\nFields\n\nid :: String\nname :: String\nmetabolites :: Dict{Metabolite, Float64}\nlb :: Float64\nub :: Float64\ngrr :: Vector{Vector{Gene}}\nsubsystem :: String\nnotes :: Dict{String, Vector{String}}\nannotation :: Dict{String, Union{Vector{String}, String}}\nobjective_coefficient :: Float64\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.ReactionStatus","page":"Function reference","title":"COBREXA.ReactionStatus","text":"Used for concise reporting of modeling results.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.SBMLModel","page":"Function reference","title":"COBREXA.SBMLModel","text":"struct SBMLModel\n\nThin wrapper around the model from SBML.jl library. Allows easy conversion from SBML to any other model format.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{SBMLModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{SBMLModel}, mm::MetabolicModel)\n\nConvert any metabolic model to SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(model::SBMLModel)::SparseVec\n\nBalance vector of a SBMLModel. This is always zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(model::SBMLModel)::Tuple{SparseVec,SparseVec}\n\nGet the lower and upper flux bounds of model SBMLModel. Throws DomainError in case if the SBML contains mismatching units.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(model::SBMLModel)::Vector{String}\n\nGet genes of a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{SBMLModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::SBMLModel, mid::String)::Maybe{Int}\n\nGet charge of a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{SBMLModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::SBMLModel, mid::String)::Maybe{MetaboliteFormula}\n\nGet MetaboliteFormula from a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(model::SBMLModel)::Vector{String}\n\nGet metabolites from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_genes-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.n_genes","text":"n_genes(model::SBMLModel)::Int\n\nGet number of genes in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_metabolites-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.n_metabolites","text":"n_metabolites(model::SBMLModel)::Int\n\nEfficient counting of metabolites in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_reactions-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.n_reactions","text":"n_reactions(model::SBMLModel)::Int\n\nEfficient counting of reactions in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(model::SBMLModel)::SparseVec\n\nObjective of the SBMLModel. \n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{SBMLModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::SBMLModel, rid::String)::Maybe{GeneAssociation}\n\nRetrieve the GeneAssociation from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(model::SBMLModel)::Vector{String}\n\nGet reactions from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(model::SBMLModel)::SparseMat\n\nRecreate the stoichiometry matrix from the SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Serialized","page":"Function reference","title":"COBREXA.Serialized","text":"mutable struct Serialized{M <: MetabolicModel}\n    m::Maybe{M}\n    filename::String\nend\n\nA meta-model that represents a model that is serialized on the disk. The internal model will be loaded on-demand by using any accessor, or by calling precache! directly.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.precache!-Tuple{Serialized}","page":"Function reference","title":"COBREXA.precache!","text":"precache!(model::Serialized{MetabolicModel})::Nothing\n\nLoad the Serialized model from disk in case it's not alreadly loaded.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.StandardModel","page":"Function reference","title":"COBREXA.StandardModel","text":"mutable struct StandardModel\n\nStandardModel is used to store a constraint based metabolic model with meta-information. Meta-information is defined as annotation details, which include gene-reaction-rules, formulas, etc.\n\nThis model type seeks to keep as much meta-information as possible, as opposed to CoreModel and CoreModelCoupled, which keep the bare neccessities only. When merging models and keeping meta-information is important, use this as the model type.  If meta-information is not important, use the more efficient core model types.  See CoreModel and CoreModelCoupled for comparison.\n\nIn this model, reactions, metabolites, and genes are stored in ordered dictionaries indexed by each struct's id field. For example, model.reactions[\"rxn1_id\"] returns a Reaction where the field id equals \"rxn1_id\". This makes adding and removing reactions efficient.   \n\nNote that the stoichiometric matrix (or any other core data, e.g. flux bounds) is not stored directly as in CoreModel.  When this model type is used in analysis functions, these core data structures are built from scratch each time an analysis function is called. This can cause performance issues if you run many small analysis functions sequentially.  Consider using the core model types if performance is critical.\n\nSee also: Reaction, Metabolite, Gene\n\nFields\n\nid :: String\nreactions :: OrderedDict{String, Reaction}\nmetabolites :: OrderedDict{String, Metabolite}\ngenes :: OrderedDict{String, Gene}\n\nExample\n\nmodel = load_model(StandardModel, \"model_location\")\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{StandardModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{StandardModel}, model::MetabolicModel)\n\nConvert any MetabolicModel into a StandardModel. Note, some data loss may occur since only the generic interface is used during the conversion process.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(model::StandardModel)\n\nReturn the balance of the linear problem, i.e. b in Sv = 0 where S is the stoichiometric matrix and v is the flux vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(model::StandardModel)\n\nReturn the lower and upper bounds, respectively, for reactions in model. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_annotations-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.gene_annotations","text":"gene_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_notes-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.gene_notes","text":"gene_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(model::StandardModel)\n\nReturn a vector of gene id strings in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.lower_bounds-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.lower_bounds","text":"lower_bounds(model::StandardModel)\n\nReturn the lower bounds for all reactions in model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_annotations-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::StandardModel, id::String)\n\nReturn the charge associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::StandardModel, id::String)\n\nReturn compartment associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::StandardModel, id::String)\n\nReturn the formula of reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_notes-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(model::StandardModel)\n\nReturn a vector of metabolite id strings contained in model. The order of metabolite strings returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_genes-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.n_genes","text":"n_genes(model::StandardModel)\n\nReturn the number of genes in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_metabolites-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.n_metabolites","text":"n_metabolites(model::StandardModel)\n\nReturn the number of metabolites in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_reactions-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.n_reactions","text":"n_reactions(model::StandardModel)\n\nReturn the number of reactions contained in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(model::StandardModel)\n\nReturn sparse objective vector for model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_annotations-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::StandardModel, id::String)\n\nReturn the gene reaction rule in string format for reaction with id in model. Return nothing if not available.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_notes-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_notes","text":"reaction_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_subsystem-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(id::String, model::StandardModel)\n\nReturn the subsystem associated with reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(model::StandardModel)\n\nReturn a vector of reaction id strings contained in model. The order of reaction ids returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(model::StandardModel)\n\nReturn the stoichiometric matrix associated with model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.upper_bounds-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.upper_bounds","text":"upper_bounds(model::StandardModel)\n\nReturn the upper bounds for all reactions in model in sparse format. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base-functions","page":"Function reference","title":"Base functions","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", file), readdir(\"../src/base\"))","category":"page"},{"location":"functions/#COBREXA._constants","page":"Function reference","title":"COBREXA._constants","text":"A named tuple that contains the magic values that are used globally for whatever purposes.\n\n\n\n\n\n","category":"constant"},{"location":"functions/#COBREXA.get_bound_vectors-Tuple{Any}","page":"Function reference","title":"COBREXA.get_bound_vectors","text":"get_bound_vectors(opt_model)\n\nReturns vectors of the lower and upper bounds of opt_model constraints, where opt_model is a JuMP model constructed by e.g. make_optimization_model or flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.is_solved-Tuple{Any}","page":"Function reference","title":"COBREXA.is_solved","text":"is_solved(optmodel)\n\nReturn true if optmodel solved successfully (solution is optimal or locally optimal).  Return false if any other termination status is reached. Termination status is defined in the documentation of JuMP.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.make_optimization_model-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.make_optimization_model","text":"make_optimization_model(\n    model::MetabolicModel,\n    optimizer;\n    sense = MOI.MAX_SENSE,\n)\n\nConvert MetabolicModels to a JuMP model, place objectives and the equality constraint.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.optimize_model-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.optimize_model","text":"optimize_model(\n    model::MetabolicModel,\n    optimizer;\n    sense = MOI.MIN_SENSE,\n)\n\nUse JuMP to solve an instance of CoreModel\n\n\n\n\n\n","category":"method"},{"location":"functions/#File-I/O-and-serialization","page":"Function reference","title":"File I/O and serialization","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", file), readdir(\"../src/io\"))","category":"page"},{"location":"functions/#COBREXA.load_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_model","text":"load_model(file_name::String)::MetabolicModel\n\nGeneric function for loading models that chooses a specific loader function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nSBML models (*.xml, loaded with load_sbml_model)\nJSON models (*.json, loaded with load_json_model)\nMATLAB models (*.mat, loaded with load_mat_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_model-Union{Tuple{T}, Tuple{Type{T}, String}} where T<:MetabolicModel","page":"Function reference","title":"COBREXA.load_model","text":"load_model(type::Type{T}, file_name::String)::T where T\n\nHelper function tht loads the model using load_model and return it converted to type.\n\nExample:\n\nload_model(CoreModel, \"mySBMLModel.xml\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.save_model-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.save_model","text":"save_model(model::MetabolicModel, file_name::String)\n\nGeneric function for saving models that chooses a specific writer function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nJSON models (*.json, loaded with save_json_model)\nMATLAB models (*.mat, loaded with save_mat_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_json_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_json_model","text":"load_json_model(filename::String)::JSONModel\n\nLoad and return a JSON-formatted model that is stored in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.save_json_model-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.save_json_model","text":"save_json_model(model::MetabolicModel, file_name::String)\n\nSave a JSONModel in model to a JSON file file_name.\n\nIn case the model is not JSONModel, it will be converted automatically.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_mat_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_mat_model","text":"load_mat_model(file_name::String)\n\nLoad and return a MATLAB file file_name that contains a COBRA-compatible model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.save_mat_model-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.save_mat_model","text":"save_mat_model(model::MetabolicModel, file_name::String; model_name::String=\"model\")\n\nSave a MATModel in model to a MATLAB file file_name in a format compatible with other MATLAB-based COBRA software.\n\nIn case the model is not MATModel, it will be converted automatically.\n\nmodel_name is the identifier name for the whole model written to the MATLAB file; defaults to just \"model\".\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_sbml_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_sbml_model","text":"load_sbml_model(file_name::String)::SBMLModel\n\nLoad and return a SBML XML model in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Pretty-printing","page":"Function reference","title":"Pretty printing","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", \"show\", file), readdir(\"../src/io/show\"))","category":"page"},{"location":"functions/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, MetabolicModel}","page":"Function reference","title":"Base.show","text":"Pretty printing of everything metabolic-modelish.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_substances-Tuple{Vector{String}}","page":"Function reference","title":"COBREXA._pretty_substances","text":"_pretty_substances(ss::Vector{String})::String\n\nNicely format a substance list.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.show-Union{Tuple{M}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Serialized{M}}} where M","page":"Function reference","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", m::Serialized{M}) where {M}\n\nShow the Serialized model without unnecessarily loading it.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Any}","page":"Function reference","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(io, def::String, payload; kwargs...)\n\nNicely prints keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Dict}","page":"Function reference","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(\n    io,\n    def::String,\n    payload::Dict\n)\n\nSpecialization of _pretty_print_keyvals for dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_print_keyvals-Tuple{Any, String, String}","page":"Function reference","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(\n    io,\n    def::String,\n    payload::String\n)\n\nSpecialization of _pretty_print_keyvals for plain strings.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Model-reconstruction","page":"Function reference","title":"Model reconstruction","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"reconstruction\", file), readdir(\"../src/reconstruction\"))","category":"page"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{V2}, Tuple{V1}, Tuple{CoreModel, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}}","page":"Function reference","title":"COBREXA.add_reactions","text":"Adds reactions to the model m\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds!-Union{Tuple{V}, Tuple{CoreModel, Vector{Int64}}} where V<:AbstractVector{Float64}","page":"Function reference","title":"COBREXA.change_bounds!","text":"Change the lower and/or upper bounds ('xl' and 'xu') for given reactions\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_exchange_metabolites-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.find_exchange_metabolites","text":"Returns indices of exchanged metabolites, ie, the outermost metabolites in the network In practice returns the metabolites consumed by the reactions given by find_exchange_reactions and if called with the same arguments, the two outputs correspond.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_exchange_reactions-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.find_exchange_reactions","text":"Returns indices of exchange reactions. Exchange reactions are identified based on most commonly used prefixes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions-Tuple{CoreModel, Vector{Int64}}","page":"Function reference","title":"COBREXA.remove_reactions","text":"Removes a set of reactions from a CoreModel. Also removes the metabolites not involved in any reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.verify_consistency-Union{Tuple{K}, Tuple{V}, Tuple{M}, Tuple{CoreModel, M, V, V, V, V, K, K, Any, Any}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Function reference","title":"COBREXA.verify_consistency","text":"Verifies the consistency of a given model\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_coupling_constraints!-Union{Tuple{V}, Tuple{CoreModelCoupled, V, AbstractFloat, AbstractFloat}} where V<:AbstractVector{Float64}","page":"Function reference","title":"COBREXA.add_coupling_constraints!","text":"In-place add coupling constraints in form\n\n    cₗ ≤ C x ≤ cᵤ\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_coupling_constraints-Tuple{CoreModel, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.add_coupling_constraints","text":"Add constraints to a plain CoreModel (converts it to the coupled type)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_coupling_constraints-Tuple{CoreModelCoupled, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.add_coupling_constraints","text":"Add constraints of the following form to a CoreModelCoupled and return a modified one.\n\nThe arguments are same as for in-place add_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_coupling_bounds!-Union{Tuple{V}, Tuple{CoreModelCoupled, Vector{Int64}}} where V<:AbstractVector{Float64}","page":"Function reference","title":"COBREXA.change_coupling_bounds!","text":"Change the lower and/or upper bounds ('cl' and 'cu') for given coupling constraints\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_coupling_constraints!-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.remove_coupling_constraints!","text":"Removes a set of coupling constraints from a CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_coupling_constraints-Tuple{CoreModelCoupled, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.remove_coupling_constraints","text":"Remove coupling constraints from the linear model and return the modified model.\n\nArguments are the same as for in-place version remove_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.:⟵-Tuple{Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}, Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}}","page":"Function reference","title":"COBREXA.:⟵","text":"⟵(\n    substrates::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient},\n    },\n    products::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient}\n    },\n)\n\nMake a reverse-only Reaction from substrates and products. An equivalent alternative is ←.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.:⟶-Tuple{Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}, Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}}","page":"Function reference","title":"COBREXA.:⟶","text":"⟶(\n    substrates::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient},\n    },\n    products::Union{\n        Nothing, \n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient}\n    },\n)\n\nMake a forward-only Reaction from substrates and products. An equivalent alternative is →.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.:⟷-Tuple{Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}, Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}}","page":"Function reference","title":"COBREXA.:⟷","text":"⟷(\n    substrates::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient},\n    },\n    products::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient}\n    },\n)\n\nMake a bidirectional (reversible) Reaction from substrates and products. An equivalent alternative is ↔.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_gene!-Tuple{StandardModel, Gene}","page":"Function reference","title":"COBREXA.add_gene!","text":"add_gene!(model::StandardModel, genes::Gene)\n\nAdd gene to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_genes!-Tuple{StandardModel, Vector{Gene}}","page":"Function reference","title":"COBREXA.add_genes!","text":"add_genes!(model::StandardModel, genes::Vector{Gene})\n\nAdd genes to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_metabolite!-Tuple{StandardModel, Metabolite}","page":"Function reference","title":"COBREXA.add_metabolite!","text":"add_metabolite!(model::StandardModel, met::Metabolite)\n\nAdd met to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_metabolites!-Tuple{StandardModel, Vector{Metabolite}}","page":"Function reference","title":"COBREXA.add_metabolites!","text":"add_metabolites!(model::StandardModel, mets::Vector{Metabolite})\n\nAdd mets to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reaction!-Tuple{StandardModel, Reaction}","page":"Function reference","title":"COBREXA.add_reaction!","text":"add_reaction!(model::StandardModel, rxn::Reaction)\n\nAdd rxn to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions!-Tuple{StandardModel, Vector{Reaction}}","page":"Function reference","title":"COBREXA.add_reactions!","text":"add_reactions!(model::StandardModel, rxns::Vector{Reaction})\n\nAdd rxns to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_gene!-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_gene!","text":"remove_gene!(\n    model::StandardModel,\n    id::Vector{String};\n    knockout_reactions::Bool = false,\n)\n\nRemove gene with id from model. If knockout_reactions is true, then also  constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_gene!(model, \"g1\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_genes!-Tuple{StandardModel, Vector{String}}","page":"Function reference","title":"COBREXA.remove_genes!","text":"remove_genes!(\n    model::StandardModel,\n    ids::Vector{String};\n    knockout_reactions::Bool = false,\n)\n\nRemove all genes with ids from model. If knockout_reactions is true, then also  constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_genes!(model, [\"g1\", \"g2\"])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite!-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::StandardModel, id::String)\n\nRemove metabolite with id from model. Warning, this could leave the model inconsistent, e.g. a reaction might require the deleted metabolite, in which case analysis functions will error.\n\nExample\n\nremove_metabolite!(model, \"atp_c\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites!-Tuple{StandardModel, Vector{String}}","page":"Function reference","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::StandardModel, ids::Vector{String})\n\nRemove all metabolites with ids from model. Warning, this could leave the model inconsistent, e.g. a reaction might require the deleted metabolite, in which case analysis functions will error.\n\nExample\n\nremove_metabolites!(model, [\"atp_c\", \"adp_c\"])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction!-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::StandardModel, id::String)\n\nRemove reaction with id from model. Note, may result in orphan metabolites.\n\nExample\n\nremove_reaction!(model, \"EX_glc__D_e\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions!-Tuple{StandardModel, Vector{String}}","page":"Function reference","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::StandardModel, ids::Vector{String})\n\nRemove all reactions with ids from model. Note, may result in orphan metabolites.\n\nExample\n\nremove_reactions!(model, [\"EX_glc__D_e\", \"fba\"])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.@add_reactions!-Tuple{Symbol, Expr}","page":"Function reference","title":"COBREXA.@add_reactions!","text":"@add_reactions!(model::Symbol, ex::Expr)\n\nShortcut to add multiple reactions and their lower and upper bounds\n\nCall variants\n\n@add_reactions! model begin\n    reaction_name, reaction\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound, upper_bound\nend\n\nExamples\n\n@add_reactions! model begin\n    \"v1\", nothing ⟶ A, 0, 500\n    \"v2\", A ⟷ B + C, -500\n    \"v3\", B + C ⟶ nothing\nend\n\n\n\n\n\n","category":"macro"},{"location":"functions/#Analysis-functions","page":"Function reference","title":"Analysis functions","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", file), readdir(\"../src/analysis\"))","category":"page"},{"location":"functions/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M<:MetabolicModel","page":"Function reference","title":"COBREXA.flux_balance_analysis","text":"flux_balance_analysis(\n    model::M,\n    optimizer;\n    modifications = [],\n) where {M<:MetabolicModel}\n\nRun flux balance analysis (FBA) on the model optionally specifying modifications to the problem.  Basically, FBA solves this optimization problem:\n\nmax cᵀx\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n\nSee \"Orth, J., Thiele, I. & Palsson, B. What is flux balance analysis?. Nat Biotechnol 28, 245–248 (2010). https://doi.org/10.1038/nbt.1614\" for more information.\n\nThe optimizer must be set to a JuMP-compatible optimizer, such as GLPK.Optimizer or Tulip.Optimizer\n\nOptionally, you may specify one or more modifications to be applied to the model before the analysis, such as change_optimizer_attribute,change_objective, and change_sense.\n\nReturns an optimized JuMP model.\n\nExample\n\nmodel = load_model(StandardModel, \"e_coli_core.json\")\nbiomass = findfirst(model.reactions, \"BIOMASS_Ecoli_core_w_GAM\")\nsolution = flux_balance_analysis(model, GLPK.optimizer; modifications=[change_objective(biomass)])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.flux_balance_analysis_dict","text":"flux_balance_analysis_dict(model::MetabolicModel, args...)::Union{Dict{String, Float64},Nothing}\n\nA variant of FBA that returns a dictionary assigning fluxes to reactions, if the solution is found. Arguments are passed to flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_balance_analysis_vec-Tuple","page":"Function reference","title":"COBREXA.flux_balance_analysis_vec","text":"flux_balance_analysis_vec(args...)::Union{Vector{Float64},Nothing}\n\nA variant of FBA that returns a vector of fluxes in the same order as reactions of the model, if the solution is found.\n\nArguments are passed to flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._FVA_add_constraint-NTuple{4, Any}","page":"Function reference","title":"COBREXA._FVA_add_constraint","text":"_FVA_add_constraint(model, c, x, Z)\n\nInternal helper function for adding constraints to a model. Exists mainly because for avoiding namespace problems on remote workers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._FVA_optimize_reaction-Tuple{Any, Any, Any}","page":"Function reference","title":"COBREXA._FVA_optimize_reaction","text":"_FVA_get_opt(model, rid)\n\nInternal helper for creating the optimized model on a remote worker, for avoiding namespace problems.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(\n    model::MetabolicModel,\n    optimizer;\n    kwargs...\n)\n\nA simpler version of flux_variability_analysis that maximizes and minimizes all reactions in the model. Arguments are forwarded.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Function reference","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(\n    model::MetabolicModel,\n    reactions::Vector{Int},\n    optimizer;\n    modifications = [],\n    workers = [myid()],\n    bounds = z -> (z,z),\n    ret = objective_value,\n)::Matrix{Float64}\n\nFlux variability analysis solves a pair of optimization problems in model for each flux listed in reactions:\n\n min,max xᵢ\ns.t. S x = b\n    xₗ ≤ x ≤ xᵤ\n     cᵀx ≥ bounds(Z₀)[1]\n     cᵀx ≤ bounds(Z₀)[2]\n\nwhere Z₀:= cᵀx₀ is the objective value of an optimal solution of the associated FBA problem (see flux_balance_analysis). See \"Gudmundsson, S., Thiele, I. Computationally efficient flux variability analysis. BMC Bioinformatics 11, 489 (2010). https://doi.org/10.1186/1471-2105-11-489\" for more information.\n\nThe bounds is a user-supplied function that specifies the objective bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in FBA. It can return -Inf and Inf in first and second pair to remove the limit. Use gamma_bounds and objective_bounds for simple bounds.\n\noptimizer must be set to a JuMP-compatible optimizer. The computation of the individual optimization problems is transparently distributed to workers (see Distributed.workers()).\n\nret is a function used to extract results from optimized JuMP models of the individual reactions. By default, it calls and returns the value of JuMP.objective_value. More information can be extracted e.g. by setting it to a function that returns a more elaborate data structure; such as m -> (JuMP.objective_value(m), JuMP.value.(m[:x])).\n\nReturns a matrix of extracted ret values for minima and maxima, of total size (length(reactions),2). The optimizer result status is checked with is_solved; nothing is returned if the optimization failed for any reason.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_variability_analysis_dict-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.flux_variability_analysis_dict","text":"flux_variability_analysis_dict(\n    model::MetabolicModel,\n    optimizer;\n    kwargs...\n)\n\nA variant of flux_variability_analysis that returns the individual maximized and minimized fluxes of all reactions as two dictionaries (of dictionaries). All keyword arguments except ret are passed through.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.parsimonious_flux_balance_analysis","text":"parsimonious_flux_balance_analysis(\n    model::MetabolicModel,\n    optimizer;\n    modifications = [],\n    qp_modifications = [],\n    relax_bounds=[1.0, 0.999999, 0.99999, 0.9999, 0.999, 0.99],\n)\n\nRun parsimonious flux balance analysis (pFBA) on the model. In short, pFBA runs two consecutive optimization problems. The first is traditional FBA:\n\nmax cᵀx = μ\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n\nAnd the second is a quadratic optimization problem:\n\nmin Σᵢ xᵢ²\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n     μ = μ⁰\n\nWhere the optimal solution of the FBA problem, μ⁰, has been added as an additional constraint. See \"Lewis, Nathan E, Hixson, Kim K, Conrad, Tom M, Lerman, Joshua A, Charusanti, Pep, Polpitiya, Ashoka D, Adkins, Joshua N, Schramm, Gunnar, Purvine, Samuel O, Lopez‐Ferrer, Daniel, Weitz, Karl K, Eils, Roland, König, Rainer, Smith, Richard D, Palsson, Bernhard Ø, (2010) Omic data from evolved E. coli are consistent with computed optimal growth from genome‐scale models. Molecular Systems Biology, 6. 390. doi: accession:10.1038/msb.2010.47\" for more details.\n\npFBA gets the model optimum by standard FBA (using flux_balance_analysis with optimizer and modifications), then finds a minimal total flux through the model that still satisfies the (slightly relaxed) optimum. This is done using a quadratic problem optimizer. If the original optimizer does not support quadratic optimization, it can be changed using the callback in qp_modifications, which are applied after the FBA.\n\nThhe optimum relaxation sequence can be specified in relax parameter, it defaults to multiplicative range of [1.0, 0.999999, ..., 0.99] of the original bound.\n\nReturns an optimized model that contains the pFBA solution; or nothing if the optimization failed.\n\nExample\n\noptimizer = Gurobi.Optimizer\natts = Dict(\"OutputFlag\" => 0)\nmodel = load_model(StandardModel, \"iJO1366.json\")\nbiomass = findfirst(model.reactions, \"BIOMASS_Ec_iJO1366_WT_53p95M\")\nsol = pfba(model, biomass, Gurobi.optimizer)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.parsimonious_flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.parsimonious_flux_balance_analysis_dict","text":"parsimonious_flux_balance_analysis_dict(model::MetabolicModel, args...; kwargs...)\n\nPerform parsimonious flux balance analysis on model using optimizer.  Returns a dictionary mapping the reaction IDs to fluxes.  Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.parsimonious_flux_balance_analysis_vec-Tuple","page":"Function reference","title":"COBREXA.parsimonious_flux_balance_analysis_vec","text":"parsimonious_flux_balance_analysis_vec(args...; kwargs...)\n\nPerform parsimonious flux balance analysis on model using optimizer.  Returns a vector of fluxes in the same order as the reactions in model.  Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.screen-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{T}, Tuple{V}} where {V<:(AbstractVector{T} where T), T<:Tuple, N}","page":"Function reference","title":"COBREXA.screen","text":"function screen(\n    model::MetabolicModel;\n    variants::Maybe{Array{V,N}} = nothing,\n    analysis,\n    args::Maybe{Array{T,N}} = nothing,\n    workers = [myid()],\n)::Array where {V<:AbstractVector, T<:Tuple,N}\n\nTake an array of model-modifying function vectors in variants, and execute the function analysis on all variants of the model specified by variants. The computation is distributed over worker IDs in workers. If args are supplied (as an array of the same size as the variants), they are forwarded as arguments to the corresponding analysis function calls.\n\nThe array of variants must contain vectors of single-parameter functions, these are applied to model in order. The functions must not modify the model, but rather return a modified copy. The copy should be made as shallow as possible, to increase memory efficiency of the process. Variant generators that modify the argument model in-place will cause unpredictable results. Refer to the definition of screen_variant for details.\n\nThe function analysis will receive a single argument (the modified model), together with an expanded tuple of arguments from args.\n\nThe modification and analysis functions are transferred to workers as-is; all packages required to run them (e.g. the optimization solvers) must be loaded there. Typically, you want to use the macro @everywhere using MyFavoriteSolver from Distributed package for loading the solvers.\n\nReturn value\n\nThe results of running analysis are collected in to the resulting array, in a way that preserves the shape of the variants, similarly as with pmap.\n\nThe results of analysis function must be serializable, preferably made only from pure Julia structures, because they may be transferred over the network between the computation nodes. For that reason, functions that return whole JuMP models that contain pointers to allocated C structures (such as flux_balance_analysis used with GLPK or Gurobi otimizers) will generally not in this context.\n\nExample\n\n``` function reverse_reaction(i::Int)     (model::CoreModel) -> begin         mod = copy(model)         mod.S[:,i] .*= -1   # this is unrealistic but sufficient for demonstration         mod     end end\n\nm = loadmodel(CoreModel, \"ecoli_core.xml\")\n\nscreenvariants(m,            [                [reversereaction(5)],                [reversereaction(3), reversereaction(6)]            ],            mod -> mod.S[:,3])  # observe the changes in S\n\nscreenvariants(m,     [         [reversereaction(5)],         [reversereaction(3), reversereaction(6)]     ],     mod -> fluxbalanceanalysis_vec(mod, GLPK.Optimizer))  # run analysis\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.screen_variant","page":"Function reference","title":"COBREXA.screen_variant","text":"screen_variant(model::MetabolicModel, variant::Vector, analysis, args = ())\n\nHelper function for screen that applies all single-argument functions in variant to the model (in order from \"first\" to \"last\"), and executes analysis on the result.\n\nCan be used to test model variants locally.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.screen_variants-Tuple{Any, Any, Any}","page":"Function reference","title":"COBREXA.screen_variants","text":"screen_variants(model, variants, analysis; workers=[myid()])\n\nA shortcut for screen that only works with model variants.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Analysis-modifications","page":"Function reference","title":"Analysis modifications","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"modifications\", file), readdir(\"../src/analysis/modifications\"))","category":"page"},{"location":"functions/#COBREXA._do_knockout-Tuple{MetabolicModel, Any, Vector{String}}","page":"Function reference","title":"COBREXA._do_knockout","text":"_do_knockout(model::MetabolicModel, opt_model)\n\nInternal helper for knockouts on generic MetabolicModels. This can be overloaded so that the knockouts may work differently (more efficiently) with other models.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.knockout-Tuple{String}","page":"Function reference","title":"COBREXA.knockout","text":"knockout(gene_id::String)\n\nA helper variant of knockout for a single gene.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.knockout-Tuple{Vector{String}}","page":"Function reference","title":"COBREXA.knockout","text":"knockout(gene_ids::Vector{String})\n\nA modification that zeroes the bounds of all reactions that would be knocked out by the specified genes (effectively disables the reactions).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_constraint-Tuple{String, Any, Any}","page":"Function reference","title":"COBREXA.change_constraint","text":"change_constraint(id::String, lb, ub)\n\nChange the lower and upper bounds (lb and ub respectively) of reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_objective-Tuple{Union{String, Vector{String}}}","page":"Function reference","title":"COBREXA.change_objective","text":"change_objective(new_objective::Union{String,Vector{String}}; weights=[], sense=MOI.MAX_SENSE)\n\nModification that changes the objective function used in a constraint based analysis function.  new_objective can be a single reaction identifier, or an array of reactions identifiers.\n\nOptionally, the objective can be weighted by a vector of weights, and a optimization sense can be set.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_optimizer-Tuple{Any}","page":"Function reference","title":"COBREXA.change_optimizer","text":"change_optimizer(optimizer)\n\nChange the JuMP optimizer used to run the optimization.\n\nThis may be used to try different approaches for reaching the optimum, and in problems that may require different optimizers for different parts, such as the parsimonious_flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_optimizer_attribute-Tuple{Any, Any}","page":"Function reference","title":"COBREXA.change_optimizer_attribute","text":"change_optimizer_attribute(attribute_key, value)\n\nChange a JuMP optimizer attribute. The attributes are optimizer-specific, refer to the JuMP documentation and the documentation of the specific optimizer for usable keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_sense-Tuple{Any}","page":"Function reference","title":"COBREXA.change_sense","text":"change_sense(objective_sense)\n\nChange the objective sense of optimization. Possible arguments are MOI.MAX_SENSE and MOI.MIN_SENSE.\n\nIf you want to change the objective and sense at the same time, use change_objective instead to do both at once.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.constrain_objective_value-Tuple{Any}","page":"Function reference","title":"COBREXA.constrain_objective_value","text":"constrain_objective_value(tolerance)\n\nLimit the objective value to tolerance-times the current objective value, as with objective_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Flux-sampling","page":"Function reference","title":"Flux sampling","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"sampling\", file), readdir(\"../src/analysis/sampling\"))","category":"page"},{"location":"functions/#COBREXA._affine_hit_and_run_chain-NTuple{5, Any}","page":"Function reference","title":"COBREXA._affine_hit_and_run_chain","text":"_affine_hit_and_run_chain(warmup, lbs, ubs, iters, chain)\n\nInternal helper function for computing a single affine hit-and-run chain. The number of the chain is passed for possible future initialization of stable RNGs.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.affine_hit_and_run-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"Function reference","title":"COBREXA.affine_hit_and_run","text":"function affine_hit_and_run(\n    warmup_points::Matrix{Float64},\n    lbs::Vector{Float64},\n    ubs::Vector{Float64};\n    sample_iters = 100 .* (1:5),\n    workers = [myid()],\n    chains = length(workers),\n)\n\nRun a hit-and-run style sampling that starts from warmup_points and uses their affine combinations for generating the run directions to sample the space delimited by lbs and ubs.  The points that represent fluxes in warmup_points should be organized in columns, i.e. warmup_points[:,1] is the first warmup flux.\n\nThere are total chains of hit-and-run runs, each on a batch of size(warmup_points, 2) points. The runs are scheduled on workers, for good load balancing chains should be ideally much greater than length(workers).\n\nEach run continues for maximum(sample_iters) iterations; the numbers in sample_iters represent the iterations at which the whole \"current\" batch of points is collected for output. For example, sample_iters=[1,4,5] causes the process run for 5 iterations, returning the sample batch that was produced by 1st, 4th and last (5th) iteration.\n\nReturns a matrix of sampled fluxes (in columns), with all collected samples horizontally concatenated. The total number of samples (columns) will be size(warmup_points,2) * chains * length(sample_iters).\n\nExample\n\nusing COBREXA\nusing Tulip\n\nmodel = load_model(StandardModel, model_path)\n\nwarmup, lbs, ubs = warmup_from_variability(model, Tulip.Optimizer, 100)\nsamples = affine_hit_and_run(warmup, lbs, ubs, sample_iters = 1:3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.warmup_from_variability","page":"Function reference","title":"COBREXA.warmup_from_variability","text":"function warmup_from_variability(\n    model::MetabolicModel,\n    optimizer,\n    min_reactions::Vector{Int}=1:n_reactions(model),\n    max_reactions::Vector{Int}=1:n_reactions(model);\n    modifications = [],\n    workers::Vector{Int} = [myid()],\n)::Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}\n\nGenerate FVA-like warmup points for samplers, by minimizing and maximizing the specified reactions. The result is returned as a matrix, each point occupies as single column in the result.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.warmup_from_variability-Tuple{MetabolicModel, Any, Int64}","page":"Function reference","title":"COBREXA.warmup_from_variability","text":"warmup_from_variability(\n    model::MetabolicModel,\n    optimizer,\n    n_points::Int;\n    kwargs...\n)\n\nGenerates FVA-like warmup points for samplers, by selecting random points by minimizing and maximizing reactions. Can not return more than 2 times the number of reactions in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Miscellaneous-utilities","page":"Function reference","title":"Miscellaneous utilities","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"utils\", file), readdir(\"../src/base/utils\"))","category":"page"},{"location":"functions/#COBREXA.ambiguously_identified_items-Tuple{Dict{String, Dict{String, Set{String}}}}","page":"Function reference","title":"COBREXA.ambiguously_identified_items","text":"ambiguously_identified_items(\n    index::Dict{String,Dict{String,[String]}},\n)::Vector{String}\n\nFind items (genes, metabolites, ...) from the annotation index that are identified non-uniquely by at least one of their annotations.\n\nThis often indicates that the items are duplicate or miscategorized.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.annotation_index-Tuple{AbstractDict{String, V} where V}","page":"Function reference","title":"COBREXA.annotation_index","text":"annotation_index(\n    xs::AbstractDict{String};\n    annotations = _annotations,\n)::Dict{String,Dict{String,[String]}}\n\nExtract annotations from a dictionary of items xs and build an index that maps annotation \"kinds\" (e.g. \"PubChem\") to the mapping from the annotations (e.g.  \"COMPOUND_12345\") to item IDs that carry the annotations.\n\nFunction annotations is used to access the Annotations object in the dictionary values.\n\nThis is extremely useful for finding items by annotation data.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.get_atoms-Tuple{Metabolite}","page":"Function reference","title":"COBREXA.get_atoms","text":"get_atoms(met::Metabolite)::MetaboliteFormula\n\nSimple wrapper for getting the atom dictionary count out of a Metabolite.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.check_duplicate_reaction-Tuple{Reaction, OrderedCollections.OrderedDict{String, Reaction}}","page":"Function reference","title":"COBREXA.check_duplicate_reaction","text":"check_duplicate_reaction(rxn::Reaction, rxns::Dict{String, Reaction}; only_metabolites=true)\n\nCheck if rxn already exists in rxns but has another id. If only_metabolites is true then only the metabolite ids are checked. Otherwise, compares metabolite ids and the absolute value of their stoichiometric coefficients to those of rxn. If rxn has the same reaction equation as another reaction in rxns, the return the id. Otherwise return nothing.\n\nSee also: is_mass_balanced\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.is_boundary-Tuple{Reaction}","page":"Function reference","title":"COBREXA.is_boundary","text":"is_boundary(rxn::Reaction)\n\nReturn true if reaction is a boundary reaction, otherwise return false. Checks if boundary by inspecting number of metabolites in reaction equation.  Boundary reactions have only one metabolite, e.g. an exchange reaction, or a sink/demand reaction. \n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.is_mass_balanced-Tuple{Reaction, StandardModel}","page":"Function reference","title":"COBREXA.is_mass_balanced","text":"is_mass_balanced(rxn::Reaction, model::StandardModel)\n\nChecks if rxn is atom balanced. Returns a boolean for whether the reaction is balanced, and the associated balance of atoms for convenience (useful if not balanced).\n\nSee also: get_atoms, check_duplicate_reaction\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.serialize_model-Tuple{Serialized, String}","page":"Function reference","title":"COBREXA.serialize_model","text":"serialize_model(model::Serialized, filename::String)::Serialized\n\nSpecialization of serialize_model that prevents nested serialization of already-serialized models.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.serialize_model-Union{Tuple{MM}, Tuple{MM, String}} where MM<:MetabolicModel","page":"Function reference","title":"COBREXA.serialize_model","text":"serialize_model(model::MM, filename::String)::Serialized{MM} where {MM<:MetabolicModel}\n\nSerialize the model to file filename, returning a Serialized model that is able to load itself back automatically upon precaching by precache!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{Gene}","page":"Function reference","title":"Base.copy","text":"Base.copy(g::Gene)\n\nShallow copy of a Gene\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{Metabolite}","page":"Function reference","title":"Base.copy","text":"Base.copy(m::Metabolite)\n\nShallow copy of a Metabolite\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{Reaction}","page":"Function reference","title":"Base.copy","text":"Base.copy(r::Reaction)\n\nShallow copy of a Reaction\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{StandardModel}","page":"Function reference","title":"Base.copy","text":"Base.copy(m::StandardModel)\n\nShallow copy of a StandardModel\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.atom_exchange-Tuple{Dict{String, Float64}, StandardModel}","page":"Function reference","title":"COBREXA.atom_exchange","text":"atom_exchange(flux_dict::Dict{String, Float64}, model::StandardModel)\n\nReturn a dictionary mapping the flux of atoms across the boundary of the model  given flux_dict (the solution of a constraint based analysis) of reactions in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_fluxes-Tuple{Dict{String, Float64}, StandardModel}","page":"Function reference","title":"COBREXA.metabolite_fluxes","text":"metabolite_fluxes(flux_dict::Dict{String, Float64}, model::StandardModel)\n\nReturn two dictionaries of metabolite ids mapped to reactions that consume or  produce them given the flux distribution supplied in fluxdict.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.set_bound-Tuple{Any, Any}","page":"Function reference","title":"COBREXA.set_bound","text":"set_bound(index, optimization_model;\n    ub=_constants.default_reaction_rate,\n    lb=-_constants.default_reaction_rate)\n\nHelper function to set the bounds of variables. The JuMP set_normalized_rhs function is a little confusing,  so this function simplifies setting constraints. In short, JuMP uses a normalized right hand side representation of constraints,  which means that lower bounds have their sign flipped. This function does this for you, so you don't have to remember to do this whenever you change the constraints. \n\nJust supply the constraint index and the JuMP model (opt_model) that  will be solved, and the variable's bounds will be set to ub and lb.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gamma_bounds-Tuple{Any}","page":"Function reference","title":"COBREXA.gamma_bounds","text":"gamma_bounds(gamma)\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to be at least gamma*Z₀, as usual in COBRA packages. Use as the bounds argument:\n\nflux_variability_analysis(model, some_optimizer; bounds = gamma_bounds(0.9))\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective_bounds-Tuple{Any}","page":"Function reference","title":"COBREXA.objective_bounds","text":"(tolerance) = z -> begin\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to a small multiple of Z₀. Use as bounds argument, similarly to gamma_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._parse_formula-Tuple{String}","page":"Function reference","title":"COBREXA._parse_formula","text":"_parse_formula(f::String)::MetaboliteFormula\n\nParse a formula in format C2H6O into a MetaboliteFormula, which is basically a dictionary of atom counts in the molecule.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._unparse_formula-Tuple{Dict{String, Int64}}","page":"Function reference","title":"COBREXA._unparse_formula","text":"_unparse_formula(f::MetaboliteFormula)::String\n\nFormat MetaboliteFormula to String.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._parse_grr-Tuple{SBML.GeneProductAssociation}","page":"Function reference","title":"COBREXA._parse_grr","text":"_parse_grr(gpa::SBML.GeneProductAssociation)::GeneAssociation\n\nParse SBML.GeneProductAssociation structure to the simpler GeneAssociation. The input must be (implicitly) in a positive DNF.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._parse_grr-Tuple{String}","page":"Function reference","title":"COBREXA._parse_grr","text":"_parse_grr(s::String)::GeneAssociation\n\nParse a DNF gene association rule in format (YIL010W and YLR043C) or (YIL010W and YGR209C) to GeneAssociation. Also acceptsOR,|,||,AND,&, and&&`.\n\nExample\n\njulia> _parse_grr(\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\")\n2-element Array{Array{String,1},1}:\n [\"YIL010W\", \"YLR043C\"]\n [\"YIL010W\", \"YGR209C\"]\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._unparse_grr-Tuple{Type{SBML.GeneProductAssociation}, Vector{Vector{String}}}","page":"Function reference","title":"COBREXA._unparse_grr","text":"_unparse_grr(\n    ::Type{SBML.GeneProductAssociation},\n    x::GeneAssociation,\n)::SBML.GeneAssociation\n\nConvert a GeneAssociation to the corresponding SBML.jl structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._unparse_grr-Tuple{Type{String}, Vector{Vector{String}}}","page":"Function reference","title":"COBREXA._unparse_grr","text":"unparse_grr(grr::Vector{Vector{Gene}}\n\nConverts a nested string gene reaction array  back into a gene reaction rule string.\n\nExample\n\njulia> _unparse_grr(String, [[\"YIL010W\", \"YLR043C\"], [\"YIL010W\", \"YGR209C\"]])\n\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\"\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._guesskey-Tuple{Any, Any}","page":"Function reference","title":"COBREXA._guesskey","text":"_guesskey(ks, possibilities)\n\nUnfortunately, many model types that contain dictionares do not have standardized field names, so we need to try a few possibilities and guess the best one. The keys used to look for valid field names should be ideally specified as constants in src/base/constants.jl.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Logging-and-debugging-helpers","page":"Function reference","title":"Logging and debugging helpers","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"logging\", file), readdir(\"../src/base/logging\"))","category":"page"},{"location":"functions/#COBREXA.log_io","page":"Function reference","title":"COBREXA.log_io","text":"log_io(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of messages and warnings from model input/output.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.log_models","page":"Function reference","title":"COBREXA.log_models","text":"log_models(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of model-related messages.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.log_perf","page":"Function reference","title":"COBREXA.log_perf","text":"log_perf(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of performance-related tracing information.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.@_make_logging_tag-Tuple{Symbol, String}","page":"Function reference","title":"COBREXA.@_make_logging_tag","text":"macro _make_logging_group(sym::Symbol, doc::String)\n\nThis creates a group of functions that allow masking out topic-related logging actions. A call that goes as follows:\n\n@_make_logging_tag XYZ\n\ncreates the following tools:\n\nglobal variable _XYZ_log_enabled defaulted to false\nfunction log_XYZ that can be called to turn the logging on/off\na masking macro @_XYZ_log that can be prepended to commands that should only happen if the logging of tag XYZ is enabled.\n\nThe masking macro is then used as follows:\n\n@_XYZ_log @info \"This is the extra verbose information you wanted!\" a b c\n\nThe user can direct logging with these:\n\nlog_XYZ()\nlog_XYZ(false)\n\ndoc should be a name of the stuff that is being printed if the corresponding log_XYZ() is enabled – it is used to create a friendly documentation for the logging switch. In this case it could say \"X, Y and Z-related messages\".\n\n\n\n\n\n","category":"macro"},{"location":"advanced/4_advanced_screening/#Advanced-model-screening","page":"Advanced model screening","title":"Advanced model screening","text":"","category":"section"},{"location":"advanced/4_advanced_screening/#Example:-Gene-knockouts","page":"Advanced model screening","title":"Example: Gene knockouts","text":"","category":"section"},{"location":"unmerged/#Generic-interface","page":"Generic interface","title":"Generic interface","text":"","category":"section"},{"location":"unmerged/","page":"Generic interface","title":"Generic interface","text":"The reason you should rather use the generic interface is that the generic interface is supported by all model types in COBREXA, while the internal model structure of each model type varies considerably. For example, MATModels store the stoichiometric matrix directly, so mat_model.mat[\"S\"] would return the stoichiometric matrix. However, JSONModels do not do this, so json_model.m[\"S\"] would throw an error. The COBREXA way of doing this is to use the generic interface, i.e. stoichiometry(json_model) and stoichiometry(mat_model) always return the stoichiometric matrix. ","category":"page"},{"location":"unmerged/","page":"Generic interface","title":"Generic interface","text":"Note, it is possible that the matrix returned by stoichiometry is not exactly the same between models. The order of the reactions (columns) and metabolites (rows) may vary from model type to model type, although they are consistent within each model type. So stoichiometry(json_model) will return a stoichiometric matrix where the columns correspond to the order of reactions listed in reactions(json_model) and the rows corresponds to the order of metabolites listed in metabolites(json_model). The column/reaction and row/metabolite order from the JSONModel is not necessarily consistent with the stoichiometric matrix returned by stoichiometry(mat_model). This is a minor note, but could cause confusion. ","category":"page"},{"location":"unmerged/#Converting-models","page":"Generic interface","title":"Converting models","text":"","category":"section"},{"location":"unmerged/","page":"Generic interface","title":"Generic interface","text":"You might recall that we mentioned that data loss does not occur when models are read into the format corresponding to their file type. This is because the models are read into memory directly in their native formats. So JSONModels contain the dictionary encoded in the .json file, and the same for .mat and .xml files (technically .xml is parsed by SBML.jl).","category":"page"},{"location":"unmerged/","page":"Generic interface","title":"Generic interface","text":"However, this data loss guarantee does not hold once you convert between models. The reason for this is that the convert function uses the generic interface to convert between models. In short, only information accessible through the generic interface will be converted between models. This is most applicable for data stored using non-standard keywords (.mat and to a lesser extent .json models are prone to this type of issue). When in doubt, inspect your models and refer to src/base/constants.jl for the keynames used to access model features if issues occur. However, this should rarely be a problem.","category":"page"},{"location":"unmerged/","page":"Generic interface","title":"Generic interface","text":"COBREXA also has specialized model types: StandardModel, CoreModel, and CoreCoupledModel. These model types are implemented to be as efficient as possible for their purpose. In short, use:","category":"page"},{"location":"unmerged/","page":"Generic interface","title":"Generic interface","text":"StandardModel if keeping all the meta-data associated with a model is important. This includes information like gene reaction rules, annotations, notes, etc. It is a good format to use when you wish to combine many models of different types and are not worried about memory limitations. \nCoreModel if you only care about constraint-based analysis that can be performed using only the stoichiometric matrix and flux bounds. This model stores all its numeric data structures as sparse matrices/vectors and is thus very efficient. It does not store superfluous information, like the gene reaction rules of reactions, annotations etc. Since this model is compact and its data structures efficient, it is ideal for distributed computing.\nCoreModelCoupled if you want to use the functionality of CoreModel but for communities. It also represents the underlying model in a sparse format, but specialized for community models. ","category":"page"},{"location":"unmerged/","page":"Generic interface","title":"Generic interface","text":"Let's load a StandardModel and a CoreModel to compare the two.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/4_basic_core_coupled_usage.jl\"","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Basic-usage-of-CoreModel-and-CoreModelCoupled","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"In this tutorial we will introduce COBREXA's CoreModel and CoreModelCoupled. We will use E. coli's toy model to start with.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Loading-a-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Loading a CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"model = load_model(CoreModel, \"e_coli_core.xml\") # we specifically want to load a CoreModel from the model file","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Basic-analysis-on-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic analysis on CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"As before, for optimization based analysis we need to load an optimizer. Here we will use Tulip.jl to optimize the linear programs of this tutorial. Refer to the constraint-based analysis basics tutorial if you are confused by any functions in this section.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"All the normal analysis functions work on CoreModel, due to it also having the same generic accessor interface as all the other model types.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"using Tulip\n\ndict_sol = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"),\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n        change_constraint(\"R_EX_o2_e\", 0, 0),\n    ],\n)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Structure-of-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Structure of CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"CoreModel is a special COBREXA type that is optimized for large scale analysis of large models. It stores data in a sparse format where possible.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"fieldnames(CoreModel)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"model.S","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#CoreModelCoupled-adds-coupling-constraints-to-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"CoreModelCoupled adds coupling constraints to CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"CoreModelCoupled extends CoreModel by adding coupling constraints.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"fieldnames(CoreModelCoupled)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"In short, coupling constraints can be used to ensure that fluxes scale with the growth rate (μ) of a model. This reduces the impact of biologically infeasible cycles from occurring. Here we will model coupling constraints by assuming that they have the form: -γ ≤ vᵢ/μ  ≤ γ, where γ is the ratio between each individual flux (vᵢ) in the model and the growth rate.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"gamma = 40 # arbitrary\n\nnr = n_reactions(model) # number of reactions\nbiomass_index = first(indexin([\"R_BIOMASS_Ecoli_core_w_GAM\"], reactions(model)))\n\nusing LinearAlgebra, SparseArrays\n\nCf = sparse(1.0I, nr, nr)\nCf[:, biomass_index] .= -gamma\nCb = sparse(1.0I, nr, nr)\nCb[:, biomass_index] .= gamma\nC = [Cf; Cb] # coupling constraint matrix\n\nclb = spzeros(2 * nr)\nclb[1:nr] .= -1000.0\ncub = spzeros(2 * nr)\ncub[nr+1:end] .= 1000\n\ncmodel = CoreModelCoupled(model, C, clb, cub)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"d = flux_balance_analysis_dict(model, Tulip.Optimizer)\nd[\"R_BIOMASS_Ecoli_core_w_GAM\"]","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"dc = flux_balance_analysis_dict(cmodel, Tulip.Optimizer)\ndc[\"R_BIOMASS_Ecoli_core_w_GAM\"]","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/4_modifying/#Modifying-and-saving-the-models","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Making a small modification to the model and reanalyzing them is often a useful way to explore how the constraints work together, and to inspect the degrees of freedom in the model.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With COBREXA.jl, you have two main choices of making model modifications:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"you can manually change the model structures (i.e. permanently change the data in of your model variable)\nyou can use special arguments of analysis functions that allow you to make the modifications in a declarative way and \"on the fly\", without having to manually interact with the model","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"tip: Notebook available\nThe available notebooks demonstrate model export and serialization and various model modifications (1, 2, 3).","category":"page"},{"location":"tutorials/4_modifying/#Manual-modifications","page":"Modifying and saving the models","title":"Manual modifications","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Certain model types, including CoreModel and StandardModel, are built from mutable structs that you are free to modify as you want.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"CoreModel consists of sparse matrices and vectors that describe the model precisely. For example, modifying a bound of the reaction is as simple as writing to the .xl or .xu (lower and upper bound for x) vectors in the structure:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"using COBREXA\nm = load_model(CoreModel, \"e_coli_core.xml\")\nm.xl[3] = 0.0","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"The available field names can be listed using e.g. fieldnames(CoreModel), or more conveniently by employing the completion in the shell:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"julia> m.   # press [Tab]\nS    b     c     mets  rxns  xl    xu","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With CoreModel, you may need to find the proper metabolites by identifier. For that, you may examine the reactions and metabolites of the model, e.g. using","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"indexin([\"M_nadh_c\", \"M_co2_e\"], metabolites(m))","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...which will return the numeric indexes of NADH and CO₂ metabolites. These can be used to, e.g., change the \"balance\" of the metabolites in the model:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m.b[64] = -1      # model will be losing 1 flux unit of CO₂","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or to modify existing reaction (here with index 5) directly in stoichiometry matrix:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m.S[5,8] = -1\nm.S[5,64] = 1","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"While this works well if you are used to working with matrix-like representations of the model, it is not really convenient if you want to change the reactions and models in an easy way. StandardModel is structured in a much more user-friendly way, which makes the manual modifications easier.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"In particular, StandardModel consists of dictionaries of Reaction, Metabolite and Gene objects that may be modified and indexed directly using their names. That way, the above modifications may be written in a cleaner, semantic and declarative fashion, as follows:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = load_model(StandardModel, \"e_coli_core.xml\")\nm.reactions[\"R_TPI\"].lb = 0.0                         # change lower bound of the reaction to 0\nm.reactions[\"R_GLNS\"].metabolites[\"M_nadh_c\"] = -1.0  # update stoichiometry\nm.reactions[\"R_GLNS\"].metabolites[\"M_co2_e\"] = 1.0\n...","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"There are other functions that may be used to change the StandardModel in a more systematic way. See the documentation of add!, rm!, @add_reactions!, and set_bound for examples.","category":"page"},{"location":"tutorials/4_modifying/#Analysis-modifiers","page":"Modifying and saving the models","title":"Analysis modifiers","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Some analysis functions, including flux_balance_analysis and flux_variability_analysis, accept a special argument modifications, which is a list of descriptions of small changes that should be applied to the model before modification.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"These include e.g.:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"change_objective that sets a new optimization objective\nchange_optimizer that chooses a different JuMP.jl optimizer for the analysis\nchange_optimizer_attribute that can set various optimizer parameters\nchange_constraint that changes the flux bounds of a reaction\nknockout that disables reactions that depend on genes","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"This way, you can easily check out the model state when maximizing the rate of \"TALA\" (transadenolase A) reaction:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = load_model(StandardModel, \"e_coli_core.xml\")\nflux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[change_objective(\"R_TALA\")])","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or knock out a gene combination that disables the transadenolase A completely (see m.reactions[\"R_TALA\"].grr):","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"flux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[knockout([\"G_b0008\", \"G_b2464\"])])","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or do both at once– knock out some other genes, and try to maximize the transadenolase A reaction rate:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"flux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[\n    knockout([\"G_s0001\"]),\n    change_objective(\"R_TALA\"),\n  ])","category":"page"},{"location":"tutorials/4_modifying/#Exporting-the-modified-models-in-native-formats","page":"Modifying and saving the models","title":"Exporting the modified models in native formats","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Manually modified models can be exported in standard formats so that they can be examined in other environments, or just made accessible for publication.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"COBREXA.jl supports export of MATLAB-like and JSON models. Simply use save_model:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"save_model(m, \"myModel.json\")\nsave_model(m, \"myModel.mat\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"The function automatically guesses the appropriate model format to write into the file from the file extension. If required, you can choose the model format manually by using save_json_model and save_mat_model.","category":"page"},{"location":"tutorials/4_modifying/#Using-Serialization-for-quick-and-efficient-model-storage","page":"Modifying and saving the models","title":"Using Serialization for quick & efficient model storage","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"If you save the model \"just for yourself\", such as for the use in an immediately following analysis, it may be inconvenient (and unnecessarily inefficient) to encode and decode the models to and from the external format. Moreover, certain model types (such as CoreModelCoupled) cannot be fully represented in all model formats, thus increasing the chance for accidental data loss.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Instead of that, we recommend using the Serialization package. It provides a straightforward way to save any Julia data structure to the disk, using a very efficient data format that can be written to and read from the disk very quickly.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With any model in m, you can write it to disk as follows:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"using Serialization\nopen(f -> serialize(f, m), \"myModel\", \"w\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...and read it back with:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = deserialize(\"myModel\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"One great advantage of Serialization is speed – models with millions of reactions are usually loaded and saved with minimal overhead in less than a second.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"warning: Limits of `Serialization`\nSerialized models are great for quickly exchanging data objects between analysis steps. The avoided need for re-encoding can save you a great deal of analysis time that can be used for better purposes. Despite that, do not rely on the stability of the serialized format – it often changes between Julia versions, and the data stored in one version may not open easily after an upgrade. In short, use serialized data within one workflow, and use standard and stable external formats for publishing and storing the data beyond the scope of a single analysis workflow.","category":"page"},{"location":"howToContribute/#Contributing-to-COBREXA.jl","page":"How to contribute","title":"Contributing to COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":":+1::tada: Thanks for taking the time to contribute to COBREXA.jl! :tada::+1:","category":"page"},{"location":"howToContribute/#How-to-report-a-bug-or-suggest-an-enhancement","page":"How to contribute","title":"How to report a bug or suggest an enhancement","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Please use the GitHub issue tracker to report any problems with the software, and discuss any potential questions about COBREXA use.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Before creating bug reports, please check the open issues, you might find out that the issue is already reported and known.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"General guidelines for reporting issues:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If creating a bug report, include a complete description of how we can reproduce the bug, including e.g. links to datasets and any external scripts used. Ideally, try to create a code snippet that causes the problem on a fresh installation of COBREXA.jl (often called the \"minimal crashing example\")\nIf possible, use the supplied issue templates and fill in all fields.\nIf your issue is already described in an issue that is \"closed\", do not reopen it. Instead, open a new issue and include a link to the original issue. (The fact that the original issue might have been mistakenly closed may be an issue on its own.)\nEnhancement proposals should refer a viable way for implementing the enhancement. If there are multiple possibilities for implementation, we will welcome a discussion about which one is optimal for COBREXA.jl.","category":"page"},{"location":"howToContribute/#How-to-test-a-development-version-of-the-package?","page":"How to contribute","title":"How to test a development version of the package?","text":"","category":"section"},{"location":"howToContribute/#Step-1:-Load-COBREXA.jl-from-the-source-from-the-git-repository","page":"How to contribute","title":"Step 1: Load COBREXA.jl from the source from the git repository","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"There are two ways that you can retrieve a local copy of the development repo: you can either clone the repository manually, or use Julia package manager to get a development version for you.","category":"page"},{"location":"howToContribute/#Option-1:-Using-Julia-package-manager","page":"How to contribute","title":"Option 1: Using Julia package manager","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When you are used to using the Julia package manager for developing or contributing to packages, you can type:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This will install the COBREXA package locally and check it out for development. You can check the location of the package with:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status\n    Status `~/.julia/environments/v1.4/Project.toml`\n  [a03a9c34] COBREXA v0.0.5 [`~/.julia/dev/COBREXA`]","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The default location of the package is ~/.julia/dev/COBREXA.","category":"page"},{"location":"howToContribute/#Option-2:-Cloning-with-git-manually","page":"How to contribute","title":"Option 2: Cloning with git manually","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You can use git to get the sources as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git clone git@github.com:LCSB-BioCore/COBREXA.jl.git","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the cloning process finishes, you shold see the package cloned in a new directory COBREXA.jl. To install this version to your Julia, change to the directory first, and start Julia:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd COBREXA.jl\n$ julia","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With Julia, you can install the development version of the package from the directory as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> add .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(press ] to get into the packaging environment)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This adds the COBREXA.jl package and all its dependencies. You can verify that the installation worked by typing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If you are planning to develop the package, it is often easier to install the package in development mode, with dev command:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"That causes the package to always load with whatever code changes that you added to the source directory.","category":"page"},{"location":"howToContribute/#Finally:-load-COBREXA.jl","page":"How to contribute","title":"Finally: load COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With both of above options, you should get COBREXA.jl installed, which means that the following command should, without errors, load the package and make COBREXA.jl functions available for testing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"julia> using COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You may now freely modify the code and test the result.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Remember that if you want to work in the environment of the package, you need to activate it. That causes, among other, that the additional dependencies specified with packaging add command will be written automaticaly to Project.toml file of your local COBREXA.jl clone, not to your global environment. Activation is simple: when in the directory of the package, just type the command into the packaging shell:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> activate","category":"page"},{"location":"howToContribute/#Step-2:-Publish-your-changes","page":"How to contribute","title":"Step 2: Publish your changes","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You are expected to make a fork of the main COBREXA.jl repository, and open a pull request from that one to the master branch of the main repository. For creating the fork, just hit the \"Fork\" button on GitHub.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After that, change the directory to your repository and adjust the remotes:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd ~/.julia/dev/COBREXA             # or any other directory, as needed\n$ git remote rename origin upstream   # renames the origin (the main COBREXA.jl repo) to upstream\n$ git remote add origin git@github.com:yourUsername/COBREXA.jl.git  # adds the link to your clone as new origin\n$ git fetch origin                    # fetches the refs from your repo","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"In the above code, change yourUsername is your GitHub username.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the renaming is done, start a new branch at upstream/master. In the code snippet, substitute yn for your initials (Your Name here) and give the new feature a better name than somefeature:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git checkout -b yn-somefeature origin/master","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Commit any changes and features that you like to the new branch. When the commits look complete to you, push the branch to your repository fork:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git push -u origin yn-somefeature","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This makes your changes visible in your repository. After that, you can navigate to GitHub's pull request page, where you should immediately see a big green button that helps you to create a pull request for this branch. Read the section below for precise details and guidelines on submitting the pull requests.","category":"page"},{"location":"howToContribute/#How-to-submit-a-pull-request-(PR)-with-your-modification/enhancement?","page":"How to contribute","title":"How to submit a pull request (PR) with your modification/enhancement?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Make a fork of the repository, commit the modifications in a separate branch and push the branch to your fork.\nMake a pull request where you describe the motivation and expected outcome for the users. Specifically, consider any possible incompatibilities, and the necessity to increment the version number after your changes are applied. Label your pull request with a semantic emoji in the title to indicate what it addresses.\nAfter submitting the pull request, verify that all status checks (tests, documentation) are passing. Make sure any new contribution is properly documented and tested (you may want to check with coverage tools, using test --coverage from the Julia packaging shell)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After you submitted a pull request, a label might be assigned that allows us to track and manage issues and pull requests.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Tip: if you commit many small, partial changes, you may help us save energy by prefixing your commit names with [skip ci], which deactivates the CI trigger on that commit. With each skipped CI, you may save as much as 15Wh of energy. Testing just the \"final\" commit of the pull-request branch is sufficient.","category":"page"},{"location":"howToContribute/#For-developers:-What-is-the-expected-branch-management/workflow?","page":"How to contribute","title":"For developers: What is the expected branch management/workflow?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The workflow is based on GitLab flow, i.e., a master branch with feature branches being merged into the master branch. Depending on your access rights, you may open the feature branch in this repository, on in your fork.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The guidelines can be summarized as such:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"when making a contribution, create one new branch and open one new PR for each new independent feature or bugfix\ndo not push to another branch unless it is your own\ntry to get a review before merging unless the change is trivial and non-impacting\nconsider prefixing your branch names with your initials, so that one can easily see who owns which branch (e.g. ad-somefeature would be committed by Arthur Dent)","category":"page"},{"location":"advanced/3_custom_models_on_hpc/#Using-customized-models-on-HPC","page":"Using customized models on HPC","title":"Using customized models on HPC","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/2_finding_balance.jl\"","category":"page"},{"location":"notebooks/2_finding_balance/#Finding-balance-and-variability-of-constraint-based-models","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Here we use flux_balance_analysis, flux_variability_analysis, and parsimonious_flux_balance_analysis of COBREXA.jl functions to analyze a toy model of E. coli.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"If it is not already present, download the model.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"tip: Tip: use `?` to get quick help about functions\nWhen you are unsure about how a function works, write ?   function_name to see the function reference documentation.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"notebooks/2_finding_balance/#Optimization-solvers-in-COBREXA","page":"Finding balance and variability of constraint-based models","title":"Optimization solvers in COBREXA","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"To actually perform any optimization based analysis we need to load an optimizer. Any JuMP.jl-supported optimizers will work. Here, we will use Tulip.jl to optimize linear programs and OSQP.jl to optimize quadratic programs.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"note: Note: OSQP can be sensitive\nWe recommend reading the docs of OSQP before using it, since   it may give inconsistent results depending on what settings   you use. Commercial solvers like Gurobi, Mosek, CPLEX, etc.   require less user engagement.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"import Pkg\nPkg.add(\"Tulip\")\nPkg.add(\"OSQP\")\n\nusing Tulip\nusing OSQP","category":"page"},{"location":"notebooks/2_finding_balance/#Flux-balance-analysis-(FBA)","page":"Finding balance and variability of constraint-based models","title":"Flux balance analysis (FBA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Most analysis functions come in several variants that produce different types of output. All of them usually require a model and JuMP.jl-compatible optimizer to work in the model.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"In the case of FBA, you may choose from these variants (here using the Tulip optimizer):","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"vec_soln = flux_balance_analysis_vec(model, Tulip.Optimizer)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"notebooks/2_finding_balance/#Modifications","page":"Finding balance and variability of constraint-based models","title":"Modifications","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Often it is desirable to add a slight modififaction to the problem before performing analysis, to see e.g. differences of the model behavior caused by the change introduced.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"COBREXA.jl supports several modifications by default, which include changing objective sense, optimizer attributes, flux constraints, optimization objective, reaction and gene knockouts, and others.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [ # modifications are applied in order\n        # this changes the objective to maximize the biomass production\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"),\n\n        # this fixes a specific rate of the glucose exchange\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n\n        # this knocks out two genes, i.e. constrains their associated reactions to zero.\n        knockout([\"b0978\", \"b0734\"]), ## the gene IDs are cytochrome oxidase (CYTBD)\n\n        # ignore the optimizer specified above and change it to Tulip\n        change_optimizer(Tulip.Optimizer),\n\n        # set a custom attribute of the Tulip optimizer (see Tulip docs for more possibilities)\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 110),\n\n        # explicitly tell the optimizer to maximize the new objective\n        change_sense(MAX_SENSE),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/#Flux-variability-analysis-(FVA)","page":"Finding balance and variability of constraint-based models","title":"Flux variability analysis (FVA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"The default FVA in flux_variability_analysis returns maximized and minimized reaction fluxes in a matrix. Here we use the dictionary variant in fluxvariabilityanalysis_dict, to show how to easily access specific fluxes from its results.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_mins, fva_maxs = flux_variability_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.99), # the objective function is allowed to vary by ~1% from the FBA optimum\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"R_EX_glc__D_e\", -10, -10),\n        change_constraint(\"R_EX_o2_e\", 0.0, 0.0),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_maxs[\"R_EX_ac_e\"][\"R_EX_ac_e\"] # get the maximal acetate exchange flux","category":"page"},{"location":"notebooks/2_finding_balance/#Parsimonious-flux-balance-analysis-(pFBA)","page":"Finding balance and variability of constraint-based models","title":"Parsimonious flux balance analysis (pFBA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Parsimonious flux balance analysis (here in parsimonious_flux_balance_analysis finds a unique flux solution that minimizes the squared sum of fluxes of the system subject, while maintaining the same objective value as the flux balance analysis solution. Since we are optimizing a quadratic objective, we also need to switch to a quadratic optimizer. In this case, OSQP will work. We demonstrate it on the dictionary-returning variant of pFBA, parsimonious_flux_balance_analysis_dict:","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = parsimonious_flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [\n        change_optimizer_attribute(\"verbose\", false), # silence the optimizer (OSQP is very verbose by default)\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"The function also has the expectable second variant that returns a vector of solutions, in parsimonious_flux_balance_analysis_vec. Here, we utilize it to show how to use different optimizers for finding the optimum and for solving the quadratic problem. That may be preferable if the optimizer qualities differ for the differing tasks. pFBA allows you to specify qp_modifications that are applied after the original optimum is found, and before the quadratic part of the problem solving begins.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"vec_soln = parsimonious_flux_balance_analysis_vec(\n    model,\n    Tulip.Optimizer; # start with Tulip\n    modifications = [\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500), # we may change Tulip-specific attributes here\n    ],\n    qp_modifications = [\n        change_optimizer(OSQP.Optimizer), # now switch to OSQP (Tulip wouldn't be able to finish the computation)\n        change_optimizer_attribute(\"verbose\", false), # and silence it.\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/1_loading_converting_saving.jl\"","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Loading,-converting,-and-saving-models","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"COBREXA can load models stored in .mat, .json, and .xml formats (with the latter denoting SBML formatted models).","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"We will primarily use the E. Coli \"core\" model to demonstrate the utilities found in COBREXA. First, let's download the model in several formats.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"# Downloads the model files if they don't already exist\n!isfile(\"e_coli_core.mat\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.mat\", \"e_coli_core.mat\");\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\");\nnothing #hide","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Now, load the package:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using COBREXA","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"tip: Save bandwidth!\nThe published models usually do not change very often. It is therefore pretty useful to save them to a central location and load them from there. That saves your time, and does not unnecessarily consume the connectivity resources of the model repository.","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Loading-models","page":"Loading, converting, and saving models","title":"Loading models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Load the models using the load_model function. Each model is able to \"pretty-print\" itself, hiding the inner complexity.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"mat_model = load_model(\"e_coli_core.mat\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"json_model = load_model(\"e_coli_core.json\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"sbml_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"note: Note: `load_model` infers the output type from the file extension\nNotice how each model was read into memory as a model type corresponding   to its file type, i.e. the file ending with .json loaded as a   JSONModel, the file ending with .mat loaded as MATModel, and the   file ending with .xml loaded as an SBMLModel.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"You can directly inspect the model objects, although only with a specific way for each specific type.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"JSON models contain their corresponding JSON:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"json_model.json","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"SBML models contain a complicated structure from SBML.jl package:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"typeof(sbml_model.sbml)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"MAT models contain MATLAB data:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"mat_model.mat","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Using-the-generic-interface-to-access-model-details","page":"Loading, converting, and saving models","title":"Using the generic interface to access model details","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"To prevent the complexities of object representation, COBREXA.jl uses a set of generic interface functions that extract various important information from all supported model types. This approach ensures that the analysis functions can work on any data.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"For example, you can check the reactions and metabolites contained in SBML and JSON models using the same accessor:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"reactions(json_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"reactions(sbml_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"issetequal(reactions(json_model), reactions(mat_model)) # do models contain the same reactions?","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"All accessors are defined in a single file in COBREXA source code; you may therefore get a list of all accessors as follows:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using InteractiveUtils\n\nfor method in filter(\n    x -> endswith(string(x.file), \"MetabolicModel.jl\"),\n    InteractiveUtils.methodswith(MetabolicModel, COBREXA),\n)\n    println(method.name)\nend","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Converting-between-model-types","page":"Loading, converting, and saving models","title":"Converting between model types","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"It is possible to convert model types to-and-fro. To do this, use the convert function, which is overloaded from Julia's Base.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"danger: Data loss may occur when converting between models\nThe conversion of models only uses the data accessible through the generic accessors. Other data may get lost.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m = convert(MATModel, json_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m will now contain the MATLAB-style matrix representation of the model:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Matrix(m.mat[\"S\"])","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"The loading and conversion can be combined using a shortcut:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m = load_model(MATModel, \"e_coli_core.json\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Saving-and-exporting-models","page":"Loading, converting, and saving models","title":"Saving and exporting models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"COBREXA.jl supports exporting the models in JSON and MAT format, using save_model.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"save_model(m, \"converted_model.json\")\nsave_model(m, \"converted_model.mat\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"If you need a non-standard suffix, use the type-specific saving functions:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"save_json_model(m, \"file.without.a.good.suffix\")\nsave_mat_model(m, \"another.file.matlab\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"If you are saving the models only for future processing in Julia environment, it is often wasteful to encode the models to external formats and decode them back. Instead, you can use the \"native\" Julia data format, accessible with package Serialization.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This way, you can use serialize to save even the StandardModel that has no file format associated:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using Serialization\n\nsm = convert(StandardModel, m)\n\nopen(f -> serialize(f, sm), \"myModel.stdmodel\", \"w\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"The models can then be loaded back using deserialize:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"sm2 = deserialize(\"myModel.stdmodel\")\nissetequal(metabolites(sm), metabolites(sm2))","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This form of loading operation is usually pretty quick:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"t = @elapsed deserialize(\"myModel.stdmodel\")\n@info \"Deserialization took $t seconds\"","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Notably, large and complicated models with thousands of reactions and annotations can take seconds to decode properly. Serialization allows you to almost completely remove this overhead, and scales well to tens of millions of reactions.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/3_basic_stdmodel_usage.jl\"","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Basic-usage-of-StandardModel","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"In this tutorial we will use COBREXA's StandardModel and functions that specifically operate on it. As usual we will use the toy model of E. coli for demonstration.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Loading-a-model","page":"Basic usage of StandardModel","title":"Loading a model","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model = load_model(StandardModel, \"e_coli_core.json\") # we specifically want to load a StandardModel from the model file","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"note: Note: Loading `StandardModel`s implicitly uses `convert`\nWhen using load_model(StandardModel, file_location) the model at   file_location is first loaded into its inferred format and is then   converted to a StandardModel using the generic accessor interface.   Thus, data loss may occur. Always check your model to ensure that   nothing important has been lost.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Basic-analysis","page":"Basic usage of StandardModel","title":"Basic analysis","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"As before, for optimization based analysis we need to load an optimizer. Here we will use Tulip.jl to solve the linear programs of this tutorial. Refer to the basic constraint-based analysis tutorial for more informaiton.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"All the normal analysis functions work on StandardModel, due to it also having the same generic accessor interface as all the other model types.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"using Tulip\n\ndict_sol = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [\n        change_objective(\"BIOMASS_Ecoli_core_w_GAM\"),\n        change_constraint(\"EX_glc__D_e\", -12, -12),\n        change_constraint(\"EX_o2_e\", 0, 0),\n    ],\n)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"This is not very exciting yet, since every other model type can also do this. However, deeper inspection of flux results is possible when using StandardModel.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Inspecting-the-flux-solution:-atom_exchange","page":"Basic usage of StandardModel","title":"Inspecting the flux solution: atom_exchange","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"It is sometimes interesting to keep track of the atoms entering and leaving the system through boundary reactions. This can be inspected by calling atom_exchange.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"atom_exchange(dict_sol, model) # flux of individual atoms entering and leaving the system through boundary reactions (e.g. exchange reactions) based on flux_dict","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Inspecting-the-flux-solution:-metabolite_fluxes","page":"Basic usage of StandardModel","title":"Inspecting the flux solution: metabolite_fluxes","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another useful flux result analysis function is metabolite_fluxes. This function keeps track of reactions consuming and producing each metabolite.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"consuming, producing = metabolite_fluxes(dict_sol, model)\n\nconsuming[\"atp_c\"] # reactions consuming atp_c","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Internals-of-StandardModel","page":"Basic usage of StandardModel","title":"Internals of StandardModel","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another benefit of StandardModel is that it supports a richer internal infrastructure that can be used to manipulate internal model attributes in a systematic way. Specifically, the genes, reactions, and metabolites with of a model each have a type. This is particularly useful when modifying or even constructing a model from scratch.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Genes,-Reactions,-and-Metabolites","page":"Basic usage of StandardModel","title":"Genes, Reactions, and Metabolites","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel is composed of ordered dictionaries of Genes, Metabolites and Reactions. Ordered dictionaries are used because the order of the reactions and metabolites are important for constructing a stoichiometric matrix since the rows and columns should correspond to the order of the metabolites and reactions returned by calling the accessors metabolites and reactions.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Each StandardModel is composed of the following fields:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(StandardModel) # fields of a StandardModel","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The :genes field of a StandardModel contains an ordered dictionary of gene ids mapped to Genes.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model.genes # the keys of this dictionary are the same as genes(model)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The Gene type is a struct that can be used to store information about genes in a StandardModel. Each Gene is composed of the following fields:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(Gene)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"tip: Tip: Use <tab> complete to explore the structure of types\nUse <tab> to quickly explore the fields of a struct. For example,   Gene.<tab> will list all the fields shown above.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The keys used in the ordered dictionaries in model.genes are the ids returned using the generic accessor genes. Genes have pretty printing, as demonstrated below for a random gene drawn from the model:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_gene_id = genes(model)[rand(1:n_genes(model))]\nmodel.genes[random_gene_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The same idea holds for both metabolites (stored as Metabolites) and reactions (stored as Reactions). This is demonstrated below.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_metabolite_id = metabolites(model)[rand(1:n_metabolites(model))]\nmodel.metabolites[random_metabolite_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_reaction_id = reactions(model)[rand(1:n_reactions(model))]\nmodel.reactions[random_reaction_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel can be used to build your own metabolic model or modify an existing one. One of the main use cases for StandardModel is that it can be used to merge multiple models or parts of multiple models together. Since the internals are uniform inside each StandardModel, attributes of other model types are squashed into the required format (using the generic accessors). This ensures that the internals of all StandardModels are the same - allowing easy systematic evaluation.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"warning: Warning: Combining models with different namespaces is tricky\nCombining models that use different namespaces requires care.   For example, in some models the water exchange reaction is called   EX_h2o_e, while in others it is called R_EX_h2o_s. This needs to   manually addressed (for now) to prevent duplicate, e.g. reactions,   from being added.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-annotation_index","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: annotation_index","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Often when models are automatically reconstructed duplicate genes, reactions or metabolites end up in a model. COBREXA exports annotation_index to check for cases where the id of a struct may be different, but the annotations the same (possibly suggesting a duplication). annotation_index builds a dictionary mapping annotation features to the ids of whatever struct you are inspecting. This makes it easy to find structs that share certain annotation features.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations = annotation_index(model.reactions)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations[\"ec-code\"]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The annotation_index function can also be used on Reactions and Genes in the same way.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-check_duplicate_reaction","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: check_duplicate_reaction","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another useful function is check_duplicate_reaction, which checks for reactions that have duplicate (or similar) reaction equations.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"pgm_duplicate = Reaction()\npgm_duplicate.id = \"pgm2\" # Phosphoglycerate mutase\npgm_duplicate.metabolites = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1)\npgm_duplicate","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"check_duplicate_reaction(pgm_duplicate, model.reactions; only_metabolites = false) # can also just check if only the metabolites are the same but different stoichiometry is used","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-is_mass_balanced","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: is_mass_balanced","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Finally, is_mass_balanced can be used to check if a reaction is mass balanced based on the formulas of the reaction equation.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"pgm_duplicate.metabolites = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1, \"h2o_c\" => 1) # not mass balanced now\nis_bal, extra_atoms = is_mass_balanced(pgm_duplicate, model) # extra_atoms shows which atoms are in excess/deficit","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"advanced/5_debugging/#Tracing-and-debugging","page":"Tracing and debugging","title":"Tracing and debugging","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<br>\n<div align=\"center\">\n    <img class=\"docs-light-only\" src=\"assets/header.svg?maxAge=0\" width=\"80%\">\n    <img class=\"docs-dark-only\" src=\"assets/header-dark.svg?maxAge=0\" width=\"80%\">\n</div>\n<br>","category":"page"},{"location":"#Constraint-Based-Reconstruction-and-EXascale-Analysis","page":"Home","title":"Constraint-Based Reconstruction and EXascale Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository Tests Coverage How to contribute?\n(Image: GitHub) (Image: CI) (Image: codecov) (Image: contrib)","category":"page"},{"location":"","page":"Home","title":"Home","text":"COBREXA is a toolkit for working with large constraint-based metabolic models, and a running very large number of analysis tasks on these models in parallel. Its main purpose is to make the methods of Constraint-based Reconstruction and Analysis (COBRA) scale to problem sizes that require the use of huge computer clusters and HPC environments, which allows them to be realistically applied to pre-exascale-sized models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package, you will find the usual COBRA-like functions that interface to underlying linear programming solvers. We use JuMP.jl as the unified interface for many solvers; you can plug in whichever compatible solver you want, including the popular Tulip.jl, GLPK.jl, OSQP.jl, and Gurobi.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n<img style=\"width:300px;margin:10px;border-offset:15px;border: 1px solid #eee;border-radius: 50%;padding: 10px;-webkit-border-radius: 50%;-moz-border-radius: 50%;\" src=\"assets/output.gif\" alt=\"history\"><br>\nDevelopment history of COBREXA.jl.\n</div>","category":"page"},{"location":"#Quick-start-guide","page":"Home","title":"Quick start guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install COBREXA from Julia repositories. Start julia, press ] to switch to the Packaging environment, and type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add COBREXA","category":"page"},{"location":"","page":"Home","title":"Home","text":"You also need to install your favorite solver supported by JuMP.jl, typing e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add Tulip","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the packages are installed, switch back to the \"normal\" julia shell by pressing Backspace (the prompt should change color back to green). After that, you can download a SBML model from the internet and perform a flux balance analysis as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using COBREXA   # loads the package\nusing Tulip     # loads the optimization solver\n\n# download the model\ndownload(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\n# open the SBML file and load the contents\nmodel = load_model(\"e_coli_core.xml\")\n\n# run a FBA\nfluxes = flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The variable fluxes will now contain a dictionary of the computed optimal flux of each reaction in the model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dict{String,Float64} with 95 entries:\n  \"R_EX_fum_e\"    => 0.0\n  \"R_ACONTb\"      => 6.00725\n  \"R_TPI\"         => 7.47738\n  \"R_SUCOAS\"      => -5.06438\n  \"R_GLNS\"        => 0.223462\n  \"R_EX_pi_e\"     => -3.2149\n  \"R_PPC\"         => 2.50431\n  \"R_O2t\"         => 21.7995\n  \"R_G6PDH2r\"     => 4.95999\n  \"R_TALA\"        => 1.49698\n  ⋮               => ⋮","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed tutorial content is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"tutorials\", filter(x -> endswith(x, \".md\"), readdir(\"tutorials\")))\nDepth = 1","category":"page"},{"location":"#Example-notebooks-and-workflows","page":"Home","title":"Example notebooks and workflows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed notebook content is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"notebooks\", filter(x -> endswith(x, \".md\"), readdir(\"notebooks\")))\nDepth = 1","category":"page"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"#Contribution-guide","page":"Home","title":"Contribution guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you wish to contribute code, patches or improvements to COBREXA.jl, please read the basic contribution guidelines and hints..","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"COBREXA.jl is developed at the Luxembourg Centre for Systems Biomedicine of the University of Luxembourg (uni.lu/lcsb), cooperating with the Institute for Quantitative and Theoretical Biology at the Heinrich Heine University in Düsseldorf (qtb.hhu.de).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The development was supported by European Union's Horizon 2020 Programme under PerMedCoE project (permedcoe.eu) agreement no. 951773.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/cobrexa.svg\" alt=\"COBREXA logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/unilu.svg\" alt=\"Uni.lu logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/lcsb.svg\" alt=\"LCSB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/hhu.svg\" alt=\"HHU logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/qtb.svg\" alt=\"QTB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/permedcoe.svg\" alt=\"PerMedCoE logo\" height=\"64px\" style=\"height:64px; width:auto\">","category":"page"},{"location":"tutorials/1_loading/#Loading-and-converting-model-data","page":"Loading and converting model data","title":"Loading and converting model data","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"COBREXA.jl supports several constraint-based model formats that can be loaded with built-in functions. You can load SBML models that are compatible with libsbml, JSON models (such as the ones from CobraPy), and MATLAB-style models (such as those from COBRA Toolbox).","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"These formats are commonly available from many model repositories, such as from BIGG, as seen e.g. on the BIGG entry for the core E. Coli entry. Here, we show how to load the basic formats and work with such models.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"tip: Notebook available!\nExample code for this tutorial is available here.","category":"page"},{"location":"tutorials/1_loading/#Loading-models-from-files","page":"Loading and converting model data","title":"Loading models from files","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"For most purposes, you should be able to open and load any model with load_model, which detects the file type from the extension (.xml, .json and .mat), and calls the appropriate loading function. After loading the COBREXA.jl library with using COBREXA and you may load the downloaded model data into Julia as follows:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"my_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"You should see some information about the loaded model, possibly looking like this:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Metabolic model of type JSONModel\n\n  [9 ,  1]  =  1.0\n  [51,  1]  =  1.0\n  ⋮\n  [57, 95]  =  1.0\n  [59, 95]  =  -1.0\nNumber of reactions: 95\nNumber of metabolites: 72","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"If the file type can not be guessed from the file extension, use any of the specific loader functions:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"load_sbml_model for SBML\nload_json_model for JSON\nload_mat_model for MATLAB models","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"All formats may store slightly different information. By default, COBREXA attempts not to discard any information unless a conversion to a more strict format is required. For example, the JSONModel (which is returned by load_json_model) still holds the original JSON structure that you can freely access for any specific purposes:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"jm = load_json_model(\"e_coli_core.json\")\njm.json[\"reactions\"][1]","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"That should print out the first reaction in the model in a JSON-style scheme, in our case the process catalyzed by phosphofructokinase:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Dict{String,Any} with 9 entries:\n  \"name\"               => \"Phosphofructokinase\"\n  \"metabolites\"        => Dict{String,Any}(\"adp_c\"=>1.0,\"atp_c\"=>-1.0,\"f6p_c\"=>…\n  \"lower_bound\"        => 0.0\n  \"id\"                 => \"PFK\"\n  \"notes\"              => Dict{String,Any}(\"original_bigg_ids\"=>Any[\"PFK\"])\n  \"gene_reaction_rule\" => \"b3916 or b1723\"\n  \"upper_bound\"        => 1000.0\n  \"subsystem\"          => \"Glycolysis/Gluconeogenesis\"\n  \"annotation\"         => Dict{String,Any}(\"ec-code\"=>Any[\"2.7.1.11\"],\"metanetx…","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"MATModel and SBMLModel (returned by the respective loading functions) contain similar \"full\" model information – you can access the whole MATLAB and SBML data and build on them without any restrictions.","category":"page"},{"location":"tutorials/1_loading/#Converting-to-other-model-types","page":"Loading and converting model data","title":"Converting to other model types","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Despite JSON and SBML are great for storing and exchanging the models, the data representation is not very suitable for analyzing the model and processing it mathematically.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"COBREXA.jl contains several model types that are much better suited  for supporting the analysis tasks. You can use the following:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"CoreModel, which represents the \"core\" of the optimization problem and the corresponding linear programming problem – a sparse representation of the stoichiometric matrix, flux bounds vectors, objective vector, etc.\nStandardModel (a \"standard\" for COBREXA.jl), which represents a highly flexible, object-like, dictionary-based representation of a model that contains individual Reactions, Metabolites, Genes, and other things.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"note: Conversion limitations and possible data loss\nBecause of the specifics of the format of each model structure, the conversion is not always able to preserve all information from the source data. You may need to check if any complicated and less-standard annotations are still present. If you require them, and either use a more complicated model, or collect them manually.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"A loaded model can be converted to any other model type using the standard Julia conversion:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"cm = convert(CoreModel, jm)","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"You can also use a shortcut in load_model to convert the model to the desired format in one command:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"cm = load_model(CoreModel, \"e_coli_core.xml\")","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"With CoreModel, the information is easily accessible in matrix form. For example, cm.S now contains the sparse stoichiometric matrix, which you can convert to a dense matrix and manipulate it in Julia as any other matrix:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Matrix(cm.S)","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"...should show you the (relatively empty) stoichiometry of the model.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"StandardModel is more suitable for fine-grained access to individual items of the model, perhaps closer to the SBML-style models. For example, you can view and set reaction bounds as follows:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"sm = load_model(StandardModel, \"e_coli_core.json\")\nsm.reactions[\"PGI\"].ub","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"...this prints the upper bound of the reaction (in this case, 1000.0); you can change it the usual way:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"sm.reactions[\"PGI\"].ub = 500","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"This change will naturally project to future analysis results.","category":"page"}]
}
